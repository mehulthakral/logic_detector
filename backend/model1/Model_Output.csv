Label,Time,Space,Cyclomatic,Halstead,Composite Metric,Code,Scaled_Time,Scaled_Space,Scaled_Cyclomatic,Scaled_Halstead,Index,Model_Rank
SORT,6.042111958181761,4.224068605678045,1,0.0,-0.3814625344583516,def SORT(l:list)->list:\n	l.sort()\n	return l\n,-0.3814625344583516,-0.19259325591079188,-0.9090909090909091,-0.8387096774193549,1,1.0
SORT,9.950546241344783,5.596862466893343,7,4.909090909090909,0.010052784736923885,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        # radix sort implementation, O(n) time complexity, where n == len(nums)\n        nums = [num + 50000 for num in nums] # unsorted array\n        A = [0] * len(nums) # each loop's sorted array\n        I = [0] * 10 # set up index array\n        for i in range(6): # because there are 6 digits\n            for num in nums:\n                I[num // (10 ** i) % 10] += 1 # find out how many occurrences of each digit\n            I = list(accumulate(I, lambda a, b: a + b)) # calculate the prefix sum\n            for j in reversed(range(len(nums))):\n                # invariant: The list is sorted at digit [j + 1:], waiting to be sorted at digit j\n                A[I[nums[j] // (10 ** i) % 10] - 1] = nums[j] # update A from the back\n                I[nums[j] // (10 ** i) % 10] -= 1 # update I at that position\n            nums[:], I[:] = A[:], [0] * 10 # copy result to nums to begin new loop, and refresh I\n        return [num - 50000 for num in nums]\n\n\n    return sortArray(l)\n",0.010052784736923885,0.3911553026043101,0.18181818181818182,0.4281524926686217,2,10.0
SORT,22.429600786211477,4.725778414484649,3,0.5,1.2601034877603348,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L = len(N)\n        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]\n\n\n    return sortArray(l)\n",1.2601034877603348,0.02074713404729718,-0.5454545454545454,-0.7096774193548387,3,16.0
SORT,50.058454425786735,1.0,5,3.0,4.027738470980204,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L, B = len(N), 1\n        while B:\n            B = 0\n            for i in range(L-1):\n                if N[i] > N[i+1]: N[i], N[i+1], B = N[i+1], N[i], 1\n        return N\n\n\n    return sortArray(l)\n",4.027738470980204,-1.563553204298257,-0.18181818181818182,-0.06451612903225806,4,17.0
SORT,19.881161391348044,3.0288999710752442,5,0.5,1.0048214513121463,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L = len(N)\n        for i in range(1,L):\n            for j in range(0,i):\n                if N[i] < N[j]:\n                    N.insert(j, N.pop(i))\n                    break\n        return N		\n\n\n    return sortArray(l)\n",1.0048214513121463,-0.7008108312823863,-0.18181818181818182,-0.7096774193548387,5,15.0
SORT,13.754959486333338,1.0,3,0.0,0.39114811807255684,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L = len(N)\n        for i in range(1,L): insort_left(N, N.pop(i), 0, i)\n        return N\n\n\n    return sortArray(l)\n",0.39114811807255684,-1.563553204298257,-0.5454545454545454,-0.8387096774193549,6,11.0
SORT,6.712076646321034,4.628196886128023,3,1.0,-0.3143508933962599,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        C, m, M, S = Counter(N), min(N), max(N), []\n        for n in range(m,M+1): S.extend([n]*C[n])\n        return S\n\n\n    return sortArray(l)\n",-0.3143508933962599,-0.02074713404729718,-0.5454545454545454,-0.5806451612903226,7,2.0
SORT,19.559619198790788,5.448820210460132,7,5.0,0.9726119564010733,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        def quicksort(A, I, J):\n            if J - I <= 1: return\n            p = partition(A, I, J)\n            quicksort(A, I, p), quicksort(A, p + 1, J)\n        \n        def partition(A, I, J):\n            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\n            for j in range(I,J):\n                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\n            A[J-1], A[i] = A[i], A[J-1]\n            return i\n        \n        quicksort(N,0,len(N))\n        return N\n\n\n    return sortArray(l)\n",0.9726119564010733,0.32820378727941996,0.18181818181818182,0.45161290322580644,8,14.0
SORT,9.19006779657376,5.118994600117699,9,4.714285714285714,-0.0661257920216187,"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        def mergesort(A):\n            LA = len(A)\n            if LA == 1: return A\n            LH, RH = mergesort(A[:LA//2]), mergesort(A[LA//2:])\n            return merge(LH,RH)\n\n        def merge(LH, RH):\n            LLH, LRH = len(LH), len(RH)\n            S, i, j = [], 0, 0\n            while i < LLH and j < LRH:\n                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])\n                else: j, _ = j + 1, S.append(RH[j])\n            return S + (RH[j:] if i == LLH else LH[i:])\n        \n        return mergesort(N)		\n\n\n    return sortArray(l)\n",-0.0661257920216187,0.1879531421983641,0.5454545454545454,0.37788018433179726,9,4.0
SORT,18.236936973550677,5.563069639450127,12,6.125,0.840116354302907,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        # Hoareâ€™s Partition Scheme works by initializing two indexes that start at two ends, \n		# the two indexes move toward each other until an inversion is found\n        # the partition function will seperate the array by two, smaller than pivot, and greater than pivot\n        # and return the final position of the pivot element.\n        def partition(nums, left, right):\n            if left > right: return\n            \n            # use the left most element as the pivot element\n            pivot_index = left\n            pivot=nums[left]\n            \n            # if the element we are looking for is greater than pivot, then it is on the correct side\n            # when right pointer meet the left pointer, we know all the elements are in the correct sides\n            # just need to put the pivot to the correct position\n            while True:\n                while left < right and nums[right] >=pivot:\n                    right -=1\n            # do the opposite thing to the left hand side\n                while left < right and nums[left] <=pivot:\n                    left +=1\n            # if both of the numbers from the left hand side and the right hand side are on the wron side,\n            # we exchange them.\n                if left < right:\n                    nums[left],nums[right] = nums[right],nums[left]\n            # if all the elements are on the correct side, break the loop, just need to insert the pivot now.        \n                else:\n                    break\n            # insert the pivot to the correct position to seperate the array by two\n            nums[right],nums[pivot_index] = nums[pivot_index],nums[right]\n            return right\n        \n        def Hoare_quicksort(nums, start, end):\n            if end < start: return\n            p = partition(nums,start,end)\n            Hoare_quicksort(nums,start,p-1)\n            Hoare_quicksort(nums,p+1,end)\n            \n        Hoare_quicksort(nums,0,len(nums)-1)\n        return nums\n\n\n    return sortArray(l)\n",0.840116354302907,0.37678569121147965,1.0909090909090908,0.7419354838709677,10,13.0
SORT,9.208327155191084,2.951033268738094,12,7.411764705882353,-0.06429671723119473,"def sortArray(l:list)->list:\n    def sortArray(nums:list)->list:\n\n        def partition(nums, left, right):\n            if left > right: return\n            \n            # use the middle  element as the pivot\n            pivot_index = left + (right-left)//2\n            pivot=nums[pivot_index]\n\n            while left<=right:\n                while left <= right and nums[left] <pivot:\n                    left +=1\n                while left <= right and nums[right] >pivot:\n                    right -=1\n                if left <= right:\n                    nums[left],nums[right] = nums[right],nums[left]\n                    left +=1\n                    right -=1\n                else:\n                    break\n            return (left,right)\n        \n        def Hoare_quicksort(nums, start, end):\n            if end < start: return\n            p = partition(nums,start,end)\n            Hoare_quicksort(nums,start,p[1])\n            Hoare_quicksort(nums,p[0],end)\n            \n        Hoare_quicksort(nums,0,len(nums)-1)\n        return nums\n\n\n    return sortArray(l)\n",-0.06429671723119473,-0.7339218296120237,1.0909090909090908,1.0740037950664136,11,5.0
SORT,9.359458273111438,4.920146824164079,10,7.764705882352941,-0.04915762480028891,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        # Merge Sort\n        \n        # merge takes two sorted array, and return the merged sorted array\n        # Leetcode #88\n        def merge(left, right):\n            l = len(left)-1\n            r = len(right)-1\n            end = l+r+1\n            \n            for _ in range(r+1):\n                left.append(None)\n                \n            while l>=0 and r>=0:\n                if left[l] >=right[r]:\n                    left[end]=left[l]\n                    l-=1\n                else:\n                    left[end]=right[r]\n                    r-=1\n                end-=1\n            if l ==-1:\n                for _ in range(r+1):\n                    left[_]=right[_]\n            \n            return left\n        \n        # if there is only one number, return the number\n        # if both left and right are sorted arrays, merge these two\n        if len(nums)<=1: return nums\n        mid = len(nums)//2\n        leftarray = sortArray(nums[:mid])\n        rightarray= sortArray(nums[mid:])\n        return merge(leftarray,rightarray)\n\n\n    return sortArray(l)\n",-0.04915762480028891,0.10339776512660198,0.7272727272727273,1.1650853889943074,12,6.0
SORT,9.738114590869898,1.0,13,6.375,-0.011226898997593385,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        def heapify(nums, n, i):\n            # \n            if i > n: return\n            largest = i\n            l = 2*i+1\n            r = 2*i+2\n\n            if l < n and nums[l] > nums[largest]:largest = l\n            if r < n and nums[r] > nums[largest]:largest = r\n            # swap the largest element with the parent node of the tree\n            if largest != i: \n                nums[i], nums[largest] = nums[largest],nums[i]\n                heapify(nums, n, largest) # \n        \n        \n        def build_heap(nums):\n            n = len(nums)\n            lastNode = n-1\n            lastParent = (lastNode-1)//2\n            for i in range(lastParent+1)[::-1]:\n                heapify(nums, n, i)\n        build_heap(nums)\n\n        def heap_sort(nums):\n            n = len(nums)\n            for i in range(n)[::-1]:\n                nums[0],nums[i]=nums[i],nums[0]\n                heapify(nums, i, 0)\n        heap_sort(nums)\n\n        return nums\n\n\n    return sortArray(l)\n",-0.011226898997593385,-1.563553204298257,1.2727272727272727,0.8064516129032258,13,8.0
SORT,7.274240684874857,4.590026001387766,5,1.7142857142857142,-0.25803784908011346,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        count = [0]*100000\n        for num in nums:\n            count[num+50000] += 1 # count the number of times we see the number\n        nums = []\n        for i,counter in enumerate(count):\n            for _ in range(counter):\n                nums.append(i-50000) # this line runs at most n times total\n        return nums\n\n\n    return sortArray(l)\n",-0.25803784908011346,-0.036978412153862536,-0.18181818181818182,-0.39631336405529954,14,3.0
SORT,9.717409174998625,5.119514789826819,9,5.0,-0.013301000010071437,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        block_size = 1;\n        while block_size <= len(nums):\n            for l in range(0, len(nums), block_size * 2):\n                r = min((l + (2 * block_size)), len(nums));\n                mid = l + block_size;\n                \n                L = nums[l:mid];\n                R = nums[mid:r];\n                \n                srt = [];\n                i = j = 0;\n                \n                while i < len(L) and j < len(R):\n                    if L[i] <= R[j]:\n                        srt.append(L[i]);\n                        i += 1;\n                    else:\n                        srt.append(R[j]);\n                        j += 1;\n                while i < len(L):\n                    srt.append(L[i]);\n                    i += 1;\n                while j < len(R):\n                    srt.append(R[j]);\n                    j += 1;\n                nums[l:r] = srt;\n            block_size = block_size * 2;\n        return nums;\n\n\n    return sortArray(l)\n",-0.013301000010071437,0.18817434073474448,0.5454545454545454,0.45161290322580644,15,7.0
SORT,9.749835584158701,6.106581488507133,12,3.5,-0.010052784736923885,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        \n        nums = [[num] for num in nums]\n\n        def merge(l1, l2):\n            i = 0\n            j = 0\n            new = []\n            \n            while i < len(l1) and j < len(l2):\n                if l1[i] < l2[j]:\n                    new.append(l1[i])\n                    i += 1\n                else:\n                    new.append(l2[j])\n                    j += 1\n                    \n            while i < len(l1):\n                new.append(l1[i])\n                i += 1\n                \n            while j < len(l2):\n                new.append(l2[j])\n                j += 1\n                \n            return new\n\n        \n        while len(nums) > 1:\n            new = []\n            for i in range(0, len(nums), 2):\n                if i + 1 < len(nums):\n                    new_arr = merge(nums[i], nums[i+1])\n                    new.append(new_arr)\n                else:\n                    new.append(nums[i])\n            nums = new\n            \n        return nums[0]\n\n\n    return sortArray(l)\n",-0.010052784736923885,0.6079014234322154,1.0909090909090908,0.06451612903225806,16,9.0
SORT,16.850326775577926,6.04334946208366,5,1.5,0.7012169652054949,"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n	\n        if len(nums) <=1: return nums\n        less , greater , base = [] , [] , nums.pop()\n        for i in nums:\n            if i < base: less.append(i)\n            else: greater.append(i)\n        return sortArray(less) + [base] + sortArray(greater)\n\n\n    return sortArray(l)\n",0.7012169652054949,0.5810134795685868,-0.18181818181818182,-0.45161290322580644,17,12.0

{
	"MIN": [
		"n",
		[
			5.107132044716761,
			1.0,
			1,
			0,
			"def MIN(l:list)->int:\n\treturn min(l)\n"
		]
	],
	"MAX": [
		"n",
		[
			5.189771130449446,
			1.0,
			1,
			0,
			"def MAX(l:list)->int:\n\treturn max(l)\n"
		]
	],
	"SORT": [
		"n",
		[
			6.042111958181761,
			4.224068605678045,
			1,
			0,
			"def SORT(l:list)->list:\n\tl.sort()\n\treturn l\n"
		],
		[
			9.950546241344783,
			5.596862466893343,
			7,
			4.909090909090909,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        # radix sort implementation, O(n) time complexity, where n == len(nums)\n        nums = [num + 50000 for num in nums] # unsorted array\n        A = [0] * len(nums) # each loop's sorted array\n        I = [0] * 10 # set up index array\n        for i in range(6): # because there are 6 digits\n            for num in nums:\n                I[num // (10 ** i) % 10] += 1 # find out how many occurrences of each digit\n            I = list(accumulate(I, lambda a, b: a + b)) # calculate the prefix sum\n            for j in reversed(range(len(nums))):\n                # invariant: The list is sorted at digit [j + 1:], waiting to be sorted at digit j\n                A[I[nums[j] // (10 ** i) % 10] - 1] = nums[j] # update A from the back\n                I[nums[j] // (10 ** i) % 10] -= 1 # update I at that position\n            nums[:], I[:] = A[:], [0] * 10 # copy result to nums to begin new loop, and refresh I\n        return [num - 50000 for num in nums]\n\n\n    return sortArray(l)\n"
		],
		[
			22.429600786211477,
			4.725778414484649,
			3,
			0.5,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L = len(N)\n        return [N.pop(min(range(L-i), key = lambda x: N[x])) for i in range(L)]\n\n\n    return sortArray(l)\n"
		],
		[
			50.058454425786735,
			1.0,
			5,
			3.0,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L, B = len(N), 1\n        while B:\n            B = 0\n            for i in range(L-1):\n                if N[i] > N[i+1]: N[i], N[i+1], B = N[i+1], N[i], 1\n        return N\n\n\n    return sortArray(l)\n"
		],
		[
			19.881161391348044,
			3.0288999710752442,
			5,
			0.5,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L = len(N)\n        for i in range(1,L):\n            for j in range(0,i):\n                if N[i] < N[j]:\n                    N.insert(j, N.pop(i))\n                    break\n        return N\t\t\n\n\n    return sortArray(l)\n"
		],
		[
			13.754959486333338,
			1.0,
			3,
			0,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        L = len(N)\n        for i in range(1,L): insort_left(N, N.pop(i), 0, i)\n        return N\n\n\n    return sortArray(l)\n"
		],
		[
			6.712076646321034,
			4.628196886128023,
			3,
			1.0,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        C, m, M, S = Counter(N), min(N), max(N), []\n        for n in range(m,M+1): S.extend([n]*C[n])\n        return S\n\n\n    return sortArray(l)\n"
		],
		[
			19.559619198790788,
			5.448820210460132,
			7,
			5.0,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        def quicksort(A, I, J):\n            if J - I <= 1: return\n            p = partition(A, I, J)\n            quicksort(A, I, p), quicksort(A, p + 1, J)\n        \n        def partition(A, I, J):\n            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\n            for j in range(I,J):\n                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\n            A[J-1], A[i] = A[i], A[J-1]\n            return i\n        \n        quicksort(N,0,len(N))\n        return N\n\n\n    return sortArray(l)\n"
		],
		[
			9.19006779657376,
			5.118994600117699,
			9,
			4.714285714285714,
			"def sortArray(l:list)->list:\n    def sortArray(N:list):\n        def mergesort(A):\n            LA = len(A)\n            if LA == 1: return A\n            LH, RH = mergesort(A[:LA//2]), mergesort(A[LA//2:])\n            return merge(LH,RH)\n\n        def merge(LH, RH):\n            LLH, LRH = len(LH), len(RH)\n            S, i, j = [], 0, 0\n            while i < LLH and j < LRH:\n                if LH[i] <= RH[j]: i, _ = i + 1, S.append(LH[i])\n                else: j, _ = j + 1, S.append(RH[j])\n            return S + (RH[j:] if i == LLH else LH[i:])\n        \n        return mergesort(N)\t\t\n\n\n    return sortArray(l)\n"
		],
		[
			18.236936973550677,
			5.563069639450127,
			12,
			6.125,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        # Hoare\u2019s Partition Scheme works by initializing two indexes that start at two ends, \n\t\t# the two indexes move toward each other until an inversion is found\n        # the partition function will seperate the array by two, smaller than pivot, and greater than pivot\n        # and return the final position of the pivot element.\n        def partition(nums, left, right):\n            if left > right: return\n            \n            # use the left most element as the pivot element\n            pivot_index = left\n            pivot=nums[left]\n            \n            # if the element we are looking for is greater than pivot, then it is on the correct side\n            # when right pointer meet the left pointer, we know all the elements are in the correct sides\n            # just need to put the pivot to the correct position\n            while True:\n                while left < right and nums[right] >=pivot:\n                    right -=1\n            # do the opposite thing to the left hand side\n                while left < right and nums[left] <=pivot:\n                    left +=1\n            # if both of the numbers from the left hand side and the right hand side are on the wron side,\n            # we exchange them.\n                if left < right:\n                    nums[left],nums[right] = nums[right],nums[left]\n            # if all the elements are on the correct side, break the loop, just need to insert the pivot now.        \n                else:\n                    break\n            # insert the pivot to the correct position to seperate the array by two\n            nums[right],nums[pivot_index] = nums[pivot_index],nums[right]\n            return right\n        \n        def Hoare_quicksort(nums, start, end):\n            if end < start: return\n            p = partition(nums,start,end)\n            Hoare_quicksort(nums,start,p-1)\n            Hoare_quicksort(nums,p+1,end)\n            \n        Hoare_quicksort(nums,0,len(nums)-1)\n        return nums\n\n\n    return sortArray(l)\n"
		],
		[
			9.208327155191084,
			2.951033268738094,
			12,
			7.411764705882353,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list)->list:\n\n        def partition(nums, left, right):\n            if left > right: return\n            \n            # use the middle  element as the pivot\n            pivot_index = left + (right-left)//2\n            pivot=nums[pivot_index]\n\n            while left<=right:\n                while left <= right and nums[left] <pivot:\n                    left +=1\n                while left <= right and nums[right] >pivot:\n                    right -=1\n                if left <= right:\n                    nums[left],nums[right] = nums[right],nums[left]\n                    left +=1\n                    right -=1\n                else:\n                    break\n            return (left,right)\n        \n        def Hoare_quicksort(nums, start, end):\n            if end < start: return\n            p = partition(nums,start,end)\n            Hoare_quicksort(nums,start,p[1])\n            Hoare_quicksort(nums,p[0],end)\n            \n        Hoare_quicksort(nums,0,len(nums)-1)\n        return nums\n\n\n    return sortArray(l)\n"
		],
		[
			9.359458273111438,
			4.920146824164079,
			10,
			7.764705882352941,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        # Merge Sort\n        \n        # merge takes two sorted array, and return the merged sorted array\n        # Leetcode #88\n        def merge(left, right):\n            l = len(left)-1\n            r = len(right)-1\n            end = l+r+1\n            \n            for _ in range(r+1):\n                left.append(None)\n                \n            while l>=0 and r>=0:\n                if left[l] >=right[r]:\n                    left[end]=left[l]\n                    l-=1\n                else:\n                    left[end]=right[r]\n                    r-=1\n                end-=1\n            if l ==-1:\n                for _ in range(r+1):\n                    left[_]=right[_]\n            \n            return left\n        \n        # if there is only one number, return the number\n        # if both left and right are sorted arrays, merge these two\n        if len(nums)<=1: return nums\n        mid = len(nums)//2\n        leftarray = sortArray(nums[:mid])\n        rightarray= sortArray(nums[mid:])\n        return merge(leftarray,rightarray)\n\n\n    return sortArray(l)\n"
		],
		[
			9.738114590869898,
			1.0,
			13,
			6.375,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        def heapify(nums, n, i):\n            # \n            if i > n: return\n            largest = i\n            l = 2*i+1\n            r = 2*i+2\n\n            if l < n and nums[l] > nums[largest]:largest = l\n            if r < n and nums[r] > nums[largest]:largest = r\n            # swap the largest element with the parent node of the tree\n            if largest != i: \n                nums[i], nums[largest] = nums[largest],nums[i]\n                heapify(nums, n, largest) # \n        \n        \n        def build_heap(nums):\n            n = len(nums)\n            lastNode = n-1\n            lastParent = (lastNode-1)//2\n            for i in range(lastParent+1)[::-1]:\n                heapify(nums, n, i)\n        build_heap(nums)\n\n        def heap_sort(nums):\n            n = len(nums)\n            for i in range(n)[::-1]:\n                nums[0],nums[i]=nums[i],nums[0]\n                heapify(nums, i, 0)\n        heap_sort(nums)\n\n        return nums\n\n\n    return sortArray(l)\n"
		],
		[
			7.274240684874857,
			4.590026001387766,
			5,
			1.7142857142857142,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        count = [0]*100000\n        for num in nums:\n            count[num+50000] += 1 # count the number of times we see the number\n        nums = []\n        for i,counter in enumerate(count):\n            for _ in range(counter):\n                nums.append(i-50000) # this line runs at most n times total\n        return nums\n\n\n    return sortArray(l)\n"
		],
		[
			9.717409174998625,
			5.119514789826819,
			9,
			5.0,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        block_size = 1;\n        while block_size <= len(nums):\n            for l in range(0, len(nums), block_size * 2):\n                r = min((l + (2 * block_size)), len(nums));\n                mid = l + block_size;\n                \n                L = nums[l:mid];\n                R = nums[mid:r];\n                \n                srt = [];\n                i = j = 0;\n                \n                while i < len(L) and j < len(R):\n                    if L[i] <= R[j]:\n                        srt.append(L[i]);\n                        i += 1;\n                    else:\n                        srt.append(R[j]);\n                        j += 1;\n                while i < len(L):\n                    srt.append(L[i]);\n                    i += 1;\n                while j < len(R):\n                    srt.append(R[j]);\n                    j += 1;\n                nums[l:r] = srt;\n            block_size = block_size * 2;\n        return nums;\n\n\n    return sortArray(l)\n"
		],
		[
			9.749835584158701,
			6.106581488507133,
			12,
			3.5,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n        \n        nums = [[num] for num in nums]\n\n        def merge(l1, l2):\n            i = 0\n            j = 0\n            new = []\n            \n            while i < len(l1) and j < len(l2):\n                if l1[i] < l2[j]:\n                    new.append(l1[i])\n                    i += 1\n                else:\n                    new.append(l2[j])\n                    j += 1\n                    \n            while i < len(l1):\n                new.append(l1[i])\n                i += 1\n                \n            while j < len(l2):\n                new.append(l2[j])\n                j += 1\n                \n            return new\n\n        \n        while len(nums) > 1:\n            new = []\n            for i in range(0, len(nums), 2):\n                if i + 1 < len(nums):\n                    new_arr = merge(nums[i], nums[i+1])\n                    new.append(new_arr)\n                else:\n                    new.append(nums[i])\n            nums = new\n            \n        return nums[0]\n\n\n    return sortArray(l)\n"
		],
		[
			16.850326775577926,
			6.04334946208366,
			5,
			1.5,
			"def sortArray(l:list)->list:\n    def sortArray(nums:list):\n\t\n        if len(nums) <=1: return nums\n        less , greater , base = [] , [] , nums.pop()\n        for i in nums:\n            if i < base: less.append(i)\n            else: greater.append(i)\n        return sortArray(less) + [base] + sortArray(greater)\n\n\n    return sortArray(l)\n"
		]
	],
	"STR_SEARCH": [
		"m",
		[
			3.4051456101915067,
			1.0,
			1,
			0,
			"def STR_SEARCH(a:str, b:str)->int:\n\treturn a.find(b)\n"
		],
		[
			3.4980897302220204,
			1.0,
			3,
			1.0,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        return haystack.index(needle) if needle in haystack else -1\n\n\n    return strStr(a,b)\n"
		],
		[
			3.438783174376256,
			1.0,
			10,
			4.5,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        ind=0\n        if needle==\"\":\n            return 0\n        elif haystack==\"\":\n            return -1\n        elif needle in haystack:\n            for index in range(0, len(haystack)):\n                if haystack[index]==needle[0]:\n                    ind, ind1=0, index\n                    while True: \n                        if ind>=len(needle):\n                            return index\n                        elif haystack[ind1] != needle[ind]:\n                            break\n                        ind1 += 1\n                        ind += 1\n        else:\n             return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			7.441978050812533,
			4.57305147441731,
			14,
			7.826086956521739,
			"def strStr(a:str,b:str):\n    def strStr(text: str, pat: str) -> int:\n        if text==pat:\n            return 0\n        if pat==\"\":\n            return 0\n        def patlps(pat,lps,m):\n            left=0\n            i=1\n            while i<m:\n                if pat[left]==pat[i]:\n                    left+=1\n                    lps[i]=left\n                    i+=1\n                else:\n                    if left!=0:\n                        left=lps[left-1]\n                    else:\n                        lps[i]=0\n                        i+=1\n        n=len(text)\n        m=len(pat)\n        lps=[0]*m\n        patlps(pat,lps,m)\n        j=0\n        i=0\n        while i<n:\n            if pat[j]==text[i]:\n                i+=1\n                j+=1\n            if j==m:\n                return i-j\n            elif i<n and pat[j]!=text[i]:\n                if j!=0:\n                    j=lps[j-1]\n                else:\n                    i+=1\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			8.284405267047696,
			4.959351680517425,
			12,
			7.134615384615385,
			"def strStr(a:str,b:str):\n    def strStr(text: str, pat: str) -> int:\n        if pat==\"\":\n            return 0\n        \n        con=pat+\"$\"+text\n        left=0\n        right=0\n        k=0\n        n=len(con)\n        z=[0]*n\n        for i in range(1,n):\n            if right<i:\n                left,right=i,i\n                while right<n and con[right-left]==con[right]:\n                    right+=1\n                z[i]=right-left\n                right-=1\n            else:\n                k=i-left\n                if z[k]<right-i+1:\n                    z[i]=z[k]\n                else:\n                    left=i\n                    while right<n and con[right-left]==con[right]:\n                        right+=1\n                    z[i]=right-left\n                    right-=1 \n        for i in range(n):\n            if z[i]==len(pat):\n                return i-len(pat)-1\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			8.140914727091063,
			1.0,
			14,
			9.393939393939394,
			"def strStr(a:str,b:str):\n    def strStr(text: str, pat: str) -> int:\n        if text==pat or pat==\"\":\n            return 0\n        d=26 # no of char in input alphabet\n        M=len(pat)\n        N=len(text)\n        if M>N:\n            return -1\n        q=5381 # any prime no to avoid hash collision ,greater will be effective\n        i,j=0,0\n        p=0 # hash value for pattern\n        t=0 # hash value for text\n        h=1\n        # The value of h would be \"pow(d, M-1)%q\" \n        for i in range(M-1): \n            h = (h*d)%q \n        for i in range(M):\n            p=(d*p+ord(pat[i]))%q\n            t=(d*t+ord(text[i]))%q\n        for i in range(N-M+1):\n            if p==t:\n                for j in range(M):\n                    if text[i+j]!=pat[j]:\n                        break\n                j+=1\n                if j==M:\n                    return i\n            if i < N-M: \n                t = (d*(t-ord(text[i])*h) + ord(text[i+M]))%q \n                if t < 0: \n                    t = t+q \n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			3.4569891234584342,
			1.0,
			7,
			3.611111111111111,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return(0)\n        if haystack == needle:\n            return(0)\n        if needle in haystack:\n            for i in range(len(haystack)+1):\n                if needle in haystack[0:i]:\n                    return(i - len(needle))\n                # print(haystack[0:i])\n        else:\n            return(-1)\n\n\n    return strStr(a,b)\n"
		],
		[
			3.4783899757217425,
			1.0,
			2,
			0,
			"def strStr(a:str,b:str):\n    def strStr(haystack, needle):\n        return haystack.find(needle)\n\n\n    return strStr(a,b)\n"
		],
		[
			7.544381987668468,
			1.0,
			4,
			2.5714285714285716,
			"def strStr(a:str,b:str):\n    def strStr(haystack, needle):\n        n, h = len(needle), len(haystack)\n        hash_n = hash(needle)\n        for i in range(h-n+1):\n            if hash(haystack[i:i+n]) == hash_n:\n                return i\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			8.08320550861006,
			1.0,
			8,
			6.896551724137931,
			"def strStr(a:str,b:str):\n    def strStr(haystack, needle):\n        def strStr(c):\n            return ord(c)-ord('A')\n\n        n, h, d, m = len(needle), len(haystack), ord('z')-ord('A')+1, float(\"inf\")\n        if n > h: return -1\n        nd, hash_n, hash_h = d**(n-1), 0, 0   \n        for i in range(n):\n            hash_n = (d*hash_n+f(needle[i]))%m\n            hash_h = (d*hash_h+f(haystack[i]))%m            \n        if hash_n == hash_h: return 0        \n        for i in range(1, h-n+1):\n            hash_h = (d*(hash_h-f(haystack[i-1])*nd)+f(haystack[i+n-1]))%m    # e.g. 10*(1234-1*10**3)+5=2345\n            if hash_n == hash_h: return i\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			7.538252776963406,
			4.901274363829819,
			10,
			8.0,
			"def strStr(a:str,b:str):\n    def strStr(haystack, needle):\n        n, h = len(needle), len(haystack)\n        i, j, nxt = 1, 0, [-1]+[0]*n\n        while i < n:                                # calculate next array\n            if j == -1 or needle[i] == needle[j]:   \n                i += 1\n                j += 1\n                nxt[i] = j\n            else:\n                j = nxt[j]\n        i = j = 0\n        while i < h and j < n:\n            if j == -1 or haystack[i] == needle[j]:\n                i += 1\n                j += 1\n            else:\n                j = nxt[j]\n        return i-j if j == n else -1\n\n\n    return strStr(a,b)\n"
		],
		[
			3.487109731677594,
			1.0,
			4,
			1.5,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        if len(needle) == 0:\n            return 0\n        if needle in haystack:\n            return haystack.index(needle)\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			7.779478877644224,
			1.0,
			10,
			5.833333333333333,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        if not needle or haystack == needle:\n            return 0\n        len_needle, len_haystack = len(needle), len(haystack)\n        if len_needle > len_haystack:\n            return -1\n        for i in range(len_haystack):\n            index = 0\n            for j in range(i, i + len_needle):\n                if j >= len_haystack:\n                    return -1\n                if haystack[j] == needle[index]:\n                    index += 1\n                    continue\n                else:\n                    break\n            if index == len_needle:\n                return i\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			7.551981874412184,
			1.0,
			9,
			6.6,
			"def strStr(a:str,b:str):\n    def strStr(haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        l1 = len(needle)\n        l2 = len(haystack)\n        if l1 > l2:\n            return -1\n        if l1 == 0 or l2 == 0:\n            return 0\n        if l1 == l2:\n            if needle == haystack:\n                return 0\n        j = 0\n        for i in range(l2-1):\n            if haystack[i:l1+j] == needle:\n                return i\n            j+=1\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			3.4675118334911144,
			1.0,
			7,
			4.166666666666667,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        if needle == '' :\n            return 0\n        \n        if needle in haystack :\n            l = len(needle)\n            h = len(haystack)\n            if l ==  h :\n                return 0\n            for x in range(0, h - l+1) :\n                if haystack[x : l + x] == needle :\n                    return x \n        else :\n            return -1 \n\n\n    return strStr(a,b)\n"
		],
		[
			3.3979779269288444,
			1.0,
			4,
			1.5,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        if needle==\"\": return 0\n        x = len(haystack.split(needle)[0])\n        return x if len(haystack)!=x else -1\n\n\n    return strStr(a,b)\n"
		],
		[
			3.481289486452522,
			1.0,
			2,
			0,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        return (haystack.find(needle)) # .find helps in finding the index of the first letter in the substring\n\n\n    return strStr(a,b)\n"
		],
		[
			3.4568765709084537,
			1.0,
			4,
			1.0,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n            if not needle:\n                return 0\n            else:\n                try:\n                    return haystack.index(needle)\n                except:\n                    return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			7.6019878060684345,
			1.0,
			8,
			3.5,
			"def strStr(a:str,b:str):\n    def strStr(haystack, needle):\n        if haystack == needle: return 0\n        if len(haystack) < len(needle): return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            foundIt = True\n            for j, patternChar in enumerate(needle):\n                if haystack[i + j] != patternChar:\n                    foundIt = False\n                    break\n            if foundIt: return i\n        return -1\n                \n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"  \n\n\n    return strStr(a,b)\n"
		],
		[
			7.308974316735311,
			1.0,
			7,
			3.8636363636363638,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n\t\n        x = len(haystack)\n        l = len(needle)\n        if haystack==needle:\n            return 0\n        if x==0 and l==0:\n            return 0\n        for i in range(0,x-l+1):\n            if haystack[i:i+l]==needle:\n                return i\n        return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			3.4065699505536498,
			1.0,
			4,
			1.875,
			"def strStr(a:str,b:str):\n    def strStr(haystack: str, needle: str) -> int:\n        if needle == \"\":\n            return 0\n        elif needle in haystack:\n            return haystack.index(needle)\n        else:\n            return -1\n\n\n    return strStr(a,b)\n"
		],
		[
			17.3979007213362,
			4.573038426253557,
			14,
			7.777777777777778,
			"def strStr(a:str,b:str):\n    def kmp_algo(needle):\n        len_needle = len(needle)\n        dp = [0] * len(needle)\n        \n        i = 1\n        j = 0\n        \n        while i < len_needle:\n            while j > 0 and needle[j] != needle[i]:\n                j = dp[j-1]\n            if needle[i] == needle[j]:\n                j += 1\n                dp[i] = j\n\n            i += 1\n        return dp\n\n    def strStr(haystack: str, needle: str) -> int:\n        if haystack == needle:\n            return 0\n        \n        if not needle:\n            return 0\n        \n        len_needle = len(needle)\n        len_haystack = len(haystack)\n\n        dp = kmp_algo(needle)\n        \n        i = 0\n        j = 0\n        \n        while i < len_haystack:\n            while j > 0 and haystack[i] != needle[j]:\n                j = dp[j-1]\n\n            if haystack[i] == needle[j]:\n                j += 1            \n            i += 1\n\n            if j == len_needle:\n                return i - j\n\n        return -1\n\n\n    return strStr(a,b)\n"
		]
	],
	"ROTATE_ARRAY": [
		"n",
		[
			5.278591262319585,
			4.9012740632089224,
			2,
			1.2,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        nums[:] = nums[len(nums)-k:] + nums[0:len(nums)-k]\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			4.929817327967682,
			1.0,
			4,
			1.3333333333333333,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n            \"\"\"\n            Do not return anything, modify nums in-place instead.\n            \"\"\"\n            k = k%len(nums)\n            if k==0:\n                return\n            for i in range(k):\n                nums.insert(0,nums.pop())\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.004999161245897,
			4.573058552093475,
			4,
			2.4,
			"def rotate(l:List[int],k:int):\n    def rotate(nums:List[int], k:int)->None:\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums1 = nums[:len(nums)-k]\n        nums2 = nums[ len(nums)-k: ]\n        \n        k=k%len(nums)\n        \n        for i in range(len(nums2)):\n            nums[i] =  nums2[i]\n        for i in range(len(nums1)):\n            nums[ k+i ] = nums1[i] \n        \n        return nums\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.154299593904849,
			1.0,
			5,
			4.666666666666667,
			"def rotate(l:List[int],k:int):\n    def reverse(A,i,j):\n        while i<j:\n            A[i],A[j] = A[j],A[i]\n            i += 1\n            j -= 1\n\n    def rotate(A:List[int], k:int)->None:\n        L  = len(A)\n        k %= L\n        if k:\n            reverse( A , 0 , L-1 )\n            reverse( A , 0 , k-1 )\n            reverse( A , k , L-1 )\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.127594339538976,
			4.9012667366962015,
			2,
			2.0,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k %= len(nums)\n        nums[k:], nums[:k] = nums[:-k], nums[-k:]\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.258794371648952,
			4.931054329720935,
			2,
			0.5,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        k=k%n\n        nums.reverse()\n        nums[0:k]=reversed(nums[0:k])\n        nums[k:]=reversed(nums[k:])\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.111670480867123,
			4.931074454984183,
			2,
			0.5,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n=len(nums)\n        k=k%n\n        nums.reverse()\n        a=reversed(nums[k:])\n        b=reversed(nums[:k])\n        nums.clear()\n        nums.extend(b)\n        nums.extend(a)\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.988571547449018,
			4.931798653168821,
			8,
			9.166666666666666,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        n = len(nums)\n        if n == 0 : return\n        if k>n : k = k%n\n        \n        # extend the list\n        for i in range(n-k):\n            nums.append(0)\n        \n        #fill the extension\n        for i in range(n-k):\n            nums[i+n] = nums[i]\n        \n        #rotate\n        for i in range(n):\n            nums[i] = nums[i+n-k]\n        \n        #cut down the list\n        i = n-k\n        while(i>0):\n            nums.pop()\n            i -= 1\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			6.902989874779392,
			1.0,
			3,
			0,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(0, k):\n            nums.insert(0, nums.pop())\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			6.906167678574247,
			1.0,
			3,
			0,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for _ in range(k):\n            nums.insert(0, nums.pop())\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.240817953455465,
			4.90127413865235,
			2,
			1.2,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        nums[:] = nums[(len(nums) - k):] + nums[:(len(nums) - k)]\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.239022129962622,
			4.901256825064012,
			2,
			1.7142857142857142,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        nums[:]=nums[-k%len(nums):]+nums[:-k%len(nums)]\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			4.760391043804323,
			1.0,
			6,
			2.25,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if k<len(nums):\n            for i in range(0,k):\n                e=nums.pop()\n                nums.insert(0,e)\n        elif k>len(nums):\n            k=k%len(nums)\n            for i in range(0,k):\n                e=nums.pop()\n                nums.insert(0,e)\n        else:\n            pass\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.019115851835433,
			1.0,
			3,
			1.3333333333333333,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:       \n        while k > 0:\n            nums.insert(0, nums.pop())\n            k -= 1\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			6.185957093222524,
			4.625063088473969,
			3,
			0,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        d = deque(nums)\n        d.rotate(k)\n        nums.clear()\n        while d:\n            nums.append(d.popleft())\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.343844368612887,
			4.901274189394899,
			5,
			3.9375,
			"def rotate(l:List[int],k:int):\n    def rotate(nums:List[int], k: int):\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n\n        \n        if len(nums) in [0, 1] or k in [0, len(nums)]:\n            return\n        k_mod = k % len(nums)\n        if len(nums[:-k_mod]) >= len(nums[:k_mod]):\n            nums[:] = nums[-k_mod:] + nums[:k_mod] + nums[k_mod:-k_mod]            \n        else:\n            nums[:] = nums[-k_mod:] + nums[:-k_mod]\n        return\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.16238567160107,
			1.0,
			5,
			3.3333333333333335,
			"def rotate(l:List[int],k:int):\n    def reverse_arr_in_place(arr, s, e):\n        while e > s:\n            arr[s], arr[e] = arr[e], arr[s]\n            s += 1\n            e -= 1\n\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"        \n        if k > len(nums):\n            k = k % len(nums) \n        reverse_arr_in_place(nums, len(nums) - k, len(nums) - 1)        \n        reverse_arr_in_place(nums, 0, len(nums) - k - 1)\n        reverse_arr_in_place(nums, 0, len(nums) - 1)\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.363181467754227,
			1.0,
			5,
			6.0,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n       n = len(nums)\n       k %= n\n       count = 0\n       curr = 0\n       while count < n:\n           prev = nums[curr]\n           next_ind = curr + k   \n           next_ind %= n            \n           while True:                \n               nums[next_ind], prev = prev, nums[next_ind]\n               count += 1\n               if next_ind == curr:\n                   break\n               next_ind += k                \n               next_ind %= n                \n           curr += 1\t\t\t\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.271974754753005,
			4.901274189394899,
			2,
			2.25,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        k=k%len(nums)\n        nums[:]=nums[-k:]+nums[:-k]\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			5.3348961560434685,
			4.901186196355147,
			2,
			1.2,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        nums[:] = nums[len(nums) - k :] + nums[:len(nums) - k]\n\n\n    rotate(l,k)\n    return l\n"
		],
		[
			7.115389719170643,
			1.0,
			4,
			2.5,
			"def rotate(l:List[int],k:int):\n    def rotate(nums: List[int], k: int) -> None:\n        n = len(nums)\n\t\t\n\t\t# Remove redundant passes\n        shift = k % n\n        gcd = math.gcd(shift, n)\n        \n        for j in range(gcd):\n            i, temp = shift + j, nums[j]\n            while i != j:\n                nums[i], temp, i = temp, nums[i], (i + shift) % n\n\n            nums[i] = temp\n\n\n    rotate(l,k)\n    return l\n"
		]
	],
	"FIB": [
		"1",
		[
			1.0,
			1.0,
			2,
			1.5,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        return int((c.golden ** N + 1) / 5 ** 0.5)\n\n\n    return fib(n)\n"
		],
		[
			7.13046005589969,
			3.2679531119104475,
			3,
			0.5,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        dp_0,dp_1 = 0,1\n        for i in range(N):\n            dp_0,dp_1 = dp_1,dp_1+dp_0\n        return dp_0\n\n\n    return fib(n)\n"
		],
		[
			2208676465.5516777,
			6.867555797237333,
			3,
			2.4,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:  \n        if N < 2:\n            return N\n\n        return fib(N - 1) + fib(N - 2)\n\n\n    return fib(n)\n"
		],
		[
			8.736813636952325,
			6.934924963991987,
			4,
			2.0,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        def dfs(n):\n            if n not in memo: memo[n] = dfs(n-1)+dfs(n-2)            \n            return memo[n]\n\t\t\t\n        memo = {0:0, 1:1}\n        return dfs(N)\n\n\n    return fib(n)\n"
		],
		[
			7.853189156893348,
			5.341155395673958,
			3,
			2.1,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:        \n        dp = [0, 1]+[0]*(N-1)\n        for i in range(2, N+1):\n            dp[i] = dp[i-1]+dp[i-2]\n        return dp[N]\n\n\n    return fib(n)\n"
		],
		[
			7.105387475799424,
			3.26798123012058,
			4,
			1.8,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        if N < 2: return N\n        a, b = 0, 1\n        for _ in range(N-1):\n            c = a+b\n            a, b = b, c\n        return c\n\n\n    return fib(n)\n"
		],
		[
			8.384713543198627,
			5.342599091061439,
			4,
			3.2,
			"def fib(n:int)->int:\n    def fib(n: int) -> int:\n\t\t# initializing table with hard-coded base values\n        table = [0,1,1]\n\n        if n > 2:  # series until 2 is already in table, we needn't calculate again\n\t\t\t# we iterate until the nth term is reached (added an offset of 2 since first two are already in table)\n            for i in range(n-2): \n                table.append(table[-1] + table[-2])\n        \n\t\t# return required nth term,\n\t\t# table[-1] would have worked except for n < 2, since our table is initialized until 2nd term.\n        return table[n] \n\n\n    return fib(n)\n"
		],
		[
			7.074994123900606,
			3.269902031454478,
			5,
			2.4,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        curr = 1\n        prev = 0\n\n        if N == 0:\n            return prev\n        elif N==1:\n            return curr\n        else:\n            for i in range(N-1):\n                prev, curr = curr, curr+prev\n\n        return curr\n\n\n    return fib(n)\n"
		],
		[
			7.111560260459045,
			3.268748177174124,
			4,
			1.0,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        if N < 2:\n            return N\n        \n        p1 = 1\n        p2 = 1\n        \n        for i in range(2, N):\n            temp = p1\n            p1 += p2\n            p2 = temp\n            \n        return p1\n\n\n    return fib(n)\n"
		],
		[
			8.887739040308515,
			6.892101499066655,
			6,
			3.3333333333333335,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:      \n        def dp(n):\n            if memo[n] != None:\n                return memo[n]\n            memo[n] = 0 if n==0 else 1 if n == 1 else dp(n-1) + dp(n-2)\n            return memo[n]  \n        \n        memo = [None] * (N+1)\n        return dp(N)\n\n\n    return fib(n)\n"
		],
		[
			7.50690856962956,
			3.365548981260178,
			5,
			3.0,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        a,b = 0 ,1\n        n = 2\n#special case is when N is 0 or 1:\n        if N ==0:\n            return 0\n        if N ==1:\n            return 1\n#run while loop to do the math\n        while n<=N:\n            rst = a + b\n            a,b = b , a+b\n            n +=1\n        return(rst)\n\n\n    return fib(n)\n"
		],
		[
			7.6157052535363565,
			5.353425873093792,
			5,
			2.75,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        res = [0,1]\n        if N == 0:\n            return res[0]\n        elif N==1:\n            return res[1]\n        for i in range(2,N+1):\n            res.append(res[-1] + res[-2])            \n        return res[-1]\n\n\n    return fib(n)\n"
		],
		[
			7.652569741614589,
			5.355732806821533,
			5,
			3.6666666666666665,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        if N == 0:\n            return 0\n        elif N == 1:\n            return 1\n        else:\n            fibs = [0, 1]\n            for number in range(N-1):\n                fibs.append(fibs[-1] + fibs[-2])\n            return fibs[-1]\n\n\n    return fib(n)\n"
		],
		[
			8.939316268071176,
			6.757500994263451,
			5,
			4.0,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        if N == 0:\n            return 0\n        if N == 1:\n            return 1\n\n        if N > 1:\n            return fib(N - 1) + fib(N - 2)\n\n\n    return fib(n)\n"
		],
		[
			8.07754816745583,
			5.348487812486922,
			5,
			3.7142857142857144,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        f = [0, 1]\n        if N == 0:\n            return f[0]\n        elif N == 1:\n            return f[1]\n        else:\n            for i in range(2, N + 1):\n                f.append(f[i-2] + f[i-1])\n\n        return f[-1]\n\n\n    return fib(n)\n"
		],
		[
			15.812871979332234,
			5.445989110398575,
			5,
			2.4375,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        f = (0, 1)\n        if N == 0:\n            return f[0]\n        elif N == 1:\n            return f[1]\n        else:\n            for _ in range(2, N + 1):\n                f += (f[-2] + f[-1],)\n\n        return f[-1]\n\n\n    return fib(n)\n"
		],
		[
			7.089844646043698,
			3.923604834033213,
			12,
			6.222222222222222,
			"def fib(n:int)->int:\n    def fib(n: int) -> int:\n        \n        def get_mat_mult(mat, other_mat):\n            res = [[0 for _ in range(len(mat[0]))] for _ in range(len(mat))]\n            for i in range(len(mat)):\n                for j in range(len(mat[i])):\n                    for k in range(len(other_mat[i])):\n                        res[i][j] += mat[i][k] * other_mat[k][j]\n            return res\n        \n        if n == 0 or n == 1:\n            return n\n        \n        final_mat = [[1,0],[0,1]]\n        start_mat = [[1,1], [1,0]]\n        n -= 1\n        while(n):\n            if (n & 1):\n                final_mat = get_mat_mult(start_mat, final_mat)\n            start_mat = get_mat_mult(start_mat, start_mat) \n            n >>= 1\n        return final_mat[0][0]\n\n\n    return fib(n)\n"
		],
		[
			7.809715661685781,
			5.359375522292978,
			3,
			1.3333333333333333,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        memo = [0, 1]\n        for i in range(2, N+1):\n            memo.append(memo[i-1]+memo[i-2])\n        return memo[N]\n\n\n    return fib(n)\n"
		],
		[
			7.284757849486288,
			3.2679536694902387,
			5,
			2.7,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        \n        res = [0,1]\n        c = 0\n        \n        if N == 0:\n            return res[0]\n        elif N==1:\n            return res[1]\n        \n        for i in range(2,N+1):\n            \n            c = res[0] + res[1]\n            \n            res[0] = res[1]\n            res[1] = c\n            \n        return res[-1]\n\n\n    return fib(n)\n"
		],
		[
			7.872665521991545,
			5.341223148428408,
			4,
			3.8636363636363638,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        ## RC ##\n        if(N == 0): return 0\n        dp = [0,1] + [0] * (N-1)\n        for i in range(2,N+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        return dp[-1]\n\n\n    return fib(n)\n"
		],
		[
			7.827835951525569,
			5.34679542894535,
			4,
			3.142857142857143,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        s = [0, 1]\n        for i in range(2, N + 1):\n            s.append(s[i - 1] + s[i - 2])\n        return s[-1] if N > 0 else 0\n\n\n    return fib(n)\n"
		],
		[
			7.999451377254485,
			5.91000540688794,
			3,
			1.3333333333333333,
			"def fib(n:int)->int:\n    def fib(N: int) -> int:\n        dic = {}\n        dic[0], dic[1] = 0, 1\n        for i in range(2, N+1):\n            dic[i] = dic[i-1] + dic[i-2]\n        return dic[N]\n\n\n    return fib(n)\n"
		]
	],
	"PALIN": [
		"1",
		[
			1.0,
			1.0,
			2,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        return str(x) == str(x)[::-1]\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			7,
			4.714285714285714,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x) -> bool:\n        if x<0:\n            return False \n        else:\n            x = str(x)\n            x = [item for item in x]\n            if len(x)%2 ==0:\n                part1 = x[0:int(len(x)/2)]\n                part2 = x[int(len(x)/2):]\n                if part1 == part2[::-1]:\n                    return True \n                else:\n                    return False \n            else:\n                part1 = x[0:int(len(x)/2)]\n                part2 = x[int(len(x)/2)+1:]\n                if part1 == part2[::-1]:\n                    return True \n                else:\n                    return False \n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			2.8,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n\t\t# always false if negative\n        if x < 0:\n            return False\n        arr = []\n        while x != 0:\n            x, r = divmod(x, 10) # Divide by 10, see the remainder\n            arr.append(r)\n        return arr==arr[::-1]\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			3,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        return True if str(x) == str(x)[::-1] else False\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			2,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        s=str(x)\n        d=s[::-1]\n        return s==d\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			10,
			11.047619047619047,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if(x<0):\n            return False\n        else:\n            x1=x\n            count=0\n            rev=0\n            while(x1>0):\n                count+=1\n                x1//=10\n            if(count==1):\n                return True\n            length=count\n            count//=2\n            if(length%2==0):\n                s=x//(10**count)\n                s1=x%(10**count)\n                while(s>0):\n                    rev=rev*10+(s%10)\n                    s=s//10\n                if(s1==rev):\n                    return True\n            else:\n                s=x//(10**(count+1))\n                s1=x%(10**count)\n                while(s>0):\n                    rev=rev*10+(s%10)\n                    s=s//10\n                print(rev)\n                \n                if(s1==rev):\n                    return True\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			2,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x):\n        return str(x) == str(x)[::-1]\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			7,
			10.714285714285714,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        \n        ## RC ##\n        ## APPROACH : covert the second half of the integer and compare with first half ##\n        \n        # Special cases:\n        # when x < 0, x is not a palindrome.\n        # Also if the last digit of the number is 0, in order to be a palindrome,\n        # the first digit of the number also needs to be 0.\n        # Only 0 satisfy this property.\n        if(x < 0 or (x % 10 == 0 and x != 0)) : return False\n\n        revertedNumber = 0\n        while(x > revertedNumber):                      # indicates half completed.\n            revertedNumber = revertedNumber * 10 + x % 10\n            x = x // 10\n\n        # When the length is an odd number, we can get rid of the middle digit by revertedNumber/10\n        # For example when the input is 12321, at the end of the while loop we get x = 12, revertedNumber = 123,\n        # since the middle digit doesn't matter in palidrome(it will always equal to itself), we can simply get rid of it.\n        return x == revertedNumber or x == revertedNumber//10;\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			3.75,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if not x:\n            return True\n        elif x < 0:\n            return False\n        \n        old_x = x\n        new_x = 0\n        \n        while old_x:\n            (t, r) = divmod(old_x, 10)\n            new_x = new_x * 10 + r\n            old_x = t\n\n        return new_x == x\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			3.75,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x<0:\n            return False\n        n=str(x)\n        i,j=0,len(n)-1\n        while j>=i:\n            if n[i]==n[j]:\n                i+=1\n                j-=1\n            else:\n                return False\n        return True\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			2.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        half = len(str(x))//2\n        string = str(x)\n        for i in range(0,half):\n            if string[i] == string[-i-1]:\n                continue\n            else:\n                return False\n                break\n        return True\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			3,
			1.5,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x<0:\n            return False\n        x_s = str(x)\n        return x_s == x_s[::-1] \n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			3,
			2.3333333333333335,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        return x >= 0 and x == int(f\"{x}\"[::-1])\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			3,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if str(x)==str(x)[::-1]:\n            return True\n        return False\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			3,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        return True if str(x) == str(x)[::-1] else False\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			1.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x<0:\n            return False\n        d=deque(str(x))\n        while d:\n            l=d.popleft()\n            if d: #For odd cases like 121,422 \n                r=d.pop()\n                if int(l)!=int(r):\n                    return False\n        return True\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			3,
			1.5,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x < 0:\n            return False\n\t\t\n        return str(x) == str(x)[::-1]\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			7.0,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x<0:\n            return False\n\n        inputNum = x\n        newNum = 0\n        while x>0:\n            newNum = newNum * 10 + x%10\n            x = x//10\n        return newNum == inputNum\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			9.642857142857142,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x < 0 or (x > 0 and x%10 == 0):   # if x is negative, return False. if x is positive and last digit is 0, that also cannot form a palindrome, return False.\n            return False\n\t\t\n        result = 0\n        while x > result:\n            result = result * 10 + x % 10\n            x = x // 10\n\t\t\t\n        return True if (x == result or x == result // 10) else False\n\n\n    return isPalindrome(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			4.7727272727272725,
			"def isPalindrome(n:int)->bool:\n    def isPalindrome(x: int) -> bool:\n        if x < 0 or (x % 10 == 0 and x != 0): \n            return False\n        else:\n            rev = str(x)[::-1]\n            if rev == str(x):\n                return True\n            else: \n                return False\n\n\n    return isPalindrome(n)\n"
		]
	],
	"POW": [
		"1",
		[
			1.0,
			3.2681925258809277,
			5,
			8.0,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        if n<0:\n            x = 1/x\n            n = abs(n)\n        res = 1\n        while n > 0:\n            if n%2 == 1:\n                res *= x\n            x *= x\n            n //= 2\n        return res\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			11,
			10.928571428571429,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if abs(x) == 1:\n            return 1 if n % 2 == 0 else x\n        \n        memo = {1: x}\n        isInverse = n < 0\n        m = abs(n)\n        result = 1\n        \n        while m > 0:\n            # reached lang limits\n            if result == 0.0:\n                return result\n            if result == inf:\n                break\n                \n            if m in memo:\n                result *= memo[m]\n                break\n            \n            subRes = x\n            progress = 1\n\t\t\t\n\t\t\t# equivalent to floor(log2(m))\n            while progress * 2 <= m:\n                subRes *= subRes\n                progress *= 2\n            \n            memo[progress] = subRes\n            result *= subRes\n            m -= progress\n            \n        return 1 / result if isInverse else result\n\n\n    return myPow(x,n)\n"
		],
		[
			23.027861783694444,
			4.1770253449212476,
			2,
			0.5,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        return x**n\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			9,
			12.681818181818182,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        if n == 0 or x == 1.0:\n            return 1.0\n        if x == 0:\n            if n < 0:\n                return float('inf')\n            else:\n                return 0.0\n        \n        if n < 0:\n            x, n = 1/x, -n\n        \n        res, num, power = 1.0, x, n\n        while power != 1:\n            if power%2 == 0:\n                num = num*num\n                power /= 2\n            else:\n                res *= num\n                power -= 1\n        \n        return res*num\n\n\n    return myPow(x,n)\n"
		],
		[
			8.16883621108744,
			1.0,
			2,
			0.5,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        return x**n\n\n\n    return myPow(x,n)\n"
		],
		[
			6.552410405882351,
			1.0,
			5,
			7.5,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        # x**n == (1/x)**(-n) \n        # by using the property above we can transform the negetive power problem to positive power problem\n        # so that we solve the positive power situation, we also solved the negtive power situation.\n        if n < 0:\n            x = 1/x\n            n = -n\n        # We solve the positive power here:\n        power = 1\n        current_product = x\n        while n > 0:\n            # if n is odd numberm, we need to time x one more time\n            if n%2 : \n                power = power * current_product\n            current_product = current_product * current_product\n            n = n//2\n        return power\n\n\n    return myPow(x,n)\n"
		],
		[
			7.00851358458066,
			1.0,
			11,
			7.714285714285714,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        if n == 0 or abs(x) == 1: return 1 if x == 1 else 1 - 2*(n % 2)\n        p, T = 1, 1E5\n        for i in range(abs(n)):\n            p *= x\n            if (abs(p) < 1/T and n > 0) or (abs(p) > T and n < 0): return 0\n        return p if n > 0 else 1/p\n\n\n    return myPow(x,n)\n"
		],
		[
			8.450824111753668,
			1.0,
			2,
			0,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        import math\n        return pow(x,n)\n\n\n    return myPow(x,n)\n"
		],
		[
			7.098615281451639,
			1.0,
			6,
			8.444444444444445,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        \n        myres = 1\n        \n        if n == 0: return 1\n        elif n < 0: \n            x = 1/x\n            n = -n\n            \n        curProd = x\n        k = n\n        \n        while (k > 0):\n            if k%2 == 1: myres *= curProd\n            curProd *= curProd\n            k //= 2\n        return myres\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			5,
			6.0,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        ret = 1\n        tmp = abs(n)\n        while(tmp):\n            if tmp % 2 == 1:\n                ret *= x\n                tmp -= 1\n            else:\n                x *= x\n                tmp /= 2\n                \n        return ret if n>0 else 1/ret\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			5,
			6.5,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        result = 1\n\n        \n        if n<0:\n            x = 1/x\n            n=-n\n        power = n\n\n        \n        while power:\n            if power&1:\n                result = result*x\n            x = x*x\n            power = power >>1\n            \n        return result\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			4,
			6.333333333333333,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x, n, r=1) -> float:\n        x, n = n < 0 and 1 / x or x, abs(n)\n        return myPow(x * x, n // 2, r * (not n % 2 or x)) if n else r\n\n\n    return myPow(x,n)\n"
		],
		[
			8.044806544568438,
			20.451795213629065,
			6,
			6.416666666666667,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n\n        def function(base = x, exponent = abs(n)):\n            if exponent == 0:\n                return 1\n            elif exponent % 2 == 0:\n                return function(base * base, exponent // 2)\n            else:\n                return base * function(base * base, (exponent - 1) // 2)\n\n        f = function()\n        \n        return float(f) if n >= 0 else 1/f\n\n\n    return myPow(x,n)\n"
		],
		[
			8.366442744121787,
			17.691162710166303,
			11,
			5.6,
			"def myPow(x: float, n: int) -> float:\n    def get_positive_power(x, power, stored_power):\n        if power == 1: return x\n        if power == 2: return x*x\n        \n        if stored_power.get(power): return stored_power[power]\n        \n        prev_power = 1\n        next_power = 2\n        prev_val = x\n        \n        while next_power < power:\n            prev_val = prev_val*prev_val\n            stored_power[next_power] = prev_val\n            prev_power = next_power\n            next_power *= 2\n        \n        stored_power[power] = prev_val * get_positive_power(x, power-prev_power, stored_power)\n        return stored_power[power]\n\n    def myPow(x: float, n: int) -> float:\n        if x == 0: return 0.0\n        if x == 1 or n == 0: return 1.0\n        \n        power = abs(n)\n        stored_power = {}\n        res = get_positive_power(x, power, stored_power)\n        return 1/res if n < 0 else res \n\n\n    return myPow(x,n)\n"
		],
		[
			106.5684725652555,
			21.033804900801684,
			9,
			8.8,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        ## RC ##\n        ## APPROACH : RECURSION ##    \n        def recurse(n):\n            ans = 1\n            if(n == 0):\n                return 1\n            if(n==1):\n                return x\n            if(n == 2):\n                return x * x\n            \n            if(n%2 == 0):\n                ans = recurse(n//2)\n                return ans * ans\n            if( n%2 == 1):\n                ans = recurse(n//2) * recurse((n//2) + 1)\n                return ans\n            \n        if( n < 0 ):\n            x = 1/x\n            n = -n\n        return recurse(n)\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			5,
			5.833333333333333,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n            res = 1 \n            temp = abs(n)\n            while temp > 0:\n                if temp & 1:\n                    res = res * x \n                x = x * x \n                temp = temp >> 1 \n            if n > 0:\n                return res\n            else:   \n                return 1 / res\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			7,
			7.636363636363637,
			"def myPow(x: float, n: int) -> float:\n    def calc(x,y):\n        if y == 0:\n            return 1\n        if y == 1:\n            return x\n        if y % 2:\n            return x * calc(x, y-1)\n        return calc(x*x, y//2)\n\n    def myPow(x: float, n: int) -> float:\n        if n < 0:\n            return calc((1/x), -1 * n)\n        else:\n            return calc(x, n)\n\n\n    return myPow(x,n)\n"
		],
		[
			1.0,
			1.0,
			2,
			0.5,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        return x**n\n\n\n    return myPow(x,n)\n"
		],
		[
			7.869056711728208,
			6.859154599383569,
			7,
			6.1923076923076925,
			"def myPow(x: float, n: int) -> float:\n    def myPow(x: float, n: int) -> float:\n        def helper(x, n):\n            if n == 0:\n                return 1\n            tmp = helper(x, n // 2)\n            if n % 2 == 0:\n                return tmp * tmp\n            if n % 2 == 1:\n                return x * tmp * tmp\n\n        if n >= 0:\n            return helper(x, n)\n\n        return 1 / helper(x, -n)\n\n\n    return myPow(x,n)\n"
		]
	],
	"UGLY_NUM": [
		"1",
		[
			1.0,
			1.0,
			7,
			3.6666666666666665,
			"def isUgly(n:int):\n    def isUgly(n: int) -> bool:\n        if n == 0:\n            return False\n        \n        while n%2 == 0:\n            n = n/2\n        \n        while n%3 == 0:\n            n = n/3\n        \n        while n%5 == 0:\n            n = n/5\n\n        if n == 1:\n            return True\n\t\t\t\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			2.0,
			"def isUgly(n:int):\n    def isUgly(n: int) -> bool:\n        if n < 1:\n            return False\n        if n == 1:\n            return True\n        multipliers = [30, 15, 10, 8, 6, 5, 4, 3, 2]\n        for mult in multipliers:\n            for _ in range(sys.maxsize):\n                if n.__mod__(mult) == 0:\n                    n = divmod(n, mult)[0]\n                    if n == 1:\n                        return True\n                else:\n                    break\n\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			3.6666666666666665,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        if num == 0: return False\n        while num % 5 == 0: num /= 5\n        while num % 3 == 0: num /= 3\n        while num % 2 == 0: num /= 2\n        return num == 1\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			7,
			4.888888888888889,
			"def isUgly(n:int):\n    def isUgly(num):\n        while num>0 :\n            if num%2==0: num=num//2\n            elif num%3==0: num=num//3\n            elif num%5==0: num=num//5\n            elif num==1: return True\n            else: return False\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			3.2142857142857144,
			"def isUgly(n:int):\n    def isUgly(num):\n            def isUgly(n, p):\n                while not n % p:\n                    n = n // p           \n                return n\n            \n            P = [num, 2, 3, 5]\n            return reduce(f, P) == 1 if num > 0 else False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			3.0,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        \n        if num == 0:\n            # Corner case handle for input 0\n            return False\n        \n        \n        given_prime = [2, 3, 5]\n        \n        for p in given_prime:\n        \n            while num % p == 0:\n                num //= p\n\n\n        if num == 1:\n            return True\n        else:\n            return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			4.0,
			"def isUgly(n:int):\n    def isUgly(num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 0:\n            return False\n\n        primes = [2, 3, 5]\n        for prime in primes:\n            while num % prime == 0:\n                num /= prime\n            if num == 1: \n                return True\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			2.2857142857142856,
			"def isUgly(n:int):\n    def isUgly(num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        #n = (2**30)*(3**20)*(5**13) = 4570198050078720000000000000L\n        return False if num < 1 or (4570198050078720000000000000)%num != 0 else True\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			4.0,
			"def isUgly(n:int):\n    def isUgly(num):\n        if num == 1:\n            return True\n        elif num == 0:\n            return False\n        \n        while num % 2 == 0:\n            num = num / 2\n        while num % 3 == 0:\n            num = num / 3\n        while num % 5 == 0:\n            num = num / 5\n            \n        if num == 1:\n            return True\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			8.4,
			"def isUgly(n:int):\n    def isUgly(num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num==1:\n            return True\n        if num<1:\n            return False\n        while num>1:\n            change=False\n            for i in [2,3,5]:\n                if not num%i:\n                    num/=i\n                    change=True\n            if not change:\n                return False\n        return num==1\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			4.888888888888889,
			"def isUgly(n:int):\n    def isUgly(num):\n\n        if num <= 0:\n            return False\n\n        while num % 5 == 0:\n            num /= 5\n        while num % 3 == 0:\n            num /= 3\n        while num % 2 == 0:\n            num /= 2\n\n        return num == 1\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			7,
			3.6666666666666665,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        if num==0:\n            return False\n        while num%2==0:\n            num=num/2\n        while num%3==0:\n            num=num/3\n        while num%5==0:\n            num=num/5\n        if num==1:\n            return True\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			3.6,
			"def isUgly(n:int):\n    def isUgly(num):\n        for p in 2, 3, 5:\n            while num % p == 0 < num:\n                num /= p\n        return num == 1\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			4.0,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        if num < 1: return False\n        for factor in [2,3,5]:\n            while num % factor == 0:\n                num //= factor\n        return num == 1\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			7,
			6.111111111111111,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        if num < 1:\n            return False\n        while num > 1:\n            if num % 2 == 0:\n                num //= 2\n            elif num % 3 == 0:\n                num //= 3\n            elif num % 5 == 0:\n                num //= 5\n            else:\n                return False\n        return True\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			4.464285714285714,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        if num < 1:\n            return False\n        while num % 2 == 0 or num % 3 == 0 or num % 5 == 0:\n            for i in [2,3,5]:\n                if num % i == 0:\n                    num /= i\n        \n        return num == 1\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			2,
			2.8,
			"def isUgly(n:int):\n    def isUgly(num: int) -> bool:\n        return num > 0 == 30**30 % num\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			9,
			5.571428571428571,
			"def isUgly(n:int):\n    def isUgly(num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num == 1:\n            return True\n        if(num<1):\n            return False\n        n2 = num/maxd(num,2)\n        if(n2 == 1):\n            return True\n        n3 = n2/maxd(num,3)\n        if(n3 == 1):\n            return True\n        n5 = n3/maxd(num,5)\n        if(n5 == 1):\n            return True\n        return False\n\n    def maxd(num,n):\n        count = 0\n        while(num%n == 0):\n            num = num/n\n            count += 1\n        return n**count\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			2.0,
			"def isUgly(n:int):\n    def isUgly(n: int) -> bool:\n        if n < 1:\n            return False\n        if n == 1:\n            return True\n        multipliers = [2, 3, 5]\n        for mult in multipliers:\n            for _ in range(1000):\n                if n.__mod__(mult) == 0:\n                    n = divmod(n, mult)[0]\n                    if n == 1:\n                        return True\n                else:\n                    break\n\n        return False\n\n\n    return isUgly(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			2.0,
			"def isUgly(n:int):\n    def isUgly(n: int) -> bool:\n        if n < 1:\n            return False\n        if n == 1:\n            return True\n        multipliers = [30, 15, 10, 8, 6, 5, 4, 3, 2]\n        for mult in multipliers:\n            for _ in range(1000):\n                if n.__mod__(mult) == 0:\n                    n = divmod(n, mult)[0]\n                    if n == 1:\n                        return True\n                else:\n                    break\n\n        return False\n\n\n    return isUgly(n)\n"
		]
	],
	"SIEVE": [
		"n",
		[
			7.248770082765363,
			4.573065887481153,
			6,
			4.0,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n <= 2:\n            return 0\n\n        table = [True]*n\n        table[0], table[1] = False,False\n\n        i = 2\n        while i*i < n:\n            if table[i]:\n                for j in range(i*i, n, i):\n                    table[j] = False\n            i+=1\n\n        return sum(table)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.083375051376592,
			4.573067642491495,
			6,
			2.857142857142857,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n            \n        if n<2:\n            return 0\n        \n        s = [1]*n\n        \n        s[0]=s[1]=0\n        \n        for i in range(2,int(n**0.5)+1):\n            if s[i]:\n                for j in range(i*i,n,i):\n                    s[j] = 0\n        \n        return sum(s)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.4913276702675775,
			4.5730477634203055,
			9,
			4.5,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n == 0 or n == 1:\n            return 0\n        prime = [True]*(n)\n        count = 0\n        for i in range(2, int(math.sqrt(n))+1):\n            if prime[i]:\n                j = i*i\n                while j < n:\n                    prime[j] = False\n                    j += i\n        for p in range(2, len(prime)):\n            if prime[p]:\n                count += 1\n        return count\n\n\n    return countPrimes(n)\n"
		],
		[
			7.282214884851794,
			4.573056700577499,
			6,
			3.4375,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n <= 2:\n            return 0\n        # the number x is represented by a[x]\n        a = [1] * n\n        # ignore 0 and 1\n        a[0] = a[1] = 0\n        nsqrt = math.ceil(math.sqrt(n))\n        for i in range(2, nsqrt + 1):\n            if not a[i]:\n                continue\n            j = int(math.pow(i, 2))\n            while j < n:\n                a[j] = 0\n                j += i\n        return sum(a)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.459020403986328,
			4.573059756422745,
			7,
			1.8,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n<3:return 0\n        primes = [True]*n\n        for i in range(3, n, 2): # skip even\n            if primes[i]:\n                for j in range(i**2, n, i):\n                    primes[j] = False\n        primes[0]=primes[1] = False\n        for i in range(4,n,2):\n            primes[i] = False\n        return sum(primes)      \n\n\n    return countPrimes(n)\n"
		],
		[
			7.472149251810262,
			4.585823646983587,
			8,
			4.375,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        \n        prime = [True for i in range(n)]\n        p = 2\n        while(p*p <=n-1):\n            if prime[p]==True:\n                for i in range( p*p , n,p):\n                    prime[i]=False\n                \n            p += 1\n        count = 0\n        for p in range(2, n): \n            if prime[p]: \n                count = count +1\n        return count\n\n\n    return countPrimes(n)\n"
		],
		[
			7.779122763646867,
			5.316963077202189,
			9,
			2.0,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n==0:\n            return 0\n        a = [x for x in range(n+1)]\n        a[1] = 0\n        count = 0\n        for i in range(2, int(sqrt(n))+1):\n            if a[i] == i:\n                for j in range(i+i, n+1, i):\n                    a[j] = 0\n        for i in range(2, n):\n            if a[i] == i:\n                count += 1\n        return count\n\n\n    return countPrimes(n)\n"
		],
		[
			7.057601715249219,
			4.901280432482347,
			6,
			3.923076923076923,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n < 3:\n            return 0\n        primes = [0, 0] + [1] * (n - 2)\n        for i in range(2, int((n - 1)**.5) + 1):\n            if not primes[i]:\n                continue\n            for j in range(i**2, n, i):\n                primes[j] = 0\n        return sum(primes)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.414563305075707,
			4.901311800873088,
			5,
			3.6,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        ## RC ##\n        ## APPROACH :  Sieve of Eratosthenes ##\n        \n        #   1. Checking till sqrt(n) is enough for prime numbers i.e i*i < n\n        #   2. mark all as prime.\n        #   3. as you move along (i to i*i<n) mark every multiple until n as False.\n        #   4. you donot need start from i for that we can start from i*i i.e j=i*i\n        \n\t\t## TIME COMPLEXITY : O(NLogN) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        isPrime = [False,False] + [True] * (n-2)\n        i = 2\n        while( i*i < n ):               # Loop's ending condition is i * i < n instead of i < sqrt(n) to avoid repeatedly calling an expensive function sqrt().\n            if(isPrime[i]):             # if not prime, it is some prime multiple.\n                j = i*i                 # ex: we can mark off multiples of 5 starting at 5 \u00d7 5 = 25, because 5 \u00d7 2 = 10 was already marked off by multiple of 2, similarly 5 \u00d7 3 = 15 was already marked off by multiple of 3. Therefore, if the current number is p, we can always mark off multiples of p starting at p2, then in increments of p: p2 + p, p2 + 2p, ...\n                while(j < n):\n                    isPrime[j] = False\n                    j += i\n            i += 1\n        return sum(isPrime)\n\n\n    return countPrimes(n)\n"
		],
		[
			8.044837427441095,
			4.573090411247182,
			5,
			2.5714285714285716,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        p = [1]*n\n        res = 0\n        for i in range(2,n):\n            if p[i]: \n                res+=1\n                j = 2\n                while j*i<n:\n                    p[i*j] = 0\n                    j+=1\n        return res\n\n\n    return countPrimes(n)\n"
		],
		[
			5.493906032129791,
			4.901279834053419,
			6,
			5.6,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n < 3: return 0     ###// No prime number less than 2\n        lst = [1] * n          ###// create a list for marking numbers less than n\n        lst[0] = lst[1] = 0    ###// 0 and 1 are not prime numbers\n        m = 2\n        while m * m < n:       ###// we only check a number (m) if its square is less than n\n            if lst[m] == 1:    ###// if m is already marked by 0, no need to check its multiples.\n\t\t\t\n\t\t\t    ###// If m is marked by 1, we mark all its multiples from m * m to n by 0. \n\t\t\t    ###// 1 + (n - m * m - 1) // m is equal to the number of multiples of m from m * m to n\n                lst[m * m: n: m] = [0] *(1 + (n - m * m - 1) // m)\n\t\t\t\t\n\t\t\t###// If it is the first iteration (e.g. m = 2), add 1 to m (e.g. m = m + 1; \n\t\t\t### // which means m will be 3 in the next iteration), \n            ###// otherwise: (m = m + 2); This way we avoid checking even numbers again.\t\n            m += 1 if m == 2 else 2\n        return sum(lst)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.0910878750682516,
			4.573074915291138,
			5,
			4.285714285714286,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        sieve = [1] * n\n        sieve[0:2] = [0,0]\n        start = 2\n        while start ** 2 < n:\n            if sieve[start] == 1:\n                for i in range(2 * start, n, start):\n                    sieve[i] = 0\n            start += 1\n        return sum(sieve)\n\n\n    return countPrimes(n)\n"
		],
		[
			8.267850090566057,
			4.573065288026922,
			6,
			2.0,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        prime = [True]*n #to make all list element values true\n        if n<2:\n            return 0\n        else:\n            prime[1] = prime[0] = False\n            for i in range(2,n):\n                if prime[i] is not False:\n                    prime[i] = True\n                for j in range(i*i,n,i):\n                    prime[j] = False\n        return sum(prime)#it will return sum of all True(1) values only\n\n\n    return countPrimes(n)\n"
		],
		[
			7.313148605919171,
			4.57306015696678,
			6,
			2.0,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        prime = [True] * n\n        if n < 2:\n            return 0\n        else:\n            prime[0] = prime[1] = False\n            for i in range(2, int(math.sqrt(n)) + 1):\n                if prime[i]:\n                    for j in range(i * i, n, i):\n                        prime[j] = False\n            return sum(prime)\n\n\n    return countPrimes(n)\n"
		],
		[
			5.343200976945402,
			4.829722337690353,
			7,
			7.619047619047619,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n<3: return 0\n        def count_primes(n):\n            \n            # Generate [0,1,0,1,0,1,...]. \n            primes=[0,1]*(n//2) # Note: with this generation, 1 is prime and 2 is not prime. But I return sum of 1s, so it does not matter much\n            if n%2!=0: primes+=[0] # add another one if n is odd\n\n            for i in range(3,int(n**0.5)+1,2): # I don't need to check for even numbers\n                if primes[i]==1: \n                    primes[i*i:n:i]=[0]*int((n-i*i-1)/i + 1)\n            return sum(primes)\n        s=count_primes(n)\n        return s\n\n\n    return countPrimes(n)\n"
		],
		[
			7.668784834792543,
			4.5730662971897305,
			6,
			4.666666666666667,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        if n <= 1:\n            return 0\n        else:\n            a = [True]*(n)\n            a[0] = a[1] = False\n            for i in range(2,n):\n                if a[i] == True:\n                    for  j in range(i,(n-1)//i + 1):\n                        a[i*j]  = False\n            return a.count(True)\n\n\n    return countPrimes(n)\n"
		],
		[
			5.417328443702286,
			4.901273414619576,
			5,
			5.6,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n:int)->int:\n\t\n        if n < 2:\n            return 0\n\t\t\t\n        k = [1] * n\n        k[0] = 0\n        k[1] = 0\n        for i in range(2, int(n**0.5)+1):\n            if  k[i] != 0:\n                k[i*i:n:i] = [0] * ((n-1-i*i)//i + 1)\n\n        return sum(k)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.496775028902376,
			4.592841777378502,
			8,
			3.2142857142857144,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        \n        return sieve_algorithm(n)\n\n    def sieve_algorithm(n: int)-> bool:\n        \n        if n <= 2:\n\t\t\t# Corner case handle\n            return 0\n        \n        \n        is_prime = [ True for _ in range(n) ]\n        \n        # Base case initialization\n        is_prime[0] = False\n        is_prime[1] = False\n        \n        upper_bound = int(n ** 0.5)\n        for i in range( 2, upper_bound+1 ):\n            \n            if not is_prime[i]:\n                # only run on prime number\n                continue\n            \n            \n            for j in range( i*i, n, i):\n                # mark all multiples of i as \"not prime\"\n                is_prime[j] = False\n                \n        return sum(is_prime)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.557125398695185,
			4.58305857021535,
			8,
			4.2,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n:int)->int:\n        prime = [1 for i in range(n+1)] \n        p = 2\n        while p * p <= n: \n            if prime[p]:\n                for i in range(p * p, n+1, p): \n                    prime[i] = 0\n\n            p += 1\n    \n        res = 0\n        for k in range(2, n): \n            if prime[k]: \n                res += 1\n\n        return res\n\n\n    return countPrimes(n)\n"
		],
		[
			7.57164376278129,
			4.75550822210026,
			8,
			4.5,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        prime = [True for i in range(n+1)]\n        p = 2\n        while p*p<=n:\n            if prime[p]:\n                for i in range(p*p,n+1,p):\n                    prime[i]=False\n            p+=1\n        res = []\n        for p in range(2,n):\n            if prime[p]:\n                res.append(p)\n        return len(res)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.368418889488324,
			4.573071721745312,
			6,
			3.0,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n:int)->int:\n        cnt, prime = n - 2, [True]*n\n        for i in range(2, int(n**0.5) + 1):\n            if prime[i]:\n                for j in range(i*i, n, i):\n                    if prime[j]: prime[j], cnt = False, cnt - 1\n        return max(0, cnt)\n\n\n    return countPrimes(n)\n"
		],
		[
			7.480042201212416,
			4.600553648086138,
			8,
			4.571428571428571,
			"def countPrimes(n:int={\"start\":0,\"end\":1000}):\n    def countPrimes(n: int) -> int:\n        \"\"\"\n\t\t1. Creating a list of consecutive integers\n\t\t2. Initializing p = 2 (First prime number)\n\t\t3. starting from p^2 and counting in increments of 2 while marking each number\n\t\t4. Finding an unmarked number greater than p and setting it as the new value of p\n\t\t\"\"\" \n        number_list = [False for i in range(n+1)]\n        p = 2\n        while p*p < n:\n            if not number_list[p]:\n                for i in range(p*p, n+1, p):\n                    number_list[i] = True\n            p += 1\n        \n        count= 0\n        for p in range(2,n):\n            if not number_list[p]:\n                count += 1\n        return count\n\n\n    return countPrimes(n)\n"
		]
	],
	"SQRT": [
		"1",
		[
			1.0,
			1.0,
			3,
			2.8,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        a = x            \n        while int(a) * int(a) > x:\n            a -= (a * a - x) / (2 * a)            \n        return int(a)\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			2,
			1.0,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        return int(x ** (1/2))\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			3,
			4.444444444444445,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x:int)->int:\n        r = x + 1\n        while r * r > x: \n            r = int( r - (r * r - x) / (2 * r))\n        return r\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			5,
			2.6666666666666665,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x:int)->int:        \n        eps = 1\n        x_i = 1\n        while(abs(newton(x_i, x) - x_i) > eps):\n            x_i = newton(x_i, x) \n        \n        if int(x_i) * int(x_i) > x:\n            return int(x_i) - 1\n        \n        return int(x_i)\n\n    def newton(x_i, a):\n        return 0.5 * (x_i + a / x_i)\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			7,
			8.666666666666666,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        ## RC ##\n        ## APPROACH : Binary Search ##\n        #   1. Any number greater than 1, will have sqrt(n) less than n/2\n        #   2. We can check i*i < n till n/2.\n        #   3. Can be optimized with binary search, listing all nums till n/2 and check i*i < n\n        if(x < 4): return 1 if (x!=0) else 0\n            \n        low = 2\n        high = x//2 \n        while(low <= high):\n            mid = low + (high - low)//2\n            if( mid**2 < x):\n                low = mid + 1\n            \n            elif( mid**2 > x):\n                high = mid - 1\n            else:\n                return mid\n        return high\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			3,
			3.3333333333333335,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        r = x\n        while r*r>x:\n            r = (r+x//r)//2\n        return int(r)\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			7,
			6.545454545454546,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        if x==1: return 1\n        low=1\n        high=x//2\n        while low+1<high:\n            mid=(high+low)//2\n            if mid*mid==x:\n                return mid\n            elif mid*mid >x:\n                high=mid\n            else:\n                low=mid\n        if high*high>x:\n            return low\n        return high\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			6,
			8.571428571428571,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        '''\n        Using the iterative method developed for EDSAC to calculate sqrt(x)\n        https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#A_two-variable_iterative_method\n        \n        valid for 0 < x < 3\n        let a_0 = x, c_0 = x-1\n        then:\n        a_n+1 = a_n-(a_n*c_n)/2\n        c_n+1 = c_n^2*(c_n-3)/4\n        \n        for all n, x*(1+c_n) = a_n^2\n        so as c_n -> 0, a_n -> sqrt(x)\n        '''\n        \n        # eliminate trivial cases\n        if x == 0 or x == 1:\n            return x\n        \n        # floor(sqrt(x)) == floor(sqrt(x+k)) for 0 <= k < 1, so aim for the middle of that interval, x + 1/2\n        x += 0.5\n        \n        # initialise a = x and c = x-1, but method only valid for 0 < x < 3 with fastest convergence around x = 1\n        # so divide by 4 until 1/2 <= x < 2\n        a = x\n        factors_of_4 = 0\n        while a >= 2:\n            a /= 4\n            factors_of_4 += 1\n        c = a-1\n        \n        # iterate until error term less than 1/x^2, always gets suitably close\n        error = 1/x**2\n        while abs(c) > error:\n            a -= a*c/2\n            c = c*c*(c-3)/4\n        \n        # a = sqrt(x), but divided x by 4 many times earlier, so multiply a by 2 that many times for final answer\n        return int(a*2**factors_of_4)\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			6,
			6.75,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x:int)->int:\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x < 2:\n            return x\n\n        min_val = 0\n        max_val = x\n        new_x = x // 2\n\n        while new_x != min_val:\n            if x < new_x ** 2:\n                max_val = new_x\n            elif x > new_x ** 2:\n                min_val = new_x\n            else:\n                return new_x\n            new_x = (min_val + max_val) // 2\n        return new_x\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			6,
			7.6923076923076925,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x:int)->int:\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        # corner cases / bad inputs\n        if x == 0:\n            return 0\n\n        if x < 0:\n            return -2147483648\n\n        l, r = 1, 1\n        maximum, minimum = 0, x + 1\n        while maximum < minimum - 1:\n            if r * r <= x:\n                maximum = r\n                l = r\n                r = min(2 * r, int((minimum + l) / 2))\n            else:\n                minimum = r\n                r = int((l + r) / 2)\n\n        return maximum\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			3,
			3.3333333333333335,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        num = x\n        while num * num > x:\n            num = (num + x//num) // 2\n        return num\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			4,
			5.0,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        l = 1\n        r = x\n        while l <= r:\n            mid = (l + r) // 2\n            if mid * mid <= x:\n                l = mid + 1\n            else:\n                r = mid - 1\n                \n        return l - 1\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			2,
			0.5,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        x = int(x**0.5)\n        return x\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			5,
			6.6,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        left, right = 0, x + 1\n        while left < right:\n            mid = left + (right - left) // 2\n            if mid ** 2 == x:\n                return mid\n            if mid ** 2 < x:\n                left = mid + 1\n            else:\n                right = mid\n        return left - 1\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			12,
			13.91304347826087,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        half = x//2\n        index = x - half\n        while True:\n            if index*index == x:\n                return index\n            elif (index*index < x) and ((index+1)*(index+1) > x):\n                return index\n            elif (index*index > x) and ((index-1)*(index-1) < x):\n                return (index-1)\n            elif index*index > x:\n                half = max(half//2, half%2)\n                index -= half\n            elif index*index < x:\n                half = max(half//2, half%2)\n                index += half\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			2,
			1.8,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        return int((x ** (1/2)) // 1)\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			2,
			0,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        result = math.sqrt(x)\n        return int(result)\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			9,
			8.0,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n\n        if x == 1 or x == 0:\n            return x\n\n        lower = 0\n        upper = x//2 if x > 4 else x\n        middle = (lower + upper +1)//2\n\n        while True:\n            if (middle * middle <= x) and ((middle + 1) * (middle + 1) > x) :\n                break\n            elif middle * middle > x:\n                upper = middle\n            elif (middle+1) * (middle+1) <= x:\n                lower = middle\n            middle = (lower + upper +1)//2\n        return middle\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			7,
			5.384615384615385,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        if x == 1:\n            return 1\n\n        lower = 0\n        upper = x // 2 if x > 5 else x\n        middle = (lower + upper) // 2\n\n        while True:\n            if middle * middle == x:\n                return middle\n            elif middle * middle > x:\n                upper = middle\n            else:\n                lower = middle\n\n            if (lower + upper) // 2 == middle:\n                return middle\n            middle = (lower + upper) // 2\n\n\n    return mySqrt(x)\n"
		],
		[
			1.0,
			1.0,
			2,
			0,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n        return int(sqrt(x))\n\n\n    return mySqrt(x)\n"
		],
		[
			3.0505438468629125,
			1.0,
			5,
			8.4,
			"def mySqrt(x:int={\"start\":0,\"end\":1000}):\n    def mySqrt(x: int) -> int:\n            i = 0\n            while i <= x:\n                if i*i == x:\n                    return i\n                elif i*i > x:\n                    return i - 1\n                i += 1\n\n\n    return mySqrt(x)\n"
		]
	],
	"REVERSE_INTEGER": [
		"1",
		[
			1.0,
			1.0,
			4,
			2.75,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n            minLimit = -2**31\n            maxLimit = 2**31\n            \n            numStr = str(x) #Conversion\n            numStr = numStr[::-1] #Reverse digits\n            \n            if numStr.endswith(\"-\"):\n                numStr = \"-\" + numStr[:-1] #Remove \"-\" sign from the end and add it to the beginning\n\n            number = int(numStr)\n            if number not in range(minLimit,maxLimit): #Overflow\n                return 0\n            \n            return number\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			8,
			6.285714285714286,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        if not x:\n            return x\n        x = list(str(x))\n        while x[-1] == '0' and len(x) > 1:\n            x.pop()\n        left,right = 0,len(x)-1\n        if x[left] == '-':\n            left += 1\n        while left < right:\n            x[left],x[right] = x[right],x[left]\n            left += 1\n            right -= 1\n        x = \"\".join(x)\n        return 0 if int(x).bit_length() > 31 else int(x)\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			4.75,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        if(x<0):\n            s=-int((str(-1*x)[::-1]))\n            return s if(s>-2**31) else 0\n        s=int((str(x)[::-1]))\n        return s if (s<2**31-1) else 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			3.0,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        if x > 0:\n            ans = int(str(x)[:: -1])\n            return ans if ans < 2**31 else 0\n        ans = - int(str(- x)[:: -1])\n        return ans if ans > - 2**31 else 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			4.25,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        # initialize variable \"result\" as a reversed string of the characters\n        result = str(x)[::-1]\n        # if the number was negative, the last character will be \"-\"\n        # remove the \"-\" from the end of the string and turn into negative int of the characters\n        if result[-1] == \"-\":\n            result = -int(result[:-1])\n        # if the number was not negative, turn into an int\n        else:\n            result = int(result)\n        # if the result is larger than a 32-bit int, return 0\n        if result > 2**31 or result < -2**31:\n            return 0\n        return result\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			9,
			5.157894736842105,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        \n        result = 0\n        limit = 2147483647 if x>=0 else -2147483648\n        sign = 1 if x>=0 else -1\n\n        for i, s in enumerate(str(abs(x))):\n            if x > 0:\n                if result+int(s)*pow(10, i) > limit:\n                    return 0\n                \n            elif x < 0:\n                if result-int(s)*pow(10, i) < limit:\n                    return 0\n            \n\t\t\t# Addition is guaranteed to be in the range: [-2147483648,  2147483647]\n            result = result + sign*int(s)*pow(10, i)\n            \n        return result\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			4.0,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        if x < 0:\n            s =- 1\n        else:\n            s = 1\n        ans = s * int(str(abs(x))[::-1])\n            # negative value can make a copy of the list in reverse order\n            # also works for tuples, arrays, and strings\n        if -2**31 <= ans <= 2**31-1:\n            return ans\n        else:\n            return 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			1.8333333333333333,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        res=str(x)\n        if (x<0):\n            res=int(\"-\" + res[1:][::-1] )\n            return res if -2147483648 < res else 0    \n        else:\n            res=int(res[::-1])\n            return res if res < 2147483647 else 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			3.911764705882353,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        x, digit= str(x), str()\n        if int(x) < 0:\n            x += \"-\"\n            x = x[1:]\n        for i in reversed(x): digit += i\n        if int(digit)<(-2**31) or int(digit)>((2**31)-1): return 0\n        else: return int(digit)\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			1.0,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        rev = int(str(abs(x))[::-1])\n\t\t\n        if (rev.bit_length() < 32):\n            if x < 0:\n                return -rev\n            else:\n                return rev\n        else:\n            return 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			4,
			1.0,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        rev = int(str(abs(x))[::-1])\n        return (-rev if x < 0 else rev) if rev.bit_length() < 32 else 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			4.166666666666667,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        s = -1 if x < 0 else 1\n        x_ = str(x)[-1::-1] if s == 1 else str(x)[-1:0:-1]\n        ans = s*int(x_)\n        return ans if abs(ans) < 2**31 else 0\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			4.576923076923077,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        \n        d=abs(x)\n        newNum=0\n    \n        while d>0:\n            d,m=divmod(d,10)\n            newNum=(newNum*10)+m\n        \n        if newNum>=(2**31)-1:\n            return 0\n        return newNum if x>0 else newNum*-1\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			5.333333333333333,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        a = list(str(abs(x)))\n        b = 0\n        for i in range(len(a)):\n            b += int(a[i]) * (10 ** i)\n        \n        if b < -(2**31) or b > ((2**31) - 1):\n            return 0\n        \n        if x < 0:\n            return (-1) * b\n        else:\n            return b\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			5,
			3.923076923076923,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        rev = int(str(abs(x))[::-1])\n        i = -rev if x < 0 else rev\n        if i < -2**31 or i > 2**31-1:\n            return 0\n        return i\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			7,
			8.5,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        reversed_number_string = \"\"\n        largest_integer_32_bit = pow(2, 31)\n        is_negative = False\n        if x == 0:\n            return 0\n        if x < 0:\n            x = abs(x)\n            is_negative = True\n        while x != 0:\n            reversed_number_string += str(x % 10)\n            x = int(x / 10)\n        reversed_number = int(reversed_number_string)\n        if reversed_number > largest_integer_32_bit:\n            return 0\n        if is_negative:\n            return reversed_number * -1\n        return reversed_number\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			5.5,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        \n        sign = 1\n        if x < 0:\n            sign = -1\n            x = -x\n        num = str(x)[::-1]\n        num = int(num)\n        if num < -(2**31) or num > 2**31 - 1:\n            return 0\n        return -num if sign is -1 else num\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			3.75,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        output = ''\n        str_x = str(x)\n        if str_x[0] == '-':\n            output+='-'\n            for i in range(len(str_x)-1,0,-1):\n                output+=str_x[i]\n        else:\n            for j in range(len(str_x)-1,-1,-1):\n                output+=str_x[j]\n        if int(output) not in range(-2147483648,2147483648):\n            return 0\n        return int(output)\n\n\n    return reverse(n)\n"
		],
		[
			1.0,
			1.0,
			6,
			10.8,
			"def reverse(n:int):\n    def reverse(x: int) -> int:\n        isneg = x<0\n        x = abs(x)\n        rev = 0\n        while(x>0):\n            rem = x%10\n            rev = rev*10+rem\n            x = x//10\n        \n        if rev >= 2** 31 -1 or rev <= -2** 31:\n            return 0\n\n        elif isneg:\n            return 0-rev\n        else:\n            return rev \n\n\n    return reverse(n)\n"
		]
	],
	"CATALAN_NUM": [
		"n^3",
		[
			95.70238729893752,
			21.9286639041882,
			6,
			3.5,
			"def numTrees(n:int):\n    def count_bsts(min_val: int, max_val: int, memo: dict) -> int:\n        if min_val >= max_val:\n            return 1\n\n        elif (min_val, max_val) in memo:\n            return memo[(min_val, max_val)]\n\n        bsts_count = 0\n        for val in range(min_val, max_val + 1):\n\n            left_subtrees_count = count_bsts(min_val, val - 1, memo)\n            right_subtrees_count = count_bsts(val + 1, max_val, memo)\n\n            bsts_count += left_subtrees_count * right_subtrees_count\n\n        memo[(min_val, max_val)] = bsts_count\n\t\t\t\n        return bsts_count\n\n    def numTrees(n: int) -> int:\n        return count_bsts(1, n, {})\n\n\n    return numTrees(n)\n"
		],
		[
			25.971904640036655,
			7.054330046082897,
			12,
			10.565217391304348,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        memo={}\n        return sol(n,memo)\n\n    def sol(n, memo):\n        if(n not in memo):\n            if(n==1 or n==0): return 1\n            if(n==2): return 2\n            if(n==3): return 5\n            result=0\n            mid=n//2\n            if(n%2==0):\n                for i in range(1,mid+1):\n                    result += 2*sol(i-1,memo)*sol(n-i,memo)\n            else:\n                mid+=1\n                for i in range(1,mid+1):\n                    if(i!=mid):\n                        result += 2*sol(i-1,memo)*sol(n-i,memo)\n                    else:\n                        result += sol(i-1,memo)*sol(n-i,memo)\n            memo[n]=result\n        return memo[n]\n\n\n    return numTrees(n)\n"
		],
		[
			25.980314637303778,
			11.602234701688182,
			4,
			1.9090909090909092,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        ar=[0]*(n+1)\n        ar[0]=1\n        for i in range(1,n+1):\n            for j in range(i):\n                ar[i]=ar[i]+(ar[j]*ar[i-j-1])\n        return ar[n]\n\n\n    return numTrees(n)\n"
		],
		[
			26.9246528557259,
			7.046010778005301,
			6,
			4.909090909090909,
			"def numTrees(n:int):\n    def numTrees(n: int, l = {}) -> int:\n        if n==0 or n==1:\n            return 1\n        if n in l:\n            return l[n]\n        count = 0\n        for i in range(1,n+1):\n            count+=numTrees(i-1,l)*numTrees(n-i,l)\n        l[n] = count\n        return count\n\n\n    return numTrees(n)\n"
		],
		[
			26.81182975780879,
			5.920252460177478,
			4,
			2.25,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        ans = {}\n        ans[0] = 1  ### for the case where left side or right side no elements\n        ans[1] = 1\n        ans[2] = 2\n        \n        for i in range(3,n+1):   ###  to find numTrees() for elements before n..so we can use that in our DP\n            cnt = 0    \n            for j in range(1,i+1):  ###  split element on all possible index from index 1 to index last\n                right = i-j      ### number of elements in right\n                left = j-1       ### number of elements in left\n                \n                r_cnt=ans[right]  ###  number of combinations of right side\n                l_cnt=ans[left]   ###  number of combinations of left side\n                \n                cnt += l_cnt*r_cnt  ###  total combination possbile from that tree is left*right\n                \n            ans[i] = cnt           ### add final ans to DP..so we can use later\n            \n        return ans[n]\n\n\n    return numTrees(n)\n"
		],
		[
			7.346946707258494,
			4.43354732108043,
			2,
			1.7142857142857142,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        num = math.factorial(2*n)\n        denom = math.factorial(n)*math.factorial(n+1)\n        return num // denom\n\n\n    return numTrees(n)\n"
		],
		[
			25.829838599000443,
			11.604043694109818,
			4,
			2.727272727272727,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        dp = [0]*(n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i-1-j]\n        return dp[-1]\n\n\n    return numTrees(n)\n"
		],
		[
			4483.84919139179,
			6.900561204976058,
			4,
			2.2222222222222223,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        if n == 0:\n            return 1\n        numSubtrees = 0\n        for leftSubtreeNodeCount in range(n):\n            rightSubtreeNodeCount = n - 1 - leftSubtreeNodeCount\n            leftSubtrees = numTrees(leftSubtreeNodeCount)\n            rightSubtrees = numTrees(rightSubtreeNodeCount)\n            numSubtrees += leftSubtrees * rightSubtrees\n        return numSubtrees\n\n\n    return numTrees(n)\n"
		],
		[
			59.332430719721465,
			7.047839192405091,
			5,
			3.0,
			"def numTrees(n:int):\n    def numTrees(n: int, cache={}) -> int:\n        if n == 0:\n            return 1\n        if n in cache:\n            return cache[n]\n        numSubtrees = 0\n        for leftSubtreeNodeCount in range(n):\n            rightSubtreeNodeCount = n - 1 - leftSubtreeNodeCount\n            leftSubtrees = numTrees(leftSubtreeNodeCount, cache)\n            rightSubtrees = numTrees(rightSubtreeNodeCount, cache)\n            numSubtrees += leftSubtrees * rightSubtrees\n        cache[n] = numSubtrees\n        return numSubtrees\n\n\n    return numTrees(n)\n"
		],
		[
			27.47014009736324,
			11.596273015733274,
			4,
			2.25,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n                \n        # G(n) = solutions for n elements\n        # F(i,n) = element i as root, n elements\n        \n        \n        # Pseudo Code\n        #G(n) = Sum of all F(i,n)\n        #F(i,n) = G(i-1)*G(n-i)\n        \n        \n        # Example\n        # n = 3\n        \n        # base cases\n        # G(0) = 1\n        # G(1) = 1\n        \n        # G(3) = F(1,3)+F(2,3)+F(3,3)\n        \n        \n        # F(1,3) = G(0)*G(2) = 2\n        # Explanation \n        # Ex: G(0) = no elements on the left branch\n        # Ex: G(2) = 2 elements on the right branch\n        \n        # F(2,3) = G(1)*G(1) = 1\n        # Explanation\n        # Ex: G(1) = 1 element on the left branch\n        # Ex: G(1) = 1 element on the right branch\n        \n        # F(3,3) = G(2)*G(0) = 2\n        # Explanation \n        # Ex: G(2) = 2 elements on the left branch\n        # Ex: G(0) = no elements on the right branch\n        \n\n        g_array = [1,1]\n        \n        for j in range(2,n+1):\n            sum_g = 0\n            for i in range(1,j+1):\n                f_i = g_array[i-1]*g_array[j-i]\n                sum_g += f_i\n            g_array.append(sum_g)\n                        \n        return g_array[n]\n\n\n    return numTrees(n)\n"
		],
		[
			29.792583899568786,
			7.219720880878179,
			8,
			5.4,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        nodes = {}\n        if n == 1 or n == 0:\n            return 1\n        elif n == 2:\n            return 2\n        elif n in dp:\n            return dp[n]\n        for i in range(1, n+1):\n            nodes[i] = numTrees(i-1) * numTrees(n-i)\n\n        dp[n] = sum(nodes[i] for i in nodes)\n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			57.193211464341054,
			5.9413717123668475,
			5,
			2.4,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n            dp = {0:1, 1:1, 2:2}\n            if n < 3: return dp[n]\n            for i in range(3, n+1):\n                num = 0\n                for j in range(i):\n                    num += dp[j]*dp[i-j-1]\n                dp[i] = num\n            return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			26.549743234868824,
			11.561157980210776,
			5,
			3.6,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        # Intuition:\n        #   - For each n we try to build BST with node i from 1 -> n as root node\n        #   - If n = 0 or 1 then only 1 way to form a BST tree\n        #   - For each i we have i - 1 nodes on left subtree and n - i nodes on right subtree\n        #   - The result is sum of all BST above. \n        #       G(n) = numTrees(1, n) + numTrees(2, n) + ... + numTrees(n, n)\n        #   - For each BST tree above we calculate number of left subtree * number of right subtree. We can see the sub problem here\n        #       numTrees(i, n) = G(i - 1) * G(n - i)\n        #   - Final formula:\n        #       G(n) = G(0) * G(n - 1) + G(1) * G(n - 2) + ... + G(n - 1) * G(0)\n        \n        # There is only one way to form BST with 0 or 1 node\n        if n <= 1:\n            return 1\n        \n        # Build up solution from 0 to n\n        dp = [0] * (n + 1)\n        # We already know the result for input = 1, input = 2\n        dp[0], dp[1] = 1, 1\n        \n        # Continue calculate result for input from 2 -> n\n        for i in range(2, n + 1):\n            # For each i calculate all possible structurally BSTs that can form by j as root node\n            for j in range(1, i + 1):\n                dp[i] += dp[j - 1] * dp[i - j]\n            \n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			56.93505337087492,
			11.545887833486072,
			5,
			4.5,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        dp = [0 for i in range(n+1)]\n        dp[0], i = 1, 1\n        while i<=n:\n            l, r = i-1, 0\n            while l >= 0:\n                dp[i] += (dp[l]*dp[r])\n                l-=1\n                r+=1\n            i+=1\n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			57.689658330029054,
			11.774254241489826,
			5,
			3.111111111111111,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        if n <= 2:\n            return n\n        \n        dp = {0: 1, 1: 1, 2: 2}\n        for i in range(3, n+1): #n+1 so that N is also included\n            #now assume every node as a root and then calculate\n            #start from 1, because, I assume I take 1st node as the root\n            sm = 0\n            for j in range(1, i+1):\n                sm += dp[j-1]*dp[i - j]\n            dp[i] = sm\n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			57.28363005012152,
			12.873456573079086,
			4,
			1.7142857142857142,
			"def numTrees(n:int):\n    def numTrees(n):\n        dp = { 0:1, 1:1 }\n        for x in range(2,n+1):\n            dp[x] = sum([ dp[y]*dp[x-y-1] for y in range(x) ] )\n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			52.79010368437834,
			12.050894115551642,
			5,
			5.0,
			"def numTrees(n:int):\n    def numTrees(n):\n        dp = { 0:1, 1:1 }\n        for x in range(2,n+1):\n            dp[x] = 2 * sum([ dp[y]*dp[x-y-1] for y in range(x//2) ] )\n            if x%2:\n                dp[x] += dp[x//2]**2\n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			25.68554116409362,
			11.898120976184789,
			4,
			2.25,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n\t\t# dp: store the result(status) in dictionary from the bottom, so we don't have to calculate every time\n        dp = {}\n        dp[0] = 1\n\n        # num : every size of the tree in range(1, n + 1)\n        for num in range(1, n + 1):\n            res = 0\n            \n\t\t\t# choose pivot i, the total result = left * right\n            for i in range(1, num + 1): \n                res = res + dp[i - 1] * dp[num - i]\n            dp[num] = res\n        return dp[n]\n\n\n    return numTrees(n)\n"
		],
		[
			14.677770077178916,
			1.0,
			2,
			2.0,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        return int(round(reduce(lambda a, b: a * ((b + n) / b), list(range(2, n + 1)), 1)))\n\n\n    return numTrees(n)\n"
		],
		[
			29.31669692157892,
			6.940708018873627,
			5,
			2.857142857142857,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        table = [-1] * (n+1)\n        table[0] = 1\n        return numTreesRec(n)\n\n    def numTreesRec(n):\n        if table[n] != -1:\n            return table[n]\n        total = 0\n        for m in range(n):\n            total += (numTreesRec(n-1-m) * numTreesRec(m))\n        table[n] = total\n        return total\n\n\n    return numTrees(n)\n"
		],
		[
			47.8426720486183,
			11.638533630399142,
			4,
			1.9090909090909092,
			"def numTrees(n:int):\n    def numTrees(n: int) -> int:\n        dp = [0] * (n+1)\n        dp[0] = 1\n        for i in range(1, n+1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i- 1 - j]\n        return dp[n]\n\n\n    return numTrees(n)\n"
		]
	],
	"ANAGRAM": [
		"nm",
		[
			17.77150866406932,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			4.163385723054068,
			1.0,
			8,
			3.25,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n        count ={}\n\t\t# +1 for s and -1 for t. If the char from s not in count then assign 1 and if the char from t not in count , then assign -1. \n        for i in range(len(s)):\n            if s[i] in count:\n                count[s[i]] +=1\n            else:\n                count[s[i]] =1\n            if t[i] in count:\n                count[t[i]] -=1\n            else:\n                count[t[i]] = -1\n        \n        for key,value in count.items():\n            if value !=0:\n                return False\n        return True\n\n\n    return isAnagram(a,b)\n"
		],
		[
			14.053433355287718,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s, t):\n\t\t    return Counter(s)==Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			14.515697628414582,
			3.321209877787336,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return Counter(t)==Counter(s)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			13.884015378849366,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return Counter(s)==Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			14.044299794603072,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			6.323449491516759,
			3.222924782263765,
			8,
			2.857142857142857,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s, t):\n        dictionary = {}\n        \n        for i in s:\n            if i in dictionary:\n                dictionary[i] += 1\n            else:\n                dictionary[i] = 1\n\n        for i in t:\n            if i in dictionary:\n                dictionary[i] -= 1\n            else:\n                return False\n\n        for val in dictionary.values():\n            if val != 0:\n                return False\n        \n        return True\n\n\n    return isAnagram(a,b)\n"
		],
		[
			6.312556496483786,
			3.2357863395690916,
			8,
			2.857142857142857,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        \n        dicts = {}\n        \n        for i in s:\n            if i in dicts:\n                dicts[i] += 1\n            else:\n                dicts[i] = 1\n        \n        for i in t:\n            if i in dicts:\n                dicts[i] -= 1\n            else:\n                return False\n        \n        for value in dicts.values():\n            if value != 0:\n                return False\n        \n        return True\n\n\n    return isAnagram(a,b)\n"
		],
		[
			15.01581773652177,
			3.1025878731838006,
			6,
			2.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        dic_s, dic_t = {}, {}\n        for letter in s:\n            if letter not in dic_s:\n                dic_s[letter] = 1\n            else:\n                dic_s[letter] += 1\n        for letter in t:\n            if letter not in dic_t:\n                dic_t[letter] = 1\n            else:\n                dic_t[letter] += 1\n        return dic_t == dic_s\n\n\n    return isAnagram(a,b)\n"
		],
		[
			15.470417084131048,
			11.630953633725719,
			7,
			1.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        \n        # convert strings to lists\n        s_list = []\n        t_list = []\n        \n        for item in s:\n            s_list.append(item)\n            \n        for item in t:\n            t_list.append(item)\n            \n        # loop through items in list\n        for item in s_list:\n            \n            # if it is in the other list, remove that item\n            if item in t_list:\n                \n                t_list.remove(item)\n\n            # if it is not in the other list, then return false\n            else:\n                return False\n            \n        # if the other list is empty\n        if not t_list:\n\n            return True\n\n\n    return isAnagram(a,b)\n"
		],
		[
			14.137836400377628,
			3.278828403593617,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s, t):\n        return Counter(s) == Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			16.618618464681425,
			1.0,
			5,
			2.2857142857142856,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n      char_count = {}\n      for char in s: char_count[char] = char_count.get(char, 0) + 1\n      for char in t: char_count[char] = char_count.get(char, 0) - 1\n      return False not in [char_count[char] == 0 for char in char_count]\n\n\n    return isAnagram(a,b)\n"
		],
		[
			15.42077438605427,
			1.0,
			8,
			2.857142857142857,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        count={}\n        for i in s:\n            if i in count:\n                count[i] +=1\n            else:\n                count[i]=1\n        for i in t:\n            if i in count:\n                count[i] -=1\n            else:\n                count[i]=1\n        for k in count:\n            if count[k]!=0:\n                return False\n        return True\n\n\n    return isAnagram(a,b)\n"
		],
		[
			6.998864014207174,
			2.984534281221772,
			6,
			2.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        obj1 = {}\n        obj2 = {}\n        \n        for i in s:\n            if i not in obj1:\n                obj1[i] = 1\n            else:\n                obj1[i] += 1\n        \n        for i in t:\n            if i not in obj2:\n                obj2[i] = 1\n            else:\n                obj2[i] += 1\n                \n        return obj1 == obj2    # In python you can compare dictionaries\n\n\n    return isAnagram(a,b)\n"
		],
		[
			7.346246865238356,
			2.9669811479369446,
			8,
			2.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s, t):\n        h = {}\n        for i in s:\n            if i not in h:\n                h[i] = 0\n            h[i] += 1\n                \n        for j in t:\n            if j not in h:\n                h[j] = 0\n            h[j] -= 1\n        \n        for key in h.keys():\n            if h[key] != 0:\n                return False\n            \n        return True\n\n\n    return isAnagram(a,b)\n"
		],
		[
			6.225874440612392,
			2.9836654605782917,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return(Counter(s) == Counter(t))\n\n\n    return isAnagram(a,b)\n"
		],
		[
			16.355304137400925,
			5.13912560364099,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return(sorted(s) == sorted(t))\n\n\n    return isAnagram(a,b)\n"
		],
		[
			5.873970800106537,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return Counter(t) == Counter(s)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			15.208385062994145,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        \n        return Counter(s) == Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			13.188849729092688,
			1.0,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)\n\n\n    return isAnagram(a,b)\n"
		],
		[
			5.635219869554784,
			3.0821665869968164,
			2,
			0.5,
			"def isAnagram(a:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}, b:str={\"upper_count\":0,\"lower_count\":10,\"digits_count\":0,\"special_count\":0}):\n    def isAnagram(s: str, t: str) -> bool:\n        ## RC ##\n        ## APPROACH : Counter ##\n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(1) ##\n        return Counter(s) == Counter(t)\n\n\n    return isAnagram(a,b)\n"
		]
	],
	"JUMP_GAME": [
		"n",
		[
			4.040451927396901,
			1.0,
			8,
			4.153846153846154,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        if nums[0] == 0 and len(nums) > 1:\n            return False\n        \n        # maximum_dis stands for the maximum distance we can reach so far \n        maximum_dis = 0\n        for i in range(len(nums)):\n            # If the current index is beyond the maximum distance we can jump to, directly return False\n            if i > maximum_dis:\n                return False\n            \n            # If maximum_dis larger or equal to the last index, it means we can reach the last index for sure\n            if maximum_dis >= len(nums) - 1:\n                return True\n            \n            # Update the maximum_dis\n            if nums[i] + i > maximum_dis:\n                maximum_dis = nums[i] + i\n\n\n    return canJump(l)\n"
		],
		[
			5.27640268614815,
			1.0,
			4,
			4.666666666666667,
			"def canJump(l:List[int]):\n    def canJump(nums:List[int])->bool:\n        max_reach = nums[0]\n        i = 0\n        while i <= max_reach and i < len(nums):\n            v = nums[i]\n            max_reach = max(max_reach, i + v)\n            i += 1\n        return max_reach >= len(nums) - 1\n\n\n    return canJump(l)\n"
		],
		[
			6.239080128549644,
			4.573068968662136,
			6,
			3.6666666666666665,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        # cover simple cases\n        if len(nums) == 1:\n            return True\n        elif nums[0] == 0:\n            return False\n        # process from right to left and keep track of\n        # how many steps are need to get to the end\n        min_steps_needed = 0\n        for num in reversed(nums[:-1]):\n\t\t\t# we need at least one step to get from one index to the next one\n            min_steps_needed += 1\n\t\t\t# if we have least that number at the current index, we can reset the step counter\n            if num >= min_steps_needed:\n                min_steps_needed = 0\n\t\t# if we do not need extra steps, return True (`min_steps_needed = 0`) and \n\t\t# otherwise False (`min_steps_needed > 0`)\n        return min_steps_needed == 0\n\n\n    return canJump(l)\n"
		],
		[
			7.108597671200999,
			1.0,
			6,
			5.444444444444445,
			"def canJump(l:List[int]):\n    def canJump(nums:List[int])->bool:\n        required_length = 1\n\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] > 0 and nums[i] >= required_length:\n                required_length = 1\n            else:\n                required_length += 1\n\n\n        if required_length == 1:\n            return True\n\n        return False\n\n\n    return canJump(l)\n"
		],
		[
			5.249628810950217,
			1.0,
			4,
			1.3333333333333333,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n# greedy -- reach means last num's maximum reach position, if current index > reach, then means can't reach current position from last number\n        reach = 0\n        for i, num in enumerate(nums):\n            if i > reach:\n                return False\n            reach = max(reach, i + num)\n        return True\n\n\n    return canJump(l)\n"
		],
		[
			5.8010960070507025,
			1.0,
			5,
			2.5,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        max_span = 0\n        for i, num in enumerate(nums):\n            if i + num >= len(nums) - 1:\n                return True\n            max_span = max(max_span - 1, num)\n            if max_span == 0:\n                return False\n\n\n    return canJump(l)\n"
		],
		[
			5.572589132267348,
			1.0,
			4,
			1.3333333333333333,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        maxdis = 0  # max distance can be reached after i iteration\n        for i in range(len(nums)):\n            if i > maxdis: return False #if position i can not be reached, False\n            maxdis = max(nums[i]+i, maxdis) # max distance may or may not be updated\n        return True\n\n\n    return canJump(l)\n"
		],
		[
			6.6745448580463265,
			1.0,
			4,
			2.0,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        p=nums[0] #index of farthest potion can reach for now\n        for i in range(1,len(nums)):\n            if p>=i:\n                p = max(p, nums[i]+i)\n        return p>=len(nums)-1\n\n\n    return canJump(l)\n"
		],
		[
			5.374196072471358,
			1.0,
			4,
			1.3333333333333333,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:        \n        maxDistReacheable = nums[0]\n        for i in range(1,len(nums)):\n            if(i > maxDistReacheable):\n                return False\n            maxDistReacheable = max( maxDistReacheable, i + nums[i] )\n        return True\n\n\n    return canJump(l)\n"
		],
		[
			5.252529906494773,
			1.0,
			6,
			3.5714285714285716,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n            \n        max_ind = 0     \n        \n        for i, num in enumerate(nums):\n            if max_ind >= len(nums)-1:\n                return True\n            \n            if num==0:\n                if max_ind<=i:\n                    return False\n            \n            max_ind = max(i+num, max_ind)\n\n\n    return canJump(l)\n"
		],
		[
			5.081533326619971,
			4.5728838999498045,
			4,
			2.5,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        x = 1\n        for y in nums[:-1]:\n            x = max(x-1, y)\n            if x == 0:\n                return False\n        return True\n\n\n    return canJump(l)\n"
		],
		[
			5.422717077787589,
			1.0,
			7,
			4.5,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        n = len(nums)\n        interval = [0, 0]\n        if n <= 1:\n            return True\n        \n        while True:\n            can_reach = -1\n            \n            for i in range(interval[0], interval[1] + 1):\n                can_reach = max(can_reach, i + nums[i])\n            \n            if can_reach >= n - 1:\n                return True\n            \n            interval = [interval[1] + 1, can_reach]\n            \n            if interval[0] > interval[1]:\n                return False\n        \n        assert(False)\n\n\n    return canJump(l)\n"
		],
		[
			4.759109060205821,
			1.0,
			5,
			2.6666666666666665,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        ln = len(nums)\n        can_reach = 0\n        for idx, num in enumerate(nums):\n            # i can't reach idx, then I can't move forward\n            if idx > can_reach:\n                return False\n            \n            can_reach = max(can_reach, idx + num) \n            #I just passed my destiny\n            if can_reach >= ln - 1:\n                return True\n                    \n        \n        return False\n\n\n    return canJump(l)\n"
		],
		[
			6.940423687374592,
			1.0,
			5,
			5.25,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        N = len(nums)\n        if N <= 1:\n            return True\n        j = N - 1  # smallest OK index\n        for i in range(N-2, -1, -1):\n            if i + nums[i] >= j:\n                j = i\n        return j == 0\n\n\n    return canJump(l)\n"
		],
		[
			7.524762281301224,
			1.0,
			6,
			4.0,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        prev = 0\n        for i in range(0,len(nums)):\n            x = i + nums[i]\n            if i <= prev and x > prev:\n                prev = x\n            if prev >= len(nums)-1:\n                return True\n        return False\n\n\n    return canJump(l)\n"
		],
		[
			5.382779369798691,
			1.0,
			5,
			3.0,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        reachableIndex = 0\n        for curr in range(len(nums)):\n            if curr + nums[curr] >= reachableIndex:\n                reachableIndex = curr + nums[curr]\n            if curr == reachableIndex:\n                break\n                \n        return reachableIndex >= len(nums) - 1\n\n\n    return canJump(l)\n"
		],
		[
			5.3518347732908795,
			1.0,
			5,
			4.642857142857143,
			"def canJump(l:List[int]):\n    def canJump(A:List[int])->bool:\n        last = len(A)-1\n        if not last:\n            return True\n        i   = 0\n        Lim = i + A[i]\n        while i < Lim:\n            i += 1\n            Lim = max(Lim, i+A[i])\n            if Lim>=last:\n                return True\n        return False\n\n\n    return canJump(l)\n"
		],
		[
			5.518795322904879,
			1.0,
			4,
			4.666666666666667,
			"def canJump(l:List[int]):\n    def canJump(nums:List[int])->bool:\n        bestJumper,i = nums[0],0\n        while i<len(nums) and i<= bestJumper: \n            bestJumper,i = max(bestJumper,i+nums[i]), i+1\n        return bestJumper>=len(nums)-1\n\n\n    return canJump(l)\n"
		],
		[
			5.651591693651521,
			1.0,
			5,
			3.75,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        if 0 not in nums:\n            return True\n        ladder=0\n        n=len(nums)-1\n        i=0\n        while(i!=n):\n            ladder=max(ladder,i+nums[i])   # ladder means the maximum index that can be reached from current index\n            if i>=ladder:     # this means we cant go any further (because we can only move further if ladder >current index)\n                return False\n            i+=1\n        return True\n\n\n    return canJump(l)\n"
		],
		[
			5.091177424259266,
			1.0,
			4,
			1.3333333333333333,
			"def canJump(l:List[int]):\n    def canJump(nums: List[int]) -> bool:\n        \n        ## RC ##\n        ## APPROACH : DP ##\n        ## LOGIC : At each index we calculate maximum reacheable distance found till now and more forward, if we go to index where it is not in range of recheable distance we return False ##\n        \n        # dp = [True] + [False] * (len(nums) - 1)                     # dp not required actually\n        \n        maxDistReacheable = nums[0]\n        for i in range(1,len(nums)):\n            if(i > maxDistReacheable):\n                return False\n            # dp[i] = True\n            maxDistReacheable = max( maxDistReacheable, i + nums[i] )\n        # return dp[-1]\n        return True\n\n\n    return canJump(l)\n"
		]
	],
	"COIN_CHANGE": [
		"nm",
		[
			25.44525541225271,
			5.161815274807001,
			8,
			6.923076923076923,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        if not coins or amount <= 0:\n            return 0\n        \n        f = [float('inf')] * (amount + 1)\n        f[0] = 0\n        for i in range(1, amount + 1):\n            for c in coins:\n                if i >= c:\n                    f[i] = min(f[i], f[i - c] + 1)\n        return f[amount] if f[amount] != float('inf') else -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			12.203907476219566,
			4.468548988727962,
			5,
			4.166666666666667,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        dp = [float(\"inf\")] * (amount + 1)  # DP Array of size (Amount +1) initialized to infinity\n        dp[0] = 0                           # Initializing no. of coins for [amount == 0] to o\n\n        for currCoin in coins:\n            for currAmount in range(currCoin, amount + 1):\n                dp[currAmount] = min(dp[currAmount], dp[currAmount - currCoin] + 1)\n\n        return dp[-1] if dp[-1] != float(\"inf\") else -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			11.094927754400054,
			6.84847256607578,
			9,
			7.045454545454546,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amt: int) -> int:\n        dp = [[0 for i in range(amt+1)]for i in range(len(coins)+1)]\n        for j in range(amt+1):\n            dp[0][j] = sys.maxsize\n        for i in range(1,len(coins)+1):\n            for j in range(1,amt+1):\n                if coins[i-1] > j:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = min(1+dp[i][j-coins[i-1]],dp[i-1][j])\n        if dp[-1][-1] != sys.maxsize:\n            return dp[-1][-1]\n        return -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			10.057774149778272,
			4.468165910979212,
			6,
			5.75,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n\t\t\n        #1D array\n        dp = [float(\"inf\")] * (amount + 1)\n\n        dp[0] = 0\n        n = len(coins)\n\n        for i in range(1, n + 1):\n            for j in range(amount + 1):\n                if coins[i - 1] <= j:\n                    dp[j] = min(dp[j], dp[j - coins[i - 1]] + 1)\n\n        return dp[-1] if dp[-1] != float(\"inf\") else -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			10.074063317832087,
			4.69880577642683,
			6,
			5.666666666666667,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        ## RC ##\n        ## APPROACH : DP ##\n        \n\t\t## TIME COMPLEXITY : O(N^2) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        dp = [0] + [amount + 1] * amount                                # fill invalid amount i.e amount + 1 for all amounts ranging from 0 to amount.\n        for value in range(amount+1):                                   # for each value till amount\n            for coin in (coins):                                        # for each coin\n                if(coin <= value):                                      # check if this coin can be used make value i.\n                    dp[value] = min(dp[value], 1 + dp[value - coin])    # 1 => current coin included, check the min coins required to make remaining value i.e  value - coin                    \n        return -1 if(dp[amount] > amount) else dp[amount]\n\n\n    return coinChange(l,amount)\n"
		],
		[
			9.11707093121851,
			5.891398029361402,
			11,
			6.0,
			"def coinChange(l:List[int],amount:int):\n    def bfs(node):\n        nodes_to_visit = deque([node])\n        nodes_visited = set([node])\n        depth = 0\n        count = 0\n        num_nodes = 1\n \n        while len(nodes_to_visit) > 0:\n            count += 1\n            if count == num_nodes:\n                depth += 1\n                count = 0\n                num_nodes = len(nodes_to_visit)\n            node = nodes_to_visit.popleft()\n            neighbours = [node - coin for coin in coin_universe]\n            for neighbour in neighbours:\n                if (neighbour not in nodes_visited) and (neighbour >= 0):\n                    if neighbour == 0: return depth\n                    nodes_visited.add(neighbour)\n                    nodes_to_visit.append(neighbour)\n        return -1\n\n    def coinChange(coin_universe:List[int], amount:int)->int:\n        \"\"\"\n        @time: O(n)\n        @space: O(1)\n        \"\"\"\n        if amount == 0: return 0\n        coin_universe = coin_universe\n        return bfs(amount)   \n\n\n    return coinChange(l,amount)\n"
		],
		[
			12.190043164489802,
			4.1625634103186195,
			6,
			6.333333333333333,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        numCoins = len(coins)\n        \n        # Values in this array equal the number of coins needed to achieve the cost of the index\n        minCoins = [amount + 1] * (amount + 1)\n        minCoins[0] = 0\n        \n        # Loop through every needed amount\n        for i in range(amount + 1):\n            # Loop through every coin value\n            for coin in coins:\n                # Check that the coin is not bigger than the current amount\n                if coin <= i:\n                    # minCoins[i]: number of coins needed to make amount i\n                    # minCoins[i-coin]: number of coins needed to make the amount before adding \n                    #                   the current coin to it (+1 to add the current coin)\n                    minCoins[i] = min(minCoins[i], minCoins[i-coin] + 1)\n        \n        # Check if any combination of coins was found to create the amount\n        if minCoins[amount] == amount + 1:\n            return -1\n        \n        # Return the optimal number of coins to create the amount\n        return minCoins[amount]\n\n\n    return coinChange(l,amount)\n"
		],
		[
			8.43183804279221,
			5.600980965079069,
			10,
			6.125,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins:List[int], amount:int)->bool:\n        his, coins, queue, step = set(), set(coins), {0}, 1\n        \n        if amount == 0: return 0\n        if amount in coins: return 1\n        \n        while queue:\n            new_queue = set()\n            for now in queue:\n                for i in coins:\n                    this = now+i\n                    if this in his or this>amount: \n                        continue\n                    else:\n                        his.add(this)\n\n                    if amount-this in coins:\n                        return step+1\n                    else:\n                        new_queue.add(this)\n                        \n            queue = new_queue\n            step += 1\n        return -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			10.150545654008594,
			4.777292421533203,
			7,
			5.538461538461538,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        if not coins or amount <= 0:\n            return 0\n        \n        f = [float('inf')] * (amount + 1)\n        f[0] = 0\n        for c in coins:\n            for a in range(c, amount + 1):\n                f[a] = min(f[a], f[a - c] + 1)\n        return f[amount] if f[amount] != float('inf') else -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			10.073794704079818,
			5.324525049198382,
			7,
			5.3125,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        \n        min_den  = [(amount+1) for i in range(0,amount+1)]\n        min_den[0] = 0\n        for i in range(1,len(min_den)):\n            min_val = min_den[i]\n            \n            for j in coins:\n                if i-j >=0:\n                    min_val = min(min_val, min_den[i-j]+1)\n                                        \n            min_den[i] = min_val\n\n        if min_den[-1]>amount:\n            return -1\n        else:\n            \n            return min_den[-1]\n\n\n    return coinChange(l,amount)\n"
		],
		[
			9.853145434191676,
			4.573253074827408,
			6,
			5.181818181818182,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        MAX = float('inf')\n        \n        dp = [0] * (amount + 1)\n            \n        for i in range(1, amount + 1):\n            dp[i] = min(dp[i - c] if i - c >= 0 else MAX for c in coins) + 1\n                \n        return -1 if dp[-1] == MAX else dp[-1]\n\n\n    return coinChange(l,amount)\n"
		],
		[
			8.812346045201306,
			5.984529458287818,
			10,
			8.571428571428571,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        if not coins or amount <= 0:\n            return 0\n        \n        coins = set(coins)\n        level = [amount]\n        visited = set([amount])\n        count = 0\n        while level:\n            count += 1\n            temp = []\n            for a in level:\n                if a in coins:\n                    return count\n                for c in coins:\n                    if a - c > 0 and (a - c) not in visited:\n                        temp.append(a - c)\n                        visited.add(a - c)\n            level = temp\n        return -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			13.361270261708215,
			5.25990734775812,
			8,
			5.1,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        \n        dp = [float('inf') for _ in range(amount+1)]\n        dp[0] = 0\n        \n        for money in range(1, amount+1):\n            if money in coins:\n                dp[money] = 1\n            else:\n                minvalue = float('inf')\n                for coin in coins:\n                    if money-coin > 0:\n                        minvalue = min(minvalue, dp[money-coin]+1)\n                dp[money] = minvalue\n\n        return dp[amount] if dp[amount] != float('inf') else -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			13.18944146364604,
			12.398780406250173,
			6,
			7.0,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        coins.sort()\n        changes=[amount+1]*(amount+1)\n        changes[0]=0\n        for i in range(1,amount+1):\n            for coin in coins:\n                if coin>i:\n                    break\n                else:\n                    changes[i]=min(changes[i],changes[i-coin]+1)\n        return changes[-1] if changes[-1]!=(amount+1) else -1\n\n\n    return coinChange(l,amount)\n"
		],
		[
			13.277626558795989,
			4.585148760033932,
			7,
			6.25,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        \n        memo = [float(\"inf\")]*(amount+1)\n        memo[0] = 0\n        \n        for i in range(1,amount+1):\n            for coin in coins:\n                \n                if i-coin >= 0 and memo[i] > memo[i-coin]+1:\n                    memo[i] = memo[i-coin]+1\n\n        if memo[amount] == float(\"inf\"):\n            return -1\n        return memo[amount]\n\n\n    return coinChange(l,amount)\n"
		],
		[
			9.867881056414278,
			4.39073066258336,
			5,
			4.166666666666667,
			"def coinChange(l:List[int],amount:int):\n    def coinChange(coins: List[int], amount: int) -> int:\n        maxi = 100001\n        dp = [maxi]*(amount+1)\n        dp[0] = 0\n        for c in coins:\n            for i in range(c,amount+1):\n                dp[i] = min(dp[i],dp[i-c]+1)\n                \n        if dp[-1]==maxi: return -1\n        else: return dp[-1]\n\n\n    return coinChange(l,amount)\n"
		]
	],
	"COUNT_ISLANDS": [
		"n^3",
		[
			65.91806227437733,
			21.313592721579738,
			16,
			5.2,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n            count = 0\n            for r,row in enumerate(grid):\n                for c,col in enumerate(row):\n                    if grid[r][c] == '1':\n                        removeNeighbors(r,c,grid)\n                        count += 1\n            return count            \n\n    def removeNeighbors(r ,c, grid):\n        grid[r][c] = 0 \n        # print(grid)   \n        if r+1 < len(grid) and grid[r+1][c] == '1':\n            removeNeighbors(r+1,c,grid)\n        if c+1 < len(grid[0]) and grid[r][c+1] == '1':\n            removeNeighbors(r,c+1,grid)    \n        if r-1 >= 0 and grid[r-1][c] == '1':\n            removeNeighbors(r-1,c,grid)\n        if c-1 >= 0 and grid[r][c-1] == '1':\n            removeNeighbors(r,c-1,grid)   \n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			32.3968681983684,
			21.308715814646433,
			11,
			4.6875,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\" \n        ans = 0\n        for r0, row in enumerate(grid):\n            for c0, val in enumerate(row):\n                if val==\"1\":\n                    stack = [(r0, c0)]\n                    ans=ans+1\n                    while stack:\n                        r, c = stack.pop()\n                        \n                        if (0 <= r < len(grid) and 0 <= c < len(grid[0]) and grid[r][c]==\"1\") :\n                    \n                            \n                            \n                            grid[r][c]=\"0\"\n                            p=[(r,c-1),(r,c+1),(r-1,c),(r+1,c)]\n                            stack+=p\n                    #ans+=1\n                            \n        return ans\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			32.93731443093408,
			21.296851824825875,
			11,
			4.928571428571429,
			"def numIslands(g:List[List[int]]):\n    def countIslands(grid: List[List[str]], row, col) -> None:\n        if(row in [-1, len(grid)] or col in [-1, len(grid[0])] or grid[row][col] == \"0\"):\n            return\n        grid[row][col] = \"0\"\n        countIslands(grid, row, col-1)\n        countIslands(grid, row-1, col)\n        countIslands(grid, row, col+1)\n        countIslands(grid, row+1, col)\n        return\n\n    def numIslands(grid: List[List[str]]) -> int:\n        count = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == \"1\":\n                    count += 1\n                    countIslands(grid, row, col)\n        return count\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			58.24764718516031,
			21.329506236867196,
			13,
			4.6875,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        total_islands = 0\n        def recursive_islands(grid, m, n):\n            if grid[m][n] == '0':\n                return \n            \n            grid[m][n] = '0'\n            if m-1 >= 0:\n                recursive_islands(grid, m-1,n)\n            if m+1<len(grid):\n                recursive_islands(grid, m+1, n)\n            if n-1 >= 0:\n                recursive_islands(grid, m, n-1)\n            if n+1 < len(grid[0]):\n                recursive_islands(grid, m, n+1)\n                \n            \n        \n        for i in range(0, len(grid)):\n            for j in range(0, len(grid[0])):\n                if grid[i][j] == '1':\n                    #then we go into recursion to mark everything 0\n                    recursive_islands(grid, i, j)\n                    total_islands+=1\n                else:\n                    continue\n        \n        return total_islands\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			31.423547144791712,
			21.296772285226677,
			13,
			4.875,
			"def numIslands(g:List[List[int]]):\n    def dfs(i, j, grid):\n\n        if i < 0 or i >= len(grid):\n            return\n\n        if j < 0 or j >= len(grid[0]):\n            return\n\n        if grid[i][j] == '0':\n            return\n\n        grid[i][j] = '0'\n\n        dfs(i - 1, j, grid)\n        dfs(i + 1, j, grid)\n        dfs(i, j - 1, grid)\n        dfs(i, j + 1, grid)\n\n    def numIslands(grid: List[List[str]]) -> int:\n\n        island_count = 0\n\n        for i, _ in enumerate(grid):\n            for j, _ in enumerate(grid[i]):\n                if grid[i][j] == '1':\n                    dfs(i, j, grid)\n                    island_count += 1\n\n        return island_count\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			33.65488556494408,
			21.197855404091932,
			11,
			4.909090909090909,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        #\u5982\u679c\u662f grid \u4e3a\u7a7a\uff0c\u8fd4\u56de 0\n        if not grid: return 0\n        row, col,island = len(grid), len(grid[0]), 0\n        \n        # dfs \u7528\u5faa\u73af\u6216\u8005\u9012\u5f52\uff0c\u627e\u5230\u4e00\u683cisland\u4e4b\u540e\uff0c\u5c06\u5176\u6539\u6210 water\uff0c\u7136\u540e\u6cbf\u7740\u56db\u4e2a\u65b9\u5411\u7ee7\u7eed\u505a dfs \u68c0\u67e5\n        def dfs(x,y):\n            if x in range(row) and y in range(col) and grid[x][y]==\"1\":\n                grid[x][y] = 0\n                list(map(dfs,(x+1,x-1,x,x),(y,y,y+1,y-1))) \n                return 1 \n# ***\u627e\u5230\u4e00\u683c island\uff0c\u8fd4\u56de \u4e00\u4e2a 1\uff0c\u4f46\u662f\u53ea\u6709\u6700\u540e\u7684\u4e00\u4e2a\u683c\u5b50\u8fd4\u56de\u7684 1 \u624d\u4f1a\u88ab nested loop \u8bb0\u5f55\u5728list\u91cc\u6c42sum***\n            return 0 #\u5982\u679c\u662f water \u6216\u8005\u8d85\u754c\u8fd4\u56de 0\n        \n        # Nested loop \u5fc5\u987b\u653e\u5728 list \u91cc, \u5bf9\u8fd4\u56de\u503c 1\uff0cisland \u7684\u4e2a\u6570\u6c42\u548c\n        return sum([dfs(i,j) for i in range(row) for j in range(col)])\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			34.226502902728136,
			21.060945091874007,
			12,
			4.4,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        #\u5982\u679c\u662f grid \u4e3a\u7a7a\uff0c\u8fd4\u56de 0\n        if not grid: return 0\n        row, col,island = len(grid), len(grid[0]), 0\n        \n        # dfs \u7528\u5faa\u73af\u6216\u8005\u9012\u5f52\uff0c\u627e\u5230\u4e00\u683cisland\u4e4b\u540e\uff0c\u5c06\u5176\u6539\u6210 water\uff0c\u7136\u540e\u6cbf\u7740\u56db\u4e2a\u65b9\u5411\u7ee7\u7eed\u505a dfs \u68c0\u67e5\n        def dfs(x,y):\n            if x in range(row) and y in range(col) and grid[x][y]==\"1\":\n                grid[x][y] = 0\n                list(map(dfs,(x+1,x-1,x,x),(y,y,y+1,y-1)))\n                \n        for i in range(row):\n            for j in range(col):\n                if grid[i][j]==\"1\":\n                    island +=1 #\u53cc\u5faa\u73af\u904d\u5386 grid, \u5982\u679c\u53d1\u73b0\u4e86\u4e00\u4e2a\u683c\u5b50\u7684 island\uff0c\u8ba1\u6570\u5668 + 1\uff0c\u6d88\u53bb\u8ddf\u5b83\u76f8\u90bb\u7684\n                    dfs(i,j)\n                \n        return island        \n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			31.87035865821815,
			21.322453006645546,
			14,
			6.4,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid: return 0\n        \n        rows = len(grid)\n        cols = len(grid[0])\n\t\t\n\t\t# Our helper will take a location on an island and subsequently \n\t\t# update all values of that island to mark it has already been counted.\n        def helper(row, col, grid):\n\t\t    # Ensure we're in the grid and we're on an unexplored island location ('1') otherwise return (stop the search)\n            if row > rows-1 or row < 0 or col > cols-1 or col < 0 or grid[row][col] != '1':\n                return\n\t\t\t# If we're in a vald location update the value to mark it's been explored and accounted for.\n            grid[row][col] = '#'\n\t\t\t# Continue search in adjacent cells.\n            helper(row+1, col, grid)\n            helper(row-1, col, grid)        \n            helper(row, col+1, grid)\n            helper(row, col-1, grid)\n\t\t\n\t\t# Keep count of the '1' s that we find, which will be the number of islands.\n        cnt = 0    \n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n\t\t\t    # If we find a location on an island we'll start our DFS and count the island.\n                if grid[row][col] == '1':\n                    helper(row, col, grid)\n                    cnt += 1\n                    \n        return cnt\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			31.98686614969869,
			21.305533766479794,
			15,
			4.5,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid: return 0\n        \n        directions = ((1, 0), (-1, 0), (0, 1), (0, -1))\n        rows = len(grid)\n        cols = len(grid[0])\n        \n        cnt = 0\n        \n        for row in range(rows):\n            for col in range(cols):\n\t\t\t    # If we find a location on an island start our BFS of that island.\n                if grid[row][col] == '1':\n\t\t\t\t    # Update our count and add the starting location to the deque.\n                    cnt += 1\n                    q = collections.deque([])\n                    q.append((row, col))\n\t\t\t\t\t# While we have valid island locations to process:\n                    while q:\n\t\t\t\t\t    # Take the next location from the deque.\n                        location = q.popleft()\n                        r, c = location[0], location[1]\n\t\t\t\t\t\t# Search the possible adjacent directions.\n                        for neigh in directions:\n\t\t\t\t\t\t    # New row and col coords to check\n                            nr = r + neigh[0]\n                            nc = c + neigh[-1]\n\t\t\t\t\t\t\t# If the new coords are valid and the lcoation is part of the island.\n                            if nr >= 0 and nr < rows and nc >= 0 and nc < cols and grid[nr][nc] == '1':\n\t\t\t\t\t\t\t    # Update the cell value to mark it's been counted/explored.\n                                grid[nr][nc] = '#'\n\t\t\t\t\t\t\t\t# Append the current location to the deque to further search it's adjacents.\n                                q.append((nr, nc))\n                                \n        return cnt\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			15.474363903312343,
			22.243624462341565,
			12,
			5.6,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n        \n        rows,cols=len(grid),len(grid[0])\n        \n        # Initialize the UnionFind data-structure with the current grid. \n        # This step will initialize the parent and rank arrays of the UnionFind data-structure and set number of islands equal to the number of 1s encountered in the grid. \n        # It'll also set the parent of every cell to be it \n        uf = UnionFind(grid)\n        \n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j]=='1':\n                    for d in [(1,0),(0,1),(-1,0),(0,-1)]:\n                        ii,jj=i+d[0],j+d[1]\n                        if 0<=ii<rows and 0<=jj<cols and grid[ii][jj]=='1':\n                            x,y=i*cols+j,ii*cols+jj\n                            uf.union(x,y)\n                            \n        return uf.numofislands\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			30.72079455539722,
			21.2979079254125,
			15,
			4.725,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        ## RC ##\n        ## APPROACH : DFS ##\n        # 1. find the land, go to surroundings and convert to water\n        # 2. increment island count, get back and search for next islands.\n        \n\t\t## TIME COMPLEXITY : O(N^2) ##\n\t\t## SPACE COMPLEXITY : O(1) ##\n\n        def convertLandToWater(grid,i,j):\n            if(i<0 or j<0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1'):\n                return\n            grid[i][j] = '0'\n            for x,y in directions:\n                convertLandToWater(grid, i + x, j + y)\n        \n        if len(grid) == 0 : return 0\n        isLandCount = 0\n        directions = [(0,1), (0,-1), (-1,0), (1,0)]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1':\n                    isLandCount += 1\n                    convertLandToWater(grid, i, j)\n        return isLandCount        \n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			34.139978556698196,
			21.273980661482472,
			17,
			7.0,
			"def numIslands(g:List[List[int]]):\n    def bfs(grid, i, j):\n        q = Queue()\n        q.put([i, j])\n        grid[i][j] = \"#\"\n        \n        while(q.qsize() > 0):\n            i, j  = q.get()\n            \n            if i - 1 >= 0 and grid[i - 1][j] == \"1\":\n                q.put([i - 1, j])\n                grid[i - 1][j] = \"#\"\n            \n            if j - 1 >= 0 and grid[i][j - 1] == \"1\":\n                q.put([i, j - 1])\n                grid[i][j - 1] = \"#\"\n                \n            if i + 1 < len(grid) and grid[i + 1][j] == \"1\":\n                q.put([i + 1, j])\n                grid[i + 1][j] = \"#\"\n            \n            if j + 1 < len(grid[0]) and grid[i][j + 1] == \"1\":\n                q.put([i, j + 1])\n                grid[i][j + 1] = \"#\"\n\n    def numIslands(grid: List[List[str]]) -> int:            \n        result = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == \"1\":\n                    bfs(grid, i, j)\n                    result += 1\n        \n        \n        return result\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			66.0083213073874,
			21.355168915624592,
			20,
			6.3,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid:\n            return 0;\n        \n        visited = grid.copy() # in case we do not want to modify our input\n        islands = 0\n        stack = [] # this will simulate the call stack \n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if visited[i][j] != 'X' and grid[i][j] == '1':\n                    islands += 1\n                    stack.append((i, j))\n\t\t\t\t\t# perform dfs iteratively\n                    while stack:\n                        row, col = stack.pop()\n                        \n                        if grid[row][col] == '1' and visited[row][col] != 'X':\n                            visited[row][col] = 'X'\n                            \n                        if  row + 1 < len(grid) and grid[row + 1][col] == '1':\n                            stack.append((row + 1, col))\n                        if  col + 1 < len(grid[0]) and grid[row][col + 1] == '1':\n                            stack.append((row, col + 1))\n                        if row - 1 >= 0 and grid[row - 1][col] == '1':\n                            stack.append((row - 1, col))\n                        if col - 1 >= 0 and grid[row][col - 1] == '1':\n                            stack.append((row, col - 1))\n        return islands\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			29.709005959364816,
			21.30668458739371,
			17,
			5.333333333333333,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        rows_count = len(grid)\n        cols_count = len(grid[0]) if grid else 0\n        num_islands = 0\n        stack = []\n        for i in range(rows_count):\n            for j in range(cols_count):\n                if grid[i][j] == '1':\n                    num_islands += 1\n                    stack.append((i, j))\n                    while stack:\n                        ci, cj = stack.pop()\n                        grid[ci][cj] = '0'\n\n                        if ci > 0 and grid[ci - 1][cj] == '1':\n                            stack.append((ci - 1, cj))\n\n                        if ci < rows_count - 1 and grid[ci + 1][cj] == '1':\n                            stack.append((ci + 1, cj))\n\n                        if cj > 0 and grid[ci][cj - 1] == '1':\n                            stack.append((ci, cj - 1))\n\n                        if cj < cols_count - 1 and grid[ci][cj + 1] == '1':\n                            stack.append((ci, cj + 1))\n\n        return num_islands\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			60.922563253193005,
			21.311693110639784,
			18,
			6.548387096774194,
			"def numIslands(g:List[List[int]]):\n    def numIslands(treasureMap: List[List[str]]) -> int:\n        # O(m * n) time and O(m * n) space to store the recursive stackframe calls\n        m = len(treasureMap)\n        if m == 0: return 0  # dead men tell no tales\n        n = len(treasureMap[0])\n        if n == 0: return 0  # dead men tell no tales\n        num_islands = 0\n\n        sail_down:  Traverser = lambda row, col: findTreasure(row + 1, col, treasureMap)\n        sail_up:    Traverser = lambda row, col: findTreasure(row - 1, col, treasureMap)\n        sail_right: Traverser = lambda row, col: findTreasure(row, col + 1, treasureMap)\n        sail_left:  Traverser = lambda row, col: findTreasure(row, col - 1, treasureMap)\n\n        land_down:  CrowsNestNavigator  = lambda row, col: (row + 1) < m  and treasureMap[row + 1][col] == \"1\"\n        land_up:    CrowsNestNavigator  = lambda row, col: (row - 1) > -1 and treasureMap[row - 1][col] == \"1\"\n        land_right: CrowsNestNavigator  = lambda row, col: (col + 1) < n  and treasureMap[row][col + 1] == \"1\"\n        land_left:  CrowsNestNavigator  = lambda row, col: (col - 1) > -1 and treasureMap[row][col - 1] == \"1\"\n\n        def findTreasure(row: int, col: int, grid: List[List[str]]) -> None:\n            nonlocal m, n\n            grid[row][col] = \"x\"\n            # for each landpiece, attempt to go left, right, up or down if there is land\n            if land_down(row, col):  sail_down(row, col)\n            if land_up(row, col):    sail_up(row, col)\n            if land_right(row, col): sail_right(row, col)\n            if land_left(row, col):  sail_left(row, col)\n\n        for col in range(n):\n            for row in range(m):\n                if treasureMap[row][col] == \"1\":\n                    findTreasure(row, col, treasureMap)\n                    num_islands += 1\n\n        return num_islands\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			60.44267703210121,
			22.934377639597916,
			10,
			2.5,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if grid != None and len(grid) != 0:\n            dictionary = {}\n            islands = 0\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    tup = (i,j)\n                    if grid[i][j] == \"1\" and tup not in dictionary:\n                        islands += 1\n                        bfs(grid, dictionary, tup)\n            return islands \n        else:\n            return 0\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			54.41570404273343,
			23.56624851069789,
			41,
			5.90625,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        n = len(grid)\n        if n <1:\n            return 0\n        \n        m = len(grid[0])\n        if n == 1:\n            if m < 1:\n                return 0\n            if m == 1:\n                if grid[0][0] == '1':\n                    return 1\n                return 0\n\n        vis = [[(j,i) for i in range(m)] for j in range(n)]\n        rank = [[0 for i in range(m)] for j in range(n)]\n        vis = vis\n        for i in range(n):\n            for j in range(m):\n                par = 0\n                if grid[i][j] == '1':\n                    if i > 0 and not par:\n                        if grid[i-1][j] == '1':\n                            union(i,j,i-1,j)\n                    if i < n-1 and not par:\n                        if grid[i+1][j] == '1':\n                            union(i,j,i+1,j)\n                    if j > 0 and not par:\n                        if grid[i][j-1] == '1':\n                            union(i,j,i,j-1)\n                    if j < m-1 and not par:\n                        if grid[i][j+1] == '1':\n                            union(i,j,i,j+1)\n        \n        freq = [[0 for i in range(m)] for j in range(n)]\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '1':\n                    setx, sety = parent(i,j,vis)\n                    if not freq[setx][sety]:\n                        res+=1\n                    freq[setx][sety]+=1\n        return res\n\n    def parent(i,j,pvec):\n        if pvec[i][j]==(i,j):\n            return i,j\n        pvec[i][j] = parent(pvec[i][j][0],pvec[i][j][1],pvec)\n        return pvec[i][j]\n\n    def union(i1,j1,i2,j2):\n        pvec = vis\n        rank = rank\n        ii1,jj1 = parent(i1,j1,pvec)\n        ii2,jj2 = parent(i2,j2,pvec)\n        if ii1 == ii2 and jj1 == jj2:\n            return\n        if rank[ii1][jj1] < rank[ii2][jj2]:\n            pvec[ii1][jj1] = (ii2,jj2)\n        elif rank[ii1][jj1] > rank[ii2][jj2]:\n            pvec[ii2][jj2] = (ii1,jj1)\n        else:\n            pvec[ii1][jj1] = (ii2,jj2)\n            rank[ii2][jj2]+=1\n        return\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			44.29792478305134,
			21.31009568900718,
			14,
			5.444444444444445,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not len(grid):\n            return 0\n        \n        def dfs(grid,row,col):\n            if row < 0 or row >= len(grid) or col < 0 or col >= len(grid[0]) or grid[row][col] == \"0\":\n                return\n            grid[row][col] = \"0\"\n            dfs(grid,row+1,col)\n            dfs(grid,row-1,col)\n            dfs(grid,row,col+1)\n            dfs(grid,row,col-1)\n            \n        count = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == \"1\":\n                    count += 1\n                    dfs(grid,row,col)\n        return count\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			193.3234192548889,
			21.37408503674601,
			15,
			6.533333333333333,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n        \n        djs = [] # list of disjoint sets\n        lbl = 0  # the label\n        \n        # One pass and (not very classic) union-find:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n            \n            # Set background to int 0.\n                if grid[i][j] == '0':\n                    grid[i][j] = 0\n                    continue\n                \n            # Get neighboring labels.\n                up = grid[i-1][j] if i > 0 else 0\n                left = grid[i][j-1] if j > 0 else 0\n                    \n                # If both neighbors are 0,\n                #   assign a new label to the current pixel.\n                # And create a new set with only one element.\n                if up == 0 and left == 0:\n                    lbl += 1\n                    grid[i][j] = lbl\n                    djs.append({lbl})\n                        \n                # If only one neighbor is 0 or both neighbors are \n\t\t\t\t#   labeled the same, assign that label to the current pixel.\n                elif up == left or up == 0 or left == 0:\n                    grid[i][j] = max(up,left)\n                        \n                # If neighbors are labeled differently,\n                #   the labels should belong the same set.\n                # Union those two sets and assign any of those labels.\n                else:\n                    uf = union(djs,up,left)\n                    grid[i][j] = up\n                        \n        # The number of sets left in the list djs is the number of islands.    \n        return len(djs)\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			64.39278673041773,
			21.323181775835163,
			13,
			3.85,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        def dfs(i, j):\n            grid[i][j] = '2'\n            for di, dj in (0, 1), (0, -1), (1, 0), (-1, 0):\n                ii, jj = i+di, j+dj\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] == '1':\n                    dfs(ii, jj)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    ans += 1\n        return ans\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			62.56520609881879,
			21.34081507299465,
			13,
			4.052631578947368,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        ans = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    q = [(i, j)]\n                    while q:\n                        x, y = q.pop()\n                        grid[x][y] = '2'\n                        for dx, dy in (0, 1), (0, -1), (1, 0), (-1, 0):\n                            xx, yy = x+dx, y+dy\n                            if 0 <= xx < m and 0 <= yy < n and grid[xx][yy] == '1':\n                                q.append((xx, yy))\n                    ans += 1            \n        return ans\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			62.63146950959198,
			23.550961567126595,
			15,
			4.5,
			"def numIslands(g:List[List[int]]):\n    def numIslands(grid: List[List[str]]) -> int:\n        if not grid:\n            return 0\n        m, n = len(grid), len(grid[0])\n        d = dict()\n        idx = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    d[i, j] = idx\n                    idx += 1\n        uf = UF(idx)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    if i > 0 and grid[i-1][j] == '1':\n                        uf.union(d[i-1, j], d[i, j])\n                    if j > 0 and grid[i][j-1] == '1':\n                        uf.union(d[i, j-1], d[i, j])\n        return uf.size\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		],
		[
			30.701884444386696,
			21.318891145097602,
			14,
			5.523809523809524,
			"def numIslands(g:List[List[int]]):\n    def numIslands(m: List[List[str]]) -> int:\n        def find(m,i,j,r,c):\n            if i<0 or j<0:\n                return 0\n            if i>r-1 or j>c-1 or m[i][j]!=\"1\":\n                return 0\n            m[i][j]=\"2\"\n            \n            for di,dj in [(0,-1),(0,1),(1,0),(-1,0)]:\n                find(m,i+di,j+dj,r,c)\n        \n        \n        r=len(m)\n        t_i=0\n        for i in range (r):\n            c=len(m[i])\n            for j in range(c):\n                if m[i][j]=='1':\n                    find(m,i,j,r,c)\n                    t_i+=1\n        return t_i\n\n\n    n = len(g)\n    grid = [[str(g[i][j]) for j in range(n)] for i in range(n)]\n    return numIslands(grid)\n"
		]
	],
	"CYCLE_GRAPH": [
		"n^2",
		[
			26.653222106700678,
			20.66663905764424,
			16,
			3.857142857142857,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        in_degrees = [0 for x in range(numCourses)]\n        start_nodes = []\n        adj_matrix = defaultdict(list)\n        for edge in prerequisites:\n            if edge[0] == edge[1]:\n                return False\n            in_degrees[edge[1]] += 1\n            adj_matrix[edge[0]].append(edge[1])\n        \n        for course_id, in_degree in enumerate(in_degrees):\n            if in_degree == 0:\n                start_nodes.append(course_id)\n        \n        if len(start_nodes) == 0:\n            return False\n        \n        # bfs \n        visited = set() \n        for start_node in start_nodes:\n            queue = [start_node]\n            while queue:\n                current = queue.pop()\n                visited.add(current)\n                for child in adj_matrix[current]:\n                    if child in visited:\n                        continue\n                    in_degrees[child] -= 1\n                    if in_degrees[child] < 1:\n                        queue.append(child)\n        return len(visited) == numCourses     \n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			27.090220946829895,
			20.906164928544825,
			15,
			1.7142857142857142,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(n: int, prerequisites: List[List[int]]) -> bool:\n        adj_list = [[] for _ in range(n)]\n        for pos, nb in prerequisites:\n            adj_list[pos].append(nb)\n\n        visited = [False] * n\n        rec_stack = [False] * n\n\n        for node in range(n):\n            if not visited[node]:\n                if is_cyclic(node, visited, rec_stack, adj_list):\n                    return False\n        return True\n\n    def is_cyclic(node, visited, rec_stack, adj_list):\n        visited[node] = True\n        rec_stack[node] = True\n\n        for nb in adj_list[node]:\n            if not visited[nb]:\n                if is_cyclic(nb, visited, rec_stack, adj_list):\n                    return True\n            elif rec_stack[nb]:\n                return True\n        rec_stack[node] = False\n        return False\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			27.071979269986418,
			21.074314934650584,
			18,
			3.3333333333333335,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        prerequisites = [[] for i in range(numCourses)]\n        finish = [0 for i in range(numCourses)]\n        for course, base in prerequisites:\n            prerequisites[course].append(base)\n        len_prerequisite = [len(prerequisite) for prerequisite in prerequisites]\n        if min(len_prerequisite) > 0:\n            return False\n        for i in range(numCourses):\n            if not helper(i):\n                return False\n        return True\n\n    def helper(course):\n        if finish[course] == 1:  # visiting\n            return False\n        if finish[course] == -1:  # already finished course\n            return True\n        # when finish[course] == 0, for unvisited course\n        finish[course] = 1  # mark as visiting\n        if prerequisites[course]:  # when prerequisites for this course is not None\n            for base in prerequisites[course]:\n                if not helper(base):\n                    return False\n        finish[course] = -1  # mark as finished course\n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			47.527207009149045,
			21.28237938900852,
			17,
			1.0,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        mat = {}\n        for i in range(numCourses):\n            mat[i] = {}\n        \n        visited = [False for i in range(numCourses)]\n        repeated = [False for i in range(numCourses)]\n        stack = []\n        \n        for u, v in prerequisites:\n            mat[v][u] = 1\n        \n        def topologicalSort(node):\n            visited[node] = True\n            repeated[node] = True\n\n            for child in mat[node]:\n                if not visited[child]:\n                    if topologicalSort(child):\n                        return True\n                elif repeated[child]:\n                    return True\n                    \n            stack.append(node)\n            repeated[node] = False\n            return False\n\n        cycle = False\n        for node in range(numCourses):\n            if not visited[node]:\n                if topologicalSort(node):\n                    cycle = True\n                    break\n\n        return not cycle\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			57.181614551629394,
			21.63264213350162,
			12,
			3.25,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        child = defaultdict(set)\n        parent = defaultdict(int)\n        for p in prerequisites:\n            child[p[1]].add(p[0])\n            parent[p[0]]+=1\n        \n        q = deque()\n        for i in range(numCourses):\n            if parent[i] == 0:\n                del parent[i]\n                q.append(i)\n        if not q:\n            return False\n        res = []\n        while q:\n            couses = q.popleft()\n            res.append(couses)\n            for c in child[couses]:\n                parent[c] -= 1\n                if parent[c] == 0:\n                    del parent[c]\n                    q.append(c)\n                    \n        return len(res) == numCourses\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			74.12776732315356,
			21.28762824797298,
			15,
			1.7142857142857142,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n\t    # extract a set of vertices from the edge list\n        vertices = set([v for sublist in prerequisites for v in sublist]) \n\t\t# transform the set of vertices and edge list into an adjacency list\n        graph = { v: [e[1] for e in prerequisites if e[0] == v] for v in vertices}\n        \n\t\t# traverse the graph starting at each vertex\n        for v in vertices:\n            bfs = deque(graph[v]) # add all the neighbours of starting node to the BFS queue\n            visited = set() # use a set to keep track of the visited nodes and not get stuck in a cycle\n            \n            while bfs:\n                current = bfs.pop()\n                visited.add(current)\n                if current == v: # we ended up at the same vertex where we started - there's a cycle\n                    return False\n                for n in graph[current]: # cycle not detected, continue the traversal to the next nodes\n                    if n not in visited:\n                        bfs.appendleft(n)            \n        \n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			58.28450942145035,
			20.920720760312477,
			12,
			3.5,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        pre = defaultdict(list)\n        count = {}\n        \n        for i in prerequisites:\n            pre[i[1]].append(i[0])\n            count[i[0]]=count.get(i[0],0) + 1\n            \n        queue = []\n        for i in range(numCourses):\n            if i not in count:\n                queue.append(i)\n        solution_count = 0       \n        while len(queue):\n            solution_count +=1\n            x = queue.pop(0)\n            for n in pre[x]:\n                count[n] -= 1\n                if count[n] == 0:\n                    del count[n]\n                    queue.append(n)\n        \n        if solution_count == numCourses:\n            return True\n        return False\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			29.26417587509372,
			20.898613518581094,
			15,
			2.5,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def buildAdjacencyList(n, edgesList):\n        adjList = [[] for _ in range(n)]\n        # c2 (course 2) is a prerequisite of c1 (course 1)\n        # i.e c2c1 is a directed edge in the graph\n        for c1, c2 in edgesList:\n            adjList[c2].append(c1)\n        return adjList\n\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # build Adjacency list from Edges list\n        adjList = buildAdjacencyList(numCourses, prerequisites)\n\n        # Each vertex can have 3 different states:\n        # state 0   : vertex is not visited. It's a default state.\n        # state -1  : vertex is being processed. Either all of its descendants\n        #             are not processed or it's still in the function call stack.\n        # state 1   : vertex and all its descendants are processed.\n        state = [0] * numCourses\n\n        def hasCycle(v):\n            if state[v] == 1:\n                # This vertex is processed so we pass.\n                return False\n            if state[v] == -1:\n                # This vertex is being processed and it means we have a cycle.\n                return True\n\n            # Set state to -1\n            state[v] = -1\n\n            for i in adjList[v]:\n                if hasCycle(i):\n                    return True\n\n            state[v] = 1\n            return False\n\n        # we traverse each vertex using DFS, if we find a cycle, stop and return\n        for v in range(numCourses):\n            if hasCycle(v):\n                return False\n\n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			53.58444335294312,
			20.228026566249884,
			15,
			1.2,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def buildAdjacencyList(n, edgesList):\n        adjList = [[] for _ in range(n)]\n        # c2 (course 2) is a prerequisite of c1 (course 1)\n        # i.e c2c1 is a directed edge in the graph\n        for c1, c2 in edgesList:\n            adjList[c2].append(c1)\n        return adjList\n\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        # build Adjacency list from Edges list\n        adjList = buildAdjacencyList(numCourses, prerequisites)\n        visited = set()\n\n        def hasCycle(v, stack):\n            if v in visited:\n                if v in stack:\n                    # This vertex is being processed and it means we have a cycle.\n                    return True\n                # This vertex is processed so we pass\n                return False\n\n            # mark this vertex as visited\n            visited.add(v)\n            # add it to the current stack\n            stack.append(v)\n\n            for i in adjList[v]:\n                if hasCycle(i, stack):\n                    return True\n\n            # once processed, we pop it out of the stack\n            stack.pop()\n            return False\n\n        # we traverse each vertex using DFS, if we find a cycle, stop and return\n        for v in range(numCourses):\n            if hasCycle(v, []):\n                return False\n\n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			26.577041961952407,
			20.450900086562065,
			17,
			3.6363636363636362,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def buildAdjacencyList(n, edgesList):\n        adjList = [[] for _ in range(n)]\n        # c2 (course 2) is a prerequisite of c1 (course 1)\n        # i.e c2c1 is a directed edge in the graph\n        for c1, c2 in edgesList:\n            adjList[c2].append(c1)\n        return adjList\n\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        return True if topoBFS(numCourses, prerequisites) else False\n\n    def topoBFS(numNodes, edgesList):\n        # Note: for consistency with other solutions above, we keep building\n        # an adjacency list here. We can also merge this step with the next step.\n        adjList = buildAdjacencyList(numNodes, edgesList)\n\n        # 1. A list stores No. of incoming edges of each vertex\n        inDegrees = [0] * numNodes\n        for v1, v2 in edgesList:\n            # v2v1 form a directed edge\n            inDegrees[v1] += 1\n\n        # 2. a queue of all vertices with no incoming edge\n        # at least one such node must exist in a non-empty acyclic graph\n        # vertices in this queue have the same order as the eventual topological\n        # sort\n        queue = []\n        for v in range(numNodes):\n            if inDegrees[v] == 0:\n                queue.append(v)\n\n        # initialize count of visited vertices\n        count = 0\n        # an empty list that will contain the final topological order\n        topoOrder = []\n\n        while queue:\n            # a. pop a vertex from front of queue\n            # depending on the order that vertices are removed from queue,\n            # a different solution is created\n            v = queue.pop(0)\n            # b. append it to topoOrder\n            topoOrder.append(v)\n\n            # increase count by 1\n            count += 1\n\n            # for each descendant of current vertex, reduce its in-degree by 1\n            for des in adjList[v]:\n                inDegrees[des] -= 1\n                # if in-degree becomes 0, add it to queue\n                if inDegrees[des] == 0:\n                    queue.append(des)\n\n        if count != numNodes:\n            return None  # graph has at least one cycle\n        else:\n            return topoOrder\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			26.175099830329273,
			21.117927861008564,
			15,
			1.5,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses, prereqs):            \n        # Create edge list\n        edge_list = [deque() for _ in range(numCourses)]\n        for [neighbour, node] in prereqs:\n            edge_list[node].append(neighbour)\n        \n        # Define recursive DFS function\n        def DFS(source, path):\n            if source in path:\n                return(True)\n            elif not visited[source]:\n                visited[source] = True\n                neighbours = edge_list[source]\n                for n in neighbours:\n                    node_path = path.union([source])\n                    if DFS(n, node_path):\n                        return(True)\n        # Call DFS for each node\n        visited = [False for _ in range(numCourses)]  # use as a memo table, thanks to\n                                                      # nonlocal scoping in nested functions (here DFS)\n        cycle_found = False\n        for node in range(numCourses):\n            if DFS(node, set()):\n                cycle_found = True\n                break\n        return(not cycle_found)\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			58.908225808360086,
			20.91805411895487,
			14,
			1.6875,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        white = defaultdict(list)\n        for x,y in prerequisites:\n            white[x].append(y)\n        \n        return not iscycle(white)\n\n    def dfs(node, black, grey, white):\n        if node in black:\n            return True\n        if node in grey:\n            return False\n        grey.add(node)\n        for neighbor in white[node]:\n            if not dfs(neighbor, black, grey, white):\n                return False\n        black.add(node)\n        grey.remove(node)\n        return True\n\n    def iscycle(white):\n        black, grey = set(), set()\n        for node in range(len(white)):\n            if not dfs(node, black, grey, white):\n                return True\n        return False\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			27.343605139496148,
			20.727457535237907,
			15,
			3.230769230769231,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        if not numCourses or not prerequisites: return True\n        # build the graph\n        graph = {}\n        for pair in prerequisites:\n            _from, _to = pair\n            graph.setdefault(_from, []).append(_to)\n        # we need to find a topological sort if we detect a cycle we are done\n        visiting, visited = set(), set()\n        def dfs(node):\n            # cycle detected\n            if node in visiting: return False\n            visiting.add(node)\n            # explore children\n            res = True\n            for child in graph.get(node, []):\n                if child not in visited:\n                    res &= dfs(child)\n                    if not res: return False\n            # done with this node and its children\n            visiting.discard(node)\n            visited.add(node)\n            return res\n        # explore all nodes\n        for i in range(numCourses):\n            if not dfs(i): return False\n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			29.44134939959249,
			20.94942713854307,
			15,
			2.5,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = [[] for _ in range(numCourses)]\n        visited = [0 for _ in range(numCourses)]\n        for x,y in prerequisites:\n            graph[x].append(y)\n        for i in range(numCourses):\n            if not dfs(graph, visited, i):\n                return False\n        return True\n\n    def dfs(graph, visited, i):\n        if visited[i] == -1:\n            return False\n        if visited[i] == 1:\n            return True\n        visited[i] = -1\n        \n        for j in graph[i]:\n            if not dfs(graph, visited, j):\n                return False\n        visited[i] = 1\n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			31.2011533166594,
			20.894280016232788,
			16,
			3.2142857142857144,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def calculateIndegree(edgelist):\n        indegree = [0]*len(edgelist)\n        vertex2id = dict((i,j) for j,i in enumerate(edgelist))\n        zero_indegree = set(list(edgelist))\n        for prereq in edgelist:\n            for pre in edgelist[prereq]:\n                indegree[vertex2id[pre]]+=1\n                zero_indegree.discard(pre)\n        return indegree,vertex2id,zero_indegree\n\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        if len(prerequisites)==0:\n            return True\n        prerequisite = makeEdgeList(prerequisites)\n        indegree,vertex2id,zero_indegree = calculateIndegree(prerequisite)\n        count = 0\n        Q = list(zero_indegree)\n        while Q:\n            course = Q.pop(0)\n            count+=1\n            prereq = prerequisite[course]\n            for p in prereq:\n                indegree[vertex2id[p]]-=1\n                if indegree[vertex2id[p]]==0:\n                    Q.append(p)\n                    \n        if count ==len(prerequisite):\n            return True\n        else:\n            return False\n\n    def makeEdgeList(prerequisites):\n        prereq = {}\n        for prereuisite in prerequisites:\n            prereq[prereuisite[1]] = prereq.get(prereuisite[1],[])+[prereuisite[0]]\n            prereq[prereuisite[0]] = prereq.get(prereuisite[0],[])\n        return prereq\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			29.708131567586555,
			21.747494325427883,
			13,
			1.5,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(n, E):\n        arrow   = defaultdict(list)\n        prereqs = defaultdict(set)\n        for x,y in E:\n            arrow  [y].append(x)  # courses must be taken as y -> x\n            prereqs[x].add   (y)  # x, after y\n        #\n        # Waiting: courses with prerequisites (the rest are ok)\n        waiting = {e[0] for e in E}\n        # Front: Foundational courses that we can use to get started\n        #        \"Courses that are foundational to others without having prerequisites themselves\"\n        front    = {e[1] for e in E} - waiting \n        #\n        while front:\n            new = []\n            for y in front:\n                # Visit all \"courses=x\" that depend on \"front=y\"\n                for x in arrow[y]:\n                    #     Arrow-Order: y -> [x1,x2,x3]\n                    # Remove \"y\" as prerequisite of \"xi\" (it's free to take now)\n                    prereqs[x].remove(y) \n                    # if x is now free of prerequisites, then declare it a foundational course\n                    if not prereqs[x]:   \n                        # append to new generation of foundational courses\n                        new.append(x)\n                        # Remove problematic course \"x\"\n                        waiting.remove(x)\n            front = new\n        if waiting:\n            return False\n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			46.84147297466019,
			20.843601318466437,
			13,
			4.25,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        T = []\n        visited = [False]*numCourses\n        queue = collections.deque()\n        indegree = [0]*numCourses\n        graph = collections.defaultdict(list)\n        for i,j in prerequisites:\n            indegree[i] += 1\n            graph[j].append(i)\n        n = len(graph)\n        for i in range(numCourses):\n            if indegree[i] == 0:\n                queue.appendleft(i)\n                visited[i] = True\n        while queue:\n            v = queue.popleft()\n            T.append(v)\n            for i in graph[v]:\n                if not visited[i]:\n                    indegree[i] -= 1\n                    if indegree[i] == 0:\n                        queue.appendleft(i)\n                        visited[i] = True\n        return True if len(T) == numCourses else False\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			60.369152528574894,
			20.419564758686704,
			21,
			4.0,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        ## RC ##\n        ## APPROACH : DFS ##\n        ## LOGIC: DETECT CYCLE IN DIRECTED GRAPH. ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        # DFS function will return False when a cycle is detected else returns True. (at one particular node)\n        def hasCycle(node):\n            \n            if(node in exploring):                     # Cycle detected. If you are still exploring and found the same element again in exploring.\n                return True\n            \n            if(node in explored):                       \n                return False\n\n            exploring.add(node)                         # mark this node as visited.\n                                                         \n            for nei in graph[node]:                     # visit all neigbhors of this node.\n                if( hasCycle(nei) ):\n                    return True                         # if one of its child has cycle return from function call\n            \n            explored.add(node)\n            exploring.remove(node)\n            \n            return False\n        \n        graph = collections.defaultdict(list)\n        for u,v in prerequisites:\n            graph[u].append(v)\n        explored = set()                                 # To keep track of explored nodes in the graph\n        exploring = set()                                # still in exploring, not yet finished.\n        \n        for node in list(graph):                         # watch out => list(graph)\n            if(node not in explored):\n                if(hasCycle(node)):         \n                    return False\n        return True\n        \n        ## APPROACH : BFS ##\n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n        graph = collections.defaultdict(list)\n        in_degree = collections.defaultdict(int)\n        for u,v in prerequisites:\n            graph[u].append(v)\n            in_degree[v] += 1\n\n        # init queue with indegree 0 nodes\n        queue = collections.deque([ u for u in range(0, numCourses) if u not in in_degree])\n\n        count = 0\n        while(queue):\n            size = len(queue)\n            for _ in range(size):\n                node = queue.popleft()\n                count += 1\n                for nei in graph[node]:\n                    in_degree[nei] -= 1\n\n                    if in_degree[nei] == 0:\n                        queue.append( nei )\n        return count == numCourses      # check if all courses are completed\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		],
		[
			55.62702286762777,
			21.009349373545106,
			14,
			1.0,
			"def canFinish(ip:List[List[int]]={\"start\":0,\"end\":1}):\n    def canFinish(numCourses: int, prerequisites: List[List[int]]) -> bool:\n        \n\t\t# Constant defined for course state\n        NOT_CHECKED, CHECKING, COMPLETED = 0, 1, 2\n        \n        # -------------------------------\n        \n        def has_deadlock( course )->bool:\n            \n            if course_state[course] == CHECKING:\n                # There is a cycle(i.e., deadlock ) in prerequisites\n                return True\n            \n            elif course_state[course] == COMPLETED:\n                # current course has been checked and marked as completed\n                return False\n            \n            \n            \n            # update current course as checking\n            course_state[course] = CHECKING\n            \n            # check pre_course in DFS and detect whether there is deadlock\n            for pre_course in requirement[course]:\n                \n                if has_deadlock( pre_course ):\n                    # deadlock is found, impossible to finish all courses\n                    return True\n                \n                                \n            # update current course as completed\n            course_state[course] = COMPLETED\n            \n            return False\n        \n        # -------------------------------\n        \n        # each course maintain a list of its own prerequisites\n        requirement = collections.defaultdict( list )\n        \n        for course, pre_course in prerequisites:\n            requirement[course].append( pre_course )\n        \n        \n        # each course maintain a state among {NOT_CHECKED, CHECKING, COMPLETED}\n\t\t# Initial state is NOT_CHECKED \n        course_state = [ NOT_CHECKED for _ in range(numCourses) ]\n           \n        # Launch cycle (i.e., deadlock ) detection in DFS\n        for course_idx in range(0, numCourses):\n            \n            if has_deadlock(course_idx):\n                # deadlock is found, impossible to finish all courses\n                return False\n        \n        # we can finish all course with required order \n        return True\n\n\n    numCourses = len(ip)\n    prerequisites = []\n    for i in range(len(ip)):\n        for j in range(len(ip)):\n            if(ip[i][j]!=0):\n                prerequisites.append([i,j])\n    return canFinish(numCourses,prerequisites)\n"
		]
	],
	"CYCLE_LL": [
		"n",
		[
			8.44088477731785,
			6.257062438817115,
			14,
			3.28125,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode)->bool:\n        if head == None or head.next == None:\n            return False\n        p = head\n        q = head.next\n        while q and q.next:\n            if p == q:\n                break\n            p = p.next\n            q = q.next.next\n        if p != q:\n            return False\n        return True\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.443703425740816,
			6.445455685618885,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        \"\"\"\n        O(n) time O(1) space\n        slow = head\n        fast = head\n        while(fast != None and fast.next != None):\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                return True\n            \n        return False\n        \"\"\"\n        \n        # O(n) time and O(n) space\n        dictionary = collections.defaultdict(ListNode)\n        while(head):\n            if head in dictionary:\n                return True\n            dictionary[head] = True\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.89367244298567,
			6.558015575296914,
			11,
			2.1666666666666665,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        node_set = set()\n        while head and head.next:\n            slow, fast = head.next, head.next.next\n            if (head, slow, fast) in node_set:\n                return True\n            else:\n                node_set.add((head, slow, fast))\n                head = slow\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.493554610291115,
			6.257058201048371,
			11,
			2.1818181818181817,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head:ListNode)->bool:\n        if not head:\n            return False \n        while head.next:\n            if head.val is None:\n                return True \n            head.val = None \n            head = head.next \n\n        return False \n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.538041504084672,
			6.2569983720619575,
			10,
			1.1,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        while head:\n            if head.val == 'LeetCode':\n                return True\n            head.val = 'LeetCode'\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.564355138981822,
			6.256924835895873,
			11,
			1.7727272727272727,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head:ListNode)->bool:\n        fast = head\n        slow = head\n        \n        while(fast and fast.next):\n            if fast.next == slow: return True \n            fast = fast.next.next                \n            slow = slow.next\n        \n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.576731399829754,
			6.256966163662299,
			11,
			1.7727272727272727,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        ## RC ##\n        ## APPROACH : 2 POINTER ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(1) ##\n        \n        slow = fast = head\n        while(fast and fast.next):\n            slow = slow.next\n            fast = fast.next.next\n            if(slow == fast):\n                return True\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.38789389028463,
			6.257058562118453,
			10,
			1.6666666666666667,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        while head:\n            if not head.val:\n                return True\n            head.val = None\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.71891619624399,
			6.495195086693834,
			10,
			2.1666666666666665,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(H: ListNode) -> bool:\n        S = set([id(H)])\n        while H != None:\n            if id(H.next) in S: return True\n            H, _ = H.next, S.add(id(H.next))\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.748865020754085,
			6.256988311793056,
			11,
			2.2666666666666666,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        slow=head\n        fast=head\n        \n        while fast!=None and fast.next!=None:\n            \n            slow=slow.next\n            fast=fast.next.next\n            \n            if(slow==fast):\n                return True\n\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.70446879443322,
			6.2569548352947395,
			13,
			2.3333333333333335,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if head==None:\n            return False\n        if head.next==None:\n            return False\n        slow=head\n        fast=head\n        while fast!=None and fast.next!=None:\n            fast=fast.next.next\n            slow=slow.next\n            if slow==fast:\n                return True\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.630980806085413,
			6.256903663596696,
			13,
			2.96875,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if not head or not head.next:\n            return False\n        \n        slow=head\n        fast=head.next\n        \n        while slow!=fast:\n            if not fast or not fast.next:\n                return False\n            slow=slow.next\n            fast=fast.next.next\n        return True \n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.46456940288264,
			6.438153770481316,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        l={}\n        while head:\n            if(head in l):\n                return True\n            else:\n                l[head]=True\n            head=head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.75728774009387,
			7.0529661837188105,
			9,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if head is None:\n            return False\n        return hcHelper(head, {})\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.475578722886146,
			6.420489324877044,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        seen=set()\n        curr=head\n        while curr:\n            if curr in seen:\n                return True\n            seen.add(curr)\n            curr=curr.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.439903462719084,
			6.256908450767948,
			12,
			2.8333333333333335,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if not head or not head.next:\n            return False\n        while head != None:\n            if(head.val == 'a'):\n                return True\n            else:\n                head.val = 'a'\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.409672220952507,
			6.256938966824868,
			11,
			3.076923076923077,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        # corner case\n        if not head: return False\n        \n        i = 0\n        while i <= 10000:\n            head = head.next\n            if head == None:\n                return False\n            i += 1\n        return True\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.502135442087372,
			6.457541256448658,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        dictionary = {}\n        while head:\n            if head in dictionary: \n                return True\n            else: \n                dictionary[head]= True\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.449412904549723,
			6.257020761714944,
			12,
			2.857142857142857,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if not head:\n            return False\n        slow = head\n        fast = head.next\n        while slow != fast:\n            if not fast or not fast.next:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n        return True\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.417554514610433,
			6.257000119099227,
			10,
			1.1,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        clone = head\n        while clone:\n            if clone.val == float('inf'):\n                return True\n            clone.val = float('inf')\n            clone= head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.455282284800075,
			6.25693807925224,
			13,
			2.875,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n\n        if head == None or head.next == None:\n            return False\n        fast = head.next\n        slow = head\n        while fast!= None and fast.next!=None:\n\n            if slow == fast:\n                return True\n            \n            slow = slow.next\n            fast = fast.next.next\n            \n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.43502213120637,
			6.438856273133343,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        l={}\n        while head:\n            if(head in l):\n                return True\n            else:\n                l[head]=True\n            head=head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			9.14589165353195,
			7.092359032738411,
			9,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if head is None:\n            return False\n        return hcHelper(head, {})\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.429237847858653,
			6.405292835145126,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        seen=set()\n        curr=head\n        while curr:\n            if curr in seen:\n                return True\n            seen.add(curr)\n            curr=curr.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.459433862823818,
			6.256947227500837,
			12,
			2.8333333333333335,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if not head or not head.next:\n            return False\n        while head != None:\n            if(head.val == 'a'):\n                return True\n            else:\n                head.val = 'a'\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.382372980422348,
			6.2569149753197655,
			11,
			3.076923076923077,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        # corner case\n        if not head: return False\n        \n        i = 0\n        while i <= 10000:\n            head = head.next\n            if head == None:\n                return False\n            i += 1\n        return True\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.506226158930088,
			6.460673957960213,
			10,
			1.65,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        dictionary = {}\n        while head:\n            if head in dictionary: \n                return True\n            else: \n                dictionary[head]= True\n            head = head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.440105654553548,
			6.257061639331762,
			12,
			2.857142857142857,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        if not head:\n            return False\n        slow = head\n        fast = head.next\n        while slow != fast:\n            if not fast or not fast.next:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n        return True\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.386318391135895,
			6.2569162544063195,
			10,
			1.1,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n        clone = head\n        while clone:\n            if clone.val == float('inf'):\n                return True\n            clone.val = float('inf')\n            clone= head.next\n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		],
		[
			8.461753576930512,
			6.25692899257981,
			13,
			2.875,
			"def hasCycle(l:List[int],p:int):\n    def makeListCycle(l,p):\n        head = None\n        reqp = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n                if(i==p):\n                    reqp = temp\n        if(p==-1):\n            return head\n        if(reqp==None):\n            temp.next = head\n        else:\n            temp.next = reqp\n        return head\n        \n    def hasCycle(head: ListNode) -> bool:\n\n        if head == None or head.next == None:\n            return False\n        fast = head.next\n        slow = head\n        while fast!= None and fast.next!=None:\n\n            if slow == fast:\n                return True\n            \n            slow = slow.next\n            fast = fast.next.next\n            \n        return False\n\n\n    return hasCycle(makeListCycle(l,p))\n"
		]
	],
	"REVERSE_LL": [
		"n",
		[
			8.589939134689772,
			6.284687762420598,
			11,
			2.6923076923076925,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if head is None or head.next is None :\n            return head \n        if head.next is not None:\n            last = None\n            point = head\n\t\t\t\n            while point is not None:\n                point.next, point, last = last, point.next, point\n                \n            return last\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.669742437319627,
			6.285076626406373,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        v_head = head\n        prev = None\n        while v_head:\n            temp = v_head.next\n            v_head.next = prev\n            prev = v_head\n            v_head = temp\n        return prev\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			9.157585019544547,
			7.056180799484639,
			9,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        p = reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.638606579007964,
			6.284536968693746,
			9,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if head:\n            v_head = head        \n            while v_head.next:\n                temp = v_head.next\n                v_head.next = v_head.next.next\n                temp.next = head\n                head = temp\n            return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			9.282580819788285,
			6.721466012019603,
			10,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return head\n        \n        nums = []\n        curr = head\n        while curr:\n            nums.append(curr.val)\n            curr = curr.next\n            \n        nums[:] = nums[::-1]\n        head = ListNode()\n        curr = head\n        for x in nums:\n            curr.next = ListNode(x)\n            curr = curr.next\n            \n        return head.next\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.625150557336692,
			6.284880081683844,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return head\n        \n        curr = head        \n        while curr.next:\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = head\n            head = temp\n            \n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.61131486390278,
			6.284251588623281,
			8,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode, prev=None) -> ListNode:\n            prev , curr = None , head\n            while curr is not None:\n                next = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next\n            \n            head = prev\n            return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.882964046712361,
			7.0586045745276405,
			9,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode, prev=None) -> ListNode:\n            if head is None or head.next is None:\n                return head\n            smallHead = reverseList(head.next)\n            tail = head.next\n            tail.next = head\n            head.next = None\n            return smallHead\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.589182978016407,
			6.28468774805017,
			8,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head:ListNode)->ListNode:\n\n        p1, p2 = None, head\n\n        while p2 is not None:\n            p3 = p2.next\n            p2.next = p1\n            p1 = p2\n            p2 = p3\n        return p1\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.568190478791019,
			6.285085597994434,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return head\n        first = head\n        second = first.next\n        while(second):\n            temp = second.next\n            second.next = first\n            first = second\n            second = temp\n            \n        head.next = None\n        head = first\n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.595460190100114,
			6.284432747812764,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        prev = None\n        cur = head\n        while cur:\n            temp = cur.next\n            cur.next = prev\n            cur, prev = temp, cur\n        return prev\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.650363618594975,
			6.28597757540385,
			10,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        ## RC ##\n        ## APPROACH : ITERATIVE ##\n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(1) ##\n        \n        prev = None             # None\n        curr = head             # curr always holds elements left to be reversed, (initially it is all elements i.e head)\n        while(curr):\n            temp = curr.next    # copy all expect 1st element \n            curr.next = prev    # replace all with previous, makes list reversed.\n            prev = curr         # copy current reversed list into prev. prev( always holds reversed previous linked list)\n            curr = temp\n        return prev\n        \n        ## APPROACH : RECURSIVE ##\n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        def helper(prev, curr):\n            if not curr:\n                return prev\n            temp = curr.next\n            curr.next = prev\n            return helper(curr, temp)\n        return helper(None, head)\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.919148881923022,
			7.038138807583351,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        root = reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return root\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.562087490588262,
			6.2845360570596,
			8,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        prev = None\n        current = head\n        while current is not None:\n            n = current.next\n            current.next = prev\n            prev = current\n            current = n\n        head = prev\n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			9.168379581437538,
			6.721832925133282,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return None\n        node = None\n        while head:\n            n = ListNode(head.val)\n            n.next = node\n            node = n\n            head = head.next\n        return node\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.68997623640829,
			6.284688021088237,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return None\n        pre = None\n\n        while head:\n            next_node = head.next\n            head.next = pre\n            pre = head\n            head = next_node\n        return pre\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.583702130586913,
			6.285082208960507,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n    \n        prev:ListNode = None #created an Empty Node\n        curr = head # The Head Node is now current(curr) node\n        while curr!= None: #Iterate until the Node is None\n            nexttemp: ListNode = curr.next #created a temp Node to remember the next Node\n            curr.next = prev # assigning the next Node of current as Prev (for first iteration it will be None)\n            prev = curr # Now the prev become current\n            curr = nexttemp # current become the node which we stored in the temp Node(nexttemp)\n        return prev\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.562713457840799,
			6.284435634867212,
			10,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        first = head\n        if (not first) or (not first.next): return first\n\n        first.next, curr, prev = None, first.next, first\n        \n        #1. Reverse  (curr.next = prev)\n        #2. Update Current\n        #3. Update previous\n        \n        while curr.next:\n            curr.next, curr, prev = prev, curr.next, curr\n\n        curr.next = prev\n        return curr\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.68901699261729,
			6.285977930255033,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        pre = None\n        curr = head\n        while curr:\n            temp = curr.next #\u53d6\u51fa\u539flist\u91cc\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\uff0c\u9632\u6b62\u5f04\u4e22\n\n            curr.next = pre #\u5c06\u5f53\u524d\u6307\u9488\u7684\u4e0b\u4e00\u4e2a\u6307\u5411\u4e4b\u524d\u7684\u5143\u7d20\uff0c\u5728\u7b2c\u4e00\u6b21\u8fd0\u884c\u65f6\u4e4b\u524d\u7684\u5143\u7d20\u4e3aNone\n            pre = curr #\u8fd9\u4e00\u6b21\u7684\u5f53\u524d\u5143\u7d20\u5c31\u662f\u4e0b\u4e00\u6b21\u7684\u4e4b\u524d\u7684\u5143\u7d20\n        \n            curr = temp #\u628a\u6307\u5411\u5f53\u524d\u5143\u7d20\u7684\u6307\u9488\u6307\u5230\u6700\u5f00\u59cb\u5b58\u5230temp\u91cc\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u4e0a\n        return pre #\u8df3\u51fa\u5faa\u73af\u65f6\uff0ccurr\u662fnone\uff0c\u4e0a\u4e00\u4e2a\u5faa\u73af\u91cc\u7684curr\u5373pre\u624d\u662f\u65b0\u94fe\u8868\u7684\u5934\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.788321536532113,
			6.283378019352956,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        current = head\n        previous = None\n        nextNode = None\n\n        while current:\n            nextNode = current.next\n            current.next = previous\n            \n            previous = current\n            current = nextNode\n\n        return previous\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.72526272152508,
			6.284636678887961,
			11,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        curr_node = head\n        \n        next_node = head.next\n        \n        prev_node = None\n        \n        while True:\n            \n            curr_node.next = prev_node\n            \n            if next_node is None:\n                head = curr_node\n                break\n            \n            prev_node = curr_node\n            \n            curr_node = next_node\n            \n            next_node = next_node.next\n            \n        \n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.682721033669404,
			6.285824257059794,
			10,
			2.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head:ListNode)->ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n\t\t\n\t\t# if sll is empty or ends after one\n        if head is None or head.next is None:\n\t\t    #then return\n            return head\n        \n\t\t#previous node is set to none\n\t\t#current node is set to head\n\t\t#next node is set to current.next\n        p_node, c_node, n_node = None, head, head.next\n        \n\t\t#while next node is not equal to none\n        while n_node is not None:\n\t\t\n\t\t    # current nodes pointer is set to the previous node\n            c_node.next = p_node\n\t\t\t# previous node is set to current node\n            p_node = c_node\n\t\t\t#current node is now set to next node\n            c_node = n_node\n\t\t\t#next node is set to current node .next\n            n_node = c_node.next\n           \n\t\t#finish final iteration by redirecting last pointer\n        c_node.next = p_node\n\t\t#declare new head\n        head = c_node\n\t\t\n\t\t#return head of sll\n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			12.118033027845842,
			6.281574571223,
			9,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head:ListNode)->ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        node_values = []\n        \n        current_node = head\n        \n        while current_node is not None:\n            node_values.insert(0, current_node.val)\n            current_node = current_node.next\n        \n        c_n = head\n        idx = 0\n        \n        while c_n is not None:\n            c_n.val = node_values[idx]\n            c_n = c_n.next\n            idx+=1\n                \n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.575562995936053,
			6.284702962156733,
			8,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        \n        p1, p2 = None, head\n        while p2 is not None:\n            p3 = p2.next\n            p2.next = p1\n            p1 = p2\n            p2 = p3\n            \n        return p1\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.727766913623137,
			6.284170432113448,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        \n        node, prev = head, None\n        \n        while node:\n            next, node.next = node.next, prev\n            prev, node = node, next\n            \n        return prev\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			9.638900759859203,
			7.052970076846617,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        def reverse(node: ListNode, prev: ListNode = None) -> ListNode:\n            \n            if not node:\n                return prev\n            \n            next, node.next = node.next, prev\n            \n            return reverse(next,node)\n            \n        return reverse(head)\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.722461378386024,
			6.284366350758586,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if not head:\n            return None\n        pre = None\n\n        while head:\n            next_node = head.next\n            head.next = pre\n            pre = head\n            head = next_node\n        return pre\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.792875635889992,
			6.286156464544205,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n    \n        prev:ListNode = None #created an Empty Node\n        curr = head # The Head Node is now current(curr) node\n        while curr!= None: #Iterate until the Node is None\n            nexttemp: ListNode = curr.next #created a temp Node to remember the next Node\n            curr.next = prev # assigning the next Node of current as Prev (for first iteration it will be None)\n            prev = curr # Now the prev become current\n            curr = nexttemp # current become the node which we stored in the temp Node(nexttemp)\n        return prev\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.779659756342792,
			6.285886194077892,
			10,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        first = head\n        if (not first) or (not first.next): return first\n\n        first.next, curr, prev = None, first.next, first\n        \n        #1. Reverse  (curr.next = prev)\n        #2. Update Current\n        #3. Update previous\n        \n        while curr.next:\n            curr.next, curr, prev = prev, curr.next, curr\n\n        curr.next = prev\n        return curr\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.678362123926044,
			6.284495181554656,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        pre = None\n        curr = head\n        while curr:\n            temp = curr.next #\u53d6\u51fa\u539flist\u91cc\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\uff0c\u9632\u6b62\u5f04\u4e22\n\n            curr.next = pre #\u5c06\u5f53\u524d\u6307\u9488\u7684\u4e0b\u4e00\u4e2a\u6307\u5411\u4e4b\u524d\u7684\u5143\u7d20\uff0c\u5728\u7b2c\u4e00\u6b21\u8fd0\u884c\u65f6\u4e4b\u524d\u7684\u5143\u7d20\u4e3aNone\n            pre = curr #\u8fd9\u4e00\u6b21\u7684\u5f53\u524d\u5143\u7d20\u5c31\u662f\u4e0b\u4e00\u6b21\u7684\u4e4b\u524d\u7684\u5143\u7d20\n        \n            curr = temp #\u628a\u6307\u5411\u5f53\u524d\u5143\u7d20\u7684\u6307\u9488\u6307\u5230\u6700\u5f00\u59cb\u5b58\u5230temp\u91cc\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u4e0a\n        return pre #\u8df3\u51fa\u5faa\u73af\u65f6\uff0ccurr\u662fnone\uff0c\u4e0a\u4e00\u4e2a\u5faa\u73af\u91cc\u7684curr\u5373pre\u624d\u662f\u65b0\u94fe\u8868\u7684\u5934\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.706037228430707,
			6.285387149594441,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        current = head\n        previous = None\n        nextNode = None\n\n        while current:\n            nextNode = current.next\n            current.next = previous\n            \n            previous = current\n            current = nextNode\n\n        return previous\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.590991200600104,
			6.284833002847911,
			11,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        if head is None or head.next is None:\n            return head\n        \n        curr_node = head\n        \n        next_node = head.next\n        \n        prev_node = None\n        \n        while True:\n            \n            curr_node.next = prev_node\n            \n            if next_node is None:\n                head = curr_node\n                break\n            \n            prev_node = curr_node\n            \n            curr_node = next_node\n            \n            next_node = next_node.next\n            \n        \n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.569988213596734,
			6.285486784630587,
			10,
			2.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head:ListNode)->ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n\t\t\n\t\t# if sll is empty or ends after one\n        if head is None or head.next is None:\n\t\t    #then return\n            return head\n        \n\t\t#previous node is set to none\n\t\t#current node is set to head\n\t\t#next node is set to current.next\n        p_node, c_node, n_node = None, head, head.next\n        \n\t\t#while next node is not equal to none\n        while n_node is not None:\n\t\t\n\t\t    # current nodes pointer is set to the previous node\n            c_node.next = p_node\n\t\t\t# previous node is set to current node\n            p_node = c_node\n\t\t\t#current node is now set to next node\n            c_node = n_node\n\t\t\t#next node is set to current node .next\n            n_node = c_node.next\n           \n\t\t#finish final iteration by redirecting last pointer\n        c_node.next = p_node\n\t\t#declare new head\n        head = c_node\n\t\t\n\t\t#return head of sll\n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			12.505318925871702,
			6.283825353658826,
			9,
			2.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head:ListNode)->ListNode:\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        node_values = []\n        \n        current_node = head\n        \n        while current_node is not None:\n            node_values.insert(0, current_node.val)\n            current_node = current_node.next\n        \n        c_n = head\n        idx = 0\n        \n        while c_n is not None:\n            c_n.val = node_values[idx]\n            c_n = c_n.next\n            idx+=1\n                \n        return head\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.579657214737443,
			6.284836989618722,
			8,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        \n        p1, p2 = None, head\n        while p2 is not None:\n            p3 = p2.next\n            p2.next = p1\n            p1 = p2\n            p2 = p3\n            \n        return p1\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.572184981244945,
			6.284938189884019,
			8,
			1.0,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        \n        node, prev = head, None\n        \n        while node:\n            next, node.next = node.next, prev\n            prev, node = node, next\n            \n        return prev\n\n\n    return breakList(f(makeList(l)))\n"
		],
		[
			8.930573564726327,
			7.055318541494427,
			9,
			1.5,
			"def reverseList(l:List[int]):\n    def makeList(l):\n        head = None\n        if(len(l)==0):\n            return head\n        else:\n            head = temp = ListNode(l[0])\n            for i in range(1,len(l)):\n                temp.next = ListNode(l[i])\n                temp = temp.next\n        return head\n\n    def breakList(head):\n        l = []\n        while(head!=None):\n            l.append(head.val)\n            head = head.next\n        return l\n\n    def reverseList(head: ListNode) -> ListNode:\n        def reverse(node: ListNode, prev: ListNode = None) -> ListNode:\n            \n            if not node:\n                return prev\n            \n            next, node.next = node.next, prev\n            \n            return reverse(next,node)\n            \n        return reverse(head)\n\n\n    return breakList(f(makeList(l)))\n"
		]
	],
	"INORDER_TRAVERSAL": [
		"n",
		[
			9.049410088076927,
			6.313483957119213,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        from collections import deque\n        ans = deque([])\n        q= deque([])\n        current = root\n        \n        # In-order traversal: Left->Root->Right\n        while True:\n            if current:  # append all the left nodes into the stack\n                q.append(current)\n                current = current.left\n            elif q: #when reached to the far left, pop from the stack\n                current = q.pop()\n                ans.append(current.val) # print the left -> middle\n                current = current.right  # then print the right\n            else:\n                break\n\n        return list(ans)\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.121113021674732,
			6.28543118757742,
			6,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        ans = []\n        def rec(root):\n            if not root:\n                return\n            rec(root.left)\n            ans.append(root.val)\n            rec(root.right)\n        rec(root)\n        return ans\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.985295671196496,
			6.286176666006351,
			8,
			3.611111111111111,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        if not root:\n            return []\n\t\t\n\t\t# inorder: L-V-R\n        result:List[int] = []\n        stack:List[int] = []\n\t\t\t\n        while True:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                if len(stack)==0:\n                    break\n                else:\n                    root = stack.pop()\n                    result.append(root.val)\n                    root = root.right\n\t\t\t\t\n        return result\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.023290615708513,
			6.285450737548484,
			6,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        res = []\n        def recursive(node, li):\n            if node:\n                recursive(node.left, li)\n                li.append(node.val)\n                recursive(node.right, li)\n                \n            return li\n        \n        return recursive(root, res)\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.969223169200479,
			6.285718208515414,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root:TreeNode)->List[int]:\n        \n        stack= []\n        \n        res = []\n        \n       \n        while True:\n            \n            if root:\n                stack.append(root)\n                root = root.left\n            \n            elif stack:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n                \n            else:\n                break\n        \n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.843382580749928,
			6.28494998784806,
			8,
			4.0625,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root:TreeNode)-> List[int]:\n        res, stack = [], []\n        n          = root\n        #\n        while n or stack:\n            if not n: \n                # n.right was empty, backtrack one node (but avoid visiting the left branch again)\n                n = stack.pop() \n            else:\n                # n.right existed, reach its left-most node\n                while n.left:\n                    stack.append(n) \n                    n = n.left\n            res.append(n.val)\n            # Attempt to move right\n            n = n.right\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.116899868293777,
			6.284760198930672,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        res, stack = [], [(root, False)]\n        while stack:\n            node, visited = stack.pop()  # the last element\n            if node:\n                if visited:\n                    res.append(node.val)\n                else:  # inorder: left -> root -> right\n                    stack.append((node.right, False))\n                    stack.append((node, True))\n                    stack.append((node.left, False))\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.083538441587192,
			6.284883992700353,
			9,
			5.333333333333333,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        curr = root\n        res = []\n        while curr:\n            if curr.left:\n                pre = curr.left\n                while pre.right and pre.right!=curr:\n                    pre = pre.right\n                if pre.right == curr:\n                    pre.right = None\n                    res.append(curr.val)\n                    curr = curr.right\n                else:\n                    pre.right = curr\n                    curr = curr.left\n            else:\n                res.append(curr.val)\n                curr = curr.right\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.986502844996478,
			6.285735670800668,
			9,
			4.8,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        output, stack =[],[]\n        while(stack or root):\n            if root:\n                # Go to the left most and push the parent into the stack\n                # We need this parent node once we are done with left child and need to go to the right child\n                stack.append(root)\n                root = root.left\n            elif stack and root == None:\n                #We are done with left , so pop out the parent\n                root = stack.pop()\n                output.append(root.val)\n                # Go to the right child\n                root = root.right\n        return output\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.155950647172217,
			6.3236239052561345,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        if root is None:\n            return []\n        \n        if root.left is None:\n            l = []\n        else:\n            l = inorderTraversal(root.left)\n            \n        if root.right is None:\n            r = []\n        else:\n            r = inorderTraversal(root.right)\n            \n        return l + [root.val] + r\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.888908025744364,
			6.2863487208946625,
			6,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        output =[]\n        def inorderTraversalHelper(root):\n            if not root:\n                return None\n            inorderTraversalHelper(root.left)\n            output.append(root.val)\n            inorderTraversalHelper(root.right)\n        inorderTraversalHelper(root)\n        return output\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.067517231240599,
			6.285464020904903,
			9,
			5.115384615384615,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        # Morris Traversal\n        curr = root\n        output =[]\n        while(curr):\n            #if no left child, we can directly go the right child\n            if not curr.left:\n                output.append(curr.val)\n                curr = curr.right\n            else:\n            # find the inorder predecessor of the current node\n                predecessor = curr.left\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \n                # and reached the curr via its predecessor link and now again checking this else condition.\n                # We have to break out of this loop.\n                while predecessor.right !=None and predecessor.right != curr:\n                    predecessor = predecessor.right # go as right as possible\n\n                # Now check which out of 2 above condition it reached\n                if predecessor.right == None:\n                    # No link created till now, so create one and go to the left child of current.\n                    predecessor.right = curr\n                    curr = curr.left\n                else:\n                    # left subtree is already visited , so delete the link and then go to right subtree\n                    predecessor.right = None\n                    output.append(curr.val)\n                    curr = curr.right\n        return output \n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.03539258008947,
			6.285363946892027,
			7,
			3.0,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        \n        ## RC ##\n        ## APPROACH : STACK ##\n        ## (question demands iterative solution)\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n        \n        res = []\n        stack = []\n        currNode = root\n        \n        while(currNode or stack):              # attention to condition.\n            while(currNode):\n                stack.append(currNode)\n                currNode = currNode.left        # traverse all to the left\n            \n            currNode = stack.pop()\n            res.append(currNode.val)            # print\n            currNode = currNode.right           # traverse right\n        \n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.00409173753254,
			6.25722225697436,
			10,
			4.25,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def findPredecessor(root: TreeNode) -> TreeNode:\n        curr = root.left\n\n        while curr.right and curr.right != root:\n            curr = curr.right\n\n        return curr\n\n    def inorderTraversal(root: TreeNode) -> List[int]:\n        res = []\n\n        while root:\n            if not root.left: # if we don't have a left, this is our best in-order value at the moment. add it to the list and move right.\n                res.append(root.val)\n                root = root.right\n            else:\n                pred = findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\n\n\t\t\t\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we're not ex\n                if pred.right != root:\n                    pred.right = root\n                    root = root.left\n                else: \n\t\t\t\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\n                    root.left = None\n\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.925388176529086,
			6.284362379584455,
			7,
			3.0,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:        \n        return_list = []\n        stack = []\n        node = root\n        \n        while True:\n            \n            if node is not None:\n                stack.append(node)\n                node = node.left\n                \n            elif(stack):\n                node = stack.pop()\n                return_list.append(node.val)\n                node = node.right\n            else:\n                break\n        return return_list\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.007483255452218,
			6.414168608179464,
			10,
			4.615384615384615,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        visited = set()\n        result = []\n        stack = []\n        if root: stack.append(root)\n        \n        while(len(stack) > 0):\n            curr = stack.pop()\n            \n            if curr.left and curr.left not in visited:\n                stack.append(curr)\n                stack.append(curr.left)\n                continue\n            \n            visited.add(curr)\n            result.append(curr.val)\n        \n            if curr.right and curr.right not in visited:\n                stack.append(curr.right)\n        \n        return result\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.002944455276484,
			6.284650303773552,
			8,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def helper(node, acc):\n        if not node: return acc\n        if node.left:\n            helper(node.left, acc)\n        \n        acc.append(node.val)\n        \n        if node.right:\n            helper(node.right, acc)\n        \n        return acc\n\n    def inorderTraversal(root: TreeNode) -> List[int]:\n        return helper(root, [])\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.017889844053865,
			6.315920260848318,
			5,
			3.0,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(node: TreeNode) -> List[int]:\n        if node is None:\n            return []\n\n        left_children = inorderTraversal(node.left)\n        right_children = inorderTraversal(node.right)\n\n        return [*left_children, node.val, *right_children]\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.082670805782053,
			6.309643699800168,
			5,
			2.1,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root:TreeNode)->List[int]:\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else []\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.08631197926125,
			6.309679598339072,
			5,
			2.727272727272727,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        \n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.944780368826903,
			6.2855860449839325,
			6,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        ans = []\n        \n        # In-order traversal: left->root->right\n        \n        def dfs(node):\n            if not node: return\n            dfs(node.left)\n            ans.append(node.val)\n            dfs(node.right)\n            \n        dfs(root)\n        return ans\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.025936412869255,
			6.285657419785883,
			8,
			3.611111111111111,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        if not root:\n            return []\n\t\t\n\t\t# inorder: L-V-R\n        result:List[int] = []\n        stack:List[int] = []\n\t\t\t\n        while True:\n            if root:\n                stack.append(root)\n                root = root.left\n            else:\n                if len(stack)==0:\n                    break\n                else:\n                    root = stack.pop()\n                    result.append(root.val)\n                    root = root.right\n\t\t\t\t\n        return result\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.966561921386539,
			6.284515908312677,
			6,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        res = []\n        def recursive(node, li):\n            if node:\n                recursive(node.left, li)\n                li.append(node.val)\n                recursive(node.right, li)\n                \n            return li\n        \n        return recursive(root, res)\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.996290427408336,
			6.28646736119019,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root:TreeNode)->List[int]:\n        \n        stack= []\n        \n        res = []\n        \n       \n        while True:\n            \n            if root:\n                stack.append(root)\n                root = root.left\n            \n            elif stack:\n                root = stack.pop()\n                res.append(root.val)\n                root = root.right\n                \n            else:\n                break\n        \n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.997159174180533,
			6.285757397055318,
			8,
			4.0625,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root:TreeNode)-> List[int]:\n        res, stack = [], []\n        n          = root\n        #\n        while n or stack:\n            if not n: \n                # n.right was empty, backtrack one node (but avoid visiting the left branch again)\n                n = stack.pop() \n            else:\n                # n.right existed, reach its left-most node\n                while n.left:\n                    stack.append(n) \n                    n = n.left\n            res.append(n.val)\n            # Attempt to move right\n            n = n.right\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.00597637030406,
			6.286541025618701,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        res, stack = [], [(root, False)]\n        while stack:\n            node, visited = stack.pop()  # the last element\n            if node:\n                if visited:\n                    res.append(node.val)\n                else:  # inorder: left -> root -> right\n                    stack.append((node.right, False))\n                    stack.append((node, True))\n                    stack.append((node.left, False))\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.053772923563267,
			6.285393123438426,
			9,
			5.333333333333333,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        curr = root\n        res = []\n        while curr:\n            if curr.left:\n                pre = curr.left\n                while pre.right and pre.right!=curr:\n                    pre = pre.right\n                if pre.right == curr:\n                    pre.right = None\n                    res.append(curr.val)\n                    curr = curr.right\n                else:\n                    pre.right = curr\n                    curr = curr.left\n            else:\n                res.append(curr.val)\n                curr = curr.right\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.942153217994612,
			6.286519621403868,
			9,
			4.8,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        output, stack =[],[]\n        while(stack or root):\n            if root:\n                # Go to the left most and push the parent into the stack\n                # We need this parent node once we are done with left child and need to go to the right child\n                stack.append(root)\n                root = root.left\n            elif stack and root == None:\n                #We are done with left , so pop out the parent\n                root = stack.pop()\n                output.append(root.val)\n                # Go to the right child\n                root = root.right\n        return output\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.072008272202275,
			6.32401389468549,
			7,
			2.5,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        if root is None:\n            return []\n        \n        if root.left is None:\n            l = []\n        else:\n            l = inorderTraversal(root.left)\n            \n        if root.right is None:\n            r = []\n        else:\n            r = inorderTraversal(root.right)\n            \n        return l + [root.val] + r\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.933873210901547,
			6.284412035298206,
			6,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        output =[]\n        def inorderTraversalHelper(root):\n            if not root:\n                return None\n            inorderTraversalHelper(root.left)\n            output.append(root.val)\n            inorderTraversalHelper(root.right)\n        inorderTraversalHelper(root)\n        return output\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.987927195933528,
			6.284341699285158,
			9,
			5.115384615384615,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        # Morris Traversal\n        curr = root\n        output =[]\n        while(curr):\n            #if no left child, we can directly go the right child\n            if not curr.left:\n                output.append(curr.val)\n                curr = curr.right\n            else:\n            # find the inorder predecessor of the current node\n                predecessor = curr.left\n                # predecessor.right = curr will occur when we have already explored the left subtree of current \n                # and reached the curr via its predecessor link and now again checking this else condition.\n                # We have to break out of this loop.\n                while predecessor.right !=None and predecessor.right != curr:\n                    predecessor = predecessor.right # go as right as possible\n\n                # Now check which out of 2 above condition it reached\n                if predecessor.right == None:\n                    # No link created till now, so create one and go to the left child of current.\n                    predecessor.right = curr\n                    curr = curr.left\n                else:\n                    # left subtree is already visited , so delete the link and then go to right subtree\n                    predecessor.right = None\n                    output.append(curr.val)\n                    curr = curr.right\n        return output \n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.950796926517894,
			6.285166253739097,
			7,
			3.0,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        \n        ## RC ##\n        ## APPROACH : STACK ##\n        ## (question demands iterative solution)\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n        \n        res = []\n        stack = []\n        currNode = root\n        \n        while(currNode or stack):              # attention to condition.\n            while(currNode):\n                stack.append(currNode)\n                currNode = currNode.left        # traverse all to the left\n            \n            currNode = stack.pop()\n            res.append(currNode.val)            # print\n            currNode = currNode.right           # traverse right\n        \n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.033784773631426,
			6.257187770925339,
			10,
			4.25,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def findPredecessor(root: TreeNode) -> TreeNode:\n        curr = root.left\n\n        while curr.right and curr.right != root:\n            curr = curr.right\n\n        return curr\n\n    def inorderTraversal(root: TreeNode) -> List[int]:\n        res = []\n\n        while root:\n            if not root.left: # if we don't have a left, this is our best in-order value at the moment. add it to the list and move right.\n                res.append(root.val)\n                root = root.right\n            else:\n                pred = findPredecessor(root) # find the predecessor for the given node. This is the farthest right of the first left we see.\n\n\t\t\t\t# if we have a right we have move on to explore this sub tree. The pred.right != root check is to ensure that we're not ex\n                if pred.right != root:\n                    pred.right = root\n                    root = root.left\n                else: \n\t\t\t\t# otherwise, we have found a pointer back to the current root and we need to rewrite the tree structure. This is basically a form of \"have we seen this before?\".\n                    root.left = None\n\n        return res\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.011333521706627,
			6.286513489303205,
			7,
			3.0,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:        \n        return_list = []\n        stack = []\n        node = root\n        \n        while True:\n            \n            if node is not None:\n                stack.append(node)\n                node = node.left\n                \n            elif(stack):\n                node = stack.pop()\n                return_list.append(node.val)\n                node = node.right\n            else:\n                break\n        return return_list\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.066217987026192,
			6.467796907065863,
			10,
			4.615384615384615,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        visited = set()\n        result = []\n        stack = []\n        if root: stack.append(root)\n        \n        while(len(stack) > 0):\n            curr = stack.pop()\n            \n            if curr.left and curr.left not in visited:\n                stack.append(curr)\n                stack.append(curr.left)\n                continue\n            \n            visited.add(curr)\n            result.append(curr.val)\n        \n            if curr.right and curr.right not in visited:\n                stack.append(curr.right)\n        \n        return result\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.983457221451065,
			6.2855118978051365,
			8,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def helper(node, acc):\n        if not node: return acc\n        if node.left:\n            helper(node.left, acc)\n        \n        acc.append(node.val)\n        \n        if node.right:\n            helper(node.right, acc)\n        \n        return acc\n\n    def inorderTraversal(root: TreeNode) -> List[int]:\n        return helper(root, [])\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.069575842125799,
			6.315943579460891,
			5,
			3.0,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(node: TreeNode) -> List[int]:\n        if node is None:\n            return []\n\n        left_children = inorderTraversal(node.left)\n        right_children = inorderTraversal(node.right)\n\n        return [*left_children, node.val, *right_children]\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.06726623552726,
			6.309655578397374,
			5,
			2.1,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root:TreeNode)->List[int]:\n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right) if root else []\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			9.139951233365347,
			6.309653294091088,
			5,
			2.727272727272727,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        \n        return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		],
		[
			8.940385388988503,
			6.284782418974206,
			6,
			3.142857142857143,
			"def inorderTraversal(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n    \n    def inorderTraversal(root: TreeNode) -> List[int]:\n        ans = []\n        \n        # In-order traversal: left->root->right\n        \n        def dfs(node):\n            if not node: return\n            dfs(node.left)\n            ans.append(node.val)\n            dfs(node.right)\n            \n        dfs(root)\n        return ans\n\n\n    return inorderTraversal(makeTree(0,l))\n"
		]
	],
	"VALID_BST": [
		"n",
		[
			8.9382581912326,
			6.257244121450743,
			9,
			4.363636363636363,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        curr = root\n        stack = []\n        while(curr):\n            stack.append(curr)\n            curr = curr.left\n        prev = None\n        while(stack):\n            top_ele = stack.pop()\n            if prev is not None and top_ele.val <= prev:\n                return False\n            prev = top_ele.val\n            next_right = top_ele.right\n            while(next_right):\n                stack.append(next_right)\n                next_right = next_right.left\n        return True\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.024318467756435,
			6.32556639440015,
			10,
			3.923076923076923,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        if not root :\n            return True\n        def inorder(root) :\n            if root.left :\n                inorder(root.left)\n            ans.append(root.val)\n            if root.right :\n                inorder(root.right)\n        ans=[]\n        inorder(root)\n        if sorted(ans)==ans and len(set(ans))==len(ans) :\n            return True\n        return False\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.004411638650183,
			6.28575883382522,
			10,
			4.071428571428571,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n            if not root:\n                return True\n            \n            def DFSInOrder(node, lista):\n\n                if node.left:\n                    DFSInOrder(node.left, lista)\n\n                lista.append(node.val)\n\n                if node.right:\n                    DFSInOrder(node.right, lista)\n\n                return lista\n            \n            a = DFSInOrder(root, [])\n            \n            for x in range(len(a)-1):\n                if a[x] == a[x+1]:\n                    return False\n                \n            return sorted(a) == a\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.897469475669475,
			6.257194761345153,
			10,
			4.846153846153846,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        if root is None:\n            return True\n        stack = [(root,float(\"-inf\"), float(\"inf\"))]\n        while stack:\n            node, mini, maxum = stack.pop()\n            \n            #if current node is between our min and max it satisfied the BST property\n            if node.val > mini and node.val < maxum:\n                #everything to the right of our current node must be greater than cur node\n                if node.right:\n                    stack.append((node.right,node.val, maxum))\n                #everything to the left of our current node must be less than cur node\n                if node.left:\n                    stack.append((node.left,mini,node.val))\n            else:\n                return False\n        return True \n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.90538462373226,
			6.257188362864673,
			11,
			5.333333333333333,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def Traverse(root,min,max):\n        if(root is None): \n          return True\n        if((min!=None and root.val<=min.val) or (max!=None and root.val>=max.val)): \n          return False\n        return Traverse(root.left, min, root) and Traverse(root.right, root, max)\n\n    def isValidBST(root: TreeNode) -> bool:                        \n        return Traverse(root,None,None)    \n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.884996967261538,
			6.25719568728922,
			14,
			5.444444444444445,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        return recurse(root, -float('inf'), float('inf'))\n\n    def recurse(node, lo, hi): \n        if not node: \n            return True \n        \n        out = True \n        if node.left: \n            new_lo, new_hi = lo, min(node.val, hi)\n            out = out and new_lo < node.left.val and node.left.val < new_hi and recurse(node.left, new_lo, new_hi)\n            \n        if node.right: \n            new_lo, new_hi = max(lo, node.val), hi \n            out = out and new_lo < node.right.val and node.right.val < new_hi and recurse(node.right, new_lo, new_hi) \n        \n        return out \n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.901935715521882,
			6.257199300862641,
			9,
			5.333333333333333,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        mini = -2147483649\n        maxi = 2147483648\n        def bst(root,mini,maxi):\n            if(not root):\n                return True\n            if(root.val<=mini or root.val>=maxi):\n                return False\n            return(bst(root.left,mini,root.val) and (bst(root.right,root.val,maxi)))\n        return(bst(root,mini,maxi))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.993691366749523,
			6.257237391521068,
			8,
			4.958333333333333,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        valid = True\n        prev = None\n        \n        def go(n):\n            nonlocal valid, prev\n            if not n:\n                return\n            \n            go(n.left)\n            if prev != None and n.val <= prev:\n                valid = False\n            prev = n.val\n            go(n.right)\n            \n        go(root)\n            \n        return valid\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.028748692387069,
			6.257236360640797,
			9,
			4.75,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        _, _, is_valid = recur(root)\n        return is_valid\n\n    def recur(root):\n        if not root:\n            return float('inf'), float('-inf'), True\n        min_left, max_left, is_valid_left = recur(root.left)\n        min_right, max_right, is_valid_right = recur(root.right)\n\n        if root.val < min_right and root.val > max_left:\n            curr_is_valid = is_valid_left and is_valid_right\n            left_min = min(min_left, root.val)\n            right_max = max(max_right, root.val)\n        else:\n            curr_is_valid = False\n            left_min = float('inf')\n            right_max = float('-inf')\n        return left_min, right_max, curr_is_valid\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.926088087335135,
			6.2572062244679145,
			10,
			4.071428571428571,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## EDGE CASE : [10,5,15,null,null,6,20] ## (i.e all right elements must be stricly greater than root even left childs of right side, vice versa)\n        \n        ## LOGIC : so we to keep upper and lower limits\n        ##  1. For left child, root is the upper limit\n        ##  2. For right child, root is the lower limit \n        \n\t\t## TIME COMPLEXICITY : O(N) ##\n\t\t## SPACE COMPLEXICITY : O(N) ##\n        \n        def helper(node, lower = float('-inf'), upper = float('inf')):\n            if not node:\n                return True\n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n        return helper(root)\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.93845345197927,
			6.257250042024686,
			7,
			4.433333333333334,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root:TreeNode, left = float('-inf'), right = float('inf'))->bool:\n        return not root or left < root.val < right and isValidBST(root.left, left, root.val) and isValidBST(root.right, root.val, right)\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.1494720932837,
			6.257252611296618,
			5,
			3.857142857142857,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode, low = -float('inf'), high = float('inf')) -> bool:\n        if not root:\n            return True\n        return (low < root.val < high) & (isValidBST(root.left, low, root.val)) & (isValidBST(root.right, root.val, high))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.981062025699119,
			6.25724612564742,
			5,
			3.857142857142857,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode, low = -float('inf'), high = float('inf')) -> bool:\n        if not root:\n            return True\n        return (low < root.val < high) & (isValidBST(root.left, low, root.val)) & (isValidBST(root.right, root.val, high))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.97238051586479,
			6.325051672862375,
			7,
			4.25,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        def inOrderTraversal(root):\n            if not root:\n                return 0\n            inOrderTraversal(root.left)\n            stack.append(root.val)\n            inOrderTraversal(root.right)\n        stack = []\n        inOrderTraversal(root)\n        return stack == sorted(stack) and stack == sorted(list(set(stack)))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.910884173028881,
			6.257203683175276,
			9,
			4.0,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        \n        def helper(root, lower=float(\"-inf\"), upper=float(\"inf\")):\n        \n            if not root:\n                return True\n            if lower < root.val < upper:\n                if helper(root.left, lower, root.val) and helper(root.right, root.val, upper):\n                    return True\n                else:\n                    return False\n            else:\n                return False\n\n        return helper(root)  \n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.898623891085713,
			6.257211373562005,
			9,
			4.666666666666667,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root:TreeNode)->bool:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return validater(root, float('-inf'), float('inf'))\n\n    def validater(tree, minimum, maximum):\n\n        # past leaf node/ single node tree\n        if tree == None:\n            return True\n\n        # validate\n        if tree.val >= maximum or tree.val <= minimum:\n            return False\n\n        # every node to the left is smaller than the one above it. the one above it is larger.\n        left_handler = validater(\n            tree.left, minimum=minimum, maximum=tree.val)\n\n        # every node to the right is larger. the one above it is smaller.\n        right_handler = validater(\n            tree.right, minimum=tree.val, maximum=maximum)\n\n        return left_handler and right_handler\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.895348294924105,
			6.2572696170211515,
			9,
			3.5,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def inOrder(node):\n        if not node: return\n\n        yield from inOrder(node.left)\n        yield(node)\n        yield from inOrder(node.right)\n\n    def isValidBST(root: TreeNode) -> bool:\n        if not root: return True\n        \n        prev = float(\"-inf\")\n        \n        for node in inOrder(root):\n            if node.val <= prev: return False\n            prev = node.val\n        \n        return True\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.921520775352977,
			6.2572934294395965,
			7,
			3.0,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n\n        def inorder(node):\n            if node:\n                yield from inorder(node.left)\n                yield node.val\n                yield from inorder(node.right)\n\n        a, b = itertools.tee(inorder(root))  # two inorder generator\n        next(b, None)  # b go on step\n        return all(c < d for c, d in zip(a, b))   # compare\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.745993803187517,
			6.25720240320682,
			10,
			5.25,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(tree: TreeNode) -> bool:\n        def are_keys_in_range(tree, low_range = float('-inf'),high_range = float('inf')):\n            if tree and tree.val == high_range:\n                return False\n            elif not tree:\n                return True\n            elif not low_range < tree.val < high_range: #doesn't hold\n                return False\n            \n            return (are_keys_in_range(tree.left,low_range,tree.val) and are_keys_in_range(tree.right,tree.val,high_range))\n        return (are_keys_in_range(tree))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.738623112949105,
			6.257193226893009,
			8,
			2.909090909090909,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        answer = True\n        \n        def dfs(root, left, right):\n            if root:\n                if left >= root.val or root.val >= right:\n                    answer = False\n                    return\n                dfs(root.left, left, root.val)\n                dfs(root.right, root.val, right)\n        dfs(root, float(\"-inf\"), float('inf'))\n        return answer\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.968572492421917,
			6.257203113577024,
			8,
			4.153846153846154,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode,\n                   max_root_val: int = sys.maxsize,\n                   min_root_val: int = -sys.maxsize) -> bool:\n        if root:\n            # The current node must not statisfy any of the conditions\n            if root.val >= max_root_val or root.val <= min_root_val:\n                return False\n            else: # Check left-subtree and right-subtree\n                return (isValidBST(root.left, min(max_root_val, root.val), min_root_val)\n                        and isValidBST(root.right, max_root_val, max(min_root_val, root.val)))\n        else: # By default return true   \n            return True\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.8775417352638,
			6.257053000200467,
			7,
			4.433333333333334,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root:TreeNode, left = float('-inf'), right = float('inf'))->bool:\n        return not root or left < root.val < right and isValidBST(root.left, left, root.val) and isValidBST(root.right, root.val, right)\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.94821504537337,
			6.257214140809335,
			5,
			3.857142857142857,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode, low = -float('inf'), high = float('inf')) -> bool:\n        if not root:\n            return True\n        return (low < root.val < high) & (isValidBST(root.left, low, root.val)) & (isValidBST(root.right, root.val, high))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.953941019877437,
			6.257190883614303,
			5,
			3.857142857142857,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode, low = -float('inf'), high = float('inf')) -> bool:\n        if not root:\n            return True\n        return (low < root.val < high) & (isValidBST(root.left, low, root.val)) & (isValidBST(root.right, root.val, high))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.007622140656787,
			6.324817965563484,
			7,
			4.25,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        def inOrderTraversal(root):\n            if not root:\n                return 0\n            inOrderTraversal(root.left)\n            stack.append(root.val)\n            inOrderTraversal(root.right)\n        stack = []\n        inOrderTraversal(root)\n        return stack == sorted(stack) and stack == sorted(list(set(stack)))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.877633317091904,
			6.257205915026807,
			9,
			4.0,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        \n        def helper(root, lower=float(\"-inf\"), upper=float(\"inf\")):\n        \n            if not root:\n                return True\n            if lower < root.val < upper:\n                if helper(root.left, lower, root.val) and helper(root.right, root.val, upper):\n                    return True\n                else:\n                    return False\n            else:\n                return False\n\n        return helper(root)  \n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.882146264602989,
			6.257164732202797,
			9,
			4.666666666666667,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root:TreeNode)->bool:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return validater(root, float('-inf'), float('inf'))\n\n    def validater(tree, minimum, maximum):\n\n        # past leaf node/ single node tree\n        if tree == None:\n            return True\n\n        # validate\n        if tree.val >= maximum or tree.val <= minimum:\n            return False\n\n        # every node to the left is smaller than the one above it. the one above it is larger.\n        left_handler = validater(\n            tree.left, minimum=minimum, maximum=tree.val)\n\n        # every node to the right is larger. the one above it is smaller.\n        right_handler = validater(\n            tree.right, minimum=tree.val, maximum=maximum)\n\n        return left_handler and right_handler\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.909173702954863,
			6.257306547155069,
			9,
			3.5,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def inOrder(node):\n        if not node: return\n\n        yield from inOrder(node.left)\n        yield(node)\n        yield from inOrder(node.right)\n\n    def isValidBST(root: TreeNode) -> bool:\n        if not root: return True\n        \n        prev = float(\"-inf\")\n        \n        for node in inOrder(root):\n            if node.val <= prev: return False\n            prev = node.val\n        \n        return True\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.945307971018506,
			6.257241725752829,
			7,
			3.0,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n\n        def inorder(node):\n            if node:\n                yield from inorder(node.left)\n                yield node.val\n                yield from inorder(node.right)\n\n        a, b = itertools.tee(inorder(root))  # two inorder generator\n        next(b, None)  # b go on step\n        return all(c < d for c, d in zip(a, b))   # compare\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.270550244892716,
			6.257202202789166,
			10,
			5.25,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(tree: TreeNode) -> bool:\n        def are_keys_in_range(tree, low_range = float('-inf'),high_range = float('inf')):\n            if tree and tree.val == high_range:\n                return False\n            elif not tree:\n                return True\n            elif not low_range < tree.val < high_range: #doesn't hold\n                return False\n            \n            return (are_keys_in_range(tree.left,low_range,tree.val) and are_keys_in_range(tree.right,tree.val,high_range))\n        return (are_keys_in_range(tree))\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			9.230552541651777,
			6.257235408056124,
			8,
			2.909090909090909,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode) -> bool:\n        answer = True\n        \n        def dfs(root, left, right):\n            if root:\n                if left >= root.val or root.val >= right:\n                    answer = False\n                    return\n                dfs(root.left, left, root.val)\n                dfs(root.right, root.val, right)\n        dfs(root, float(\"-inf\"), float('inf'))\n        return answer\n\n\n    return isValidBST(makeTree(0,l))\n"
		],
		[
			8.931297656078629,
			6.257223693227339,
			8,
			4.153846153846154,
			"def isValidBST(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def isValidBST(root: TreeNode,\n                   max_root_val: int = sys.maxsize,\n                   min_root_val: int = -sys.maxsize) -> bool:\n        if root:\n            # The current node must not statisfy any of the conditions\n            if root.val >= max_root_val or root.val <= min_root_val:\n                return False\n            else: # Check left-subtree and right-subtree\n                return (isValidBST(root.left, min(max_root_val, root.val), min_root_val)\n                        and isValidBST(root.right, max_root_val, max(min_root_val, root.val)))\n        else: # By default return true   \n            return True\n\n\n    return isValidBST(makeTree(0,l))\n"
		]
	],
	"HEIGHT_BT": [
		"n",
		[
			9.092375702592497,
			6.257317949230803,
			5,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        left = maxDepth(root.left)\n        right = maxDepth(root.right)\n        \n        return max(left, right) + 1\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.131459849208401,
			6.257312209548638,
			6,
			4.071428571428571,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root:TreeNode)->int:\n        if not root or root.val is  None: \n            return 0\n\n        left_level = maxDepth(root.left) + 1 \n        right_level = maxDepth(root.right) + 1 \n\n        return max(left_level, right_level)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			11.573805464509844,
			6.27163107108145,
			9,
			5.03125,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        queue = []\n        count = 0\n        if not root:\n            return 0\n        queue.append(root)\n        while len(queue) > 0:\n            size = len(queue)\n            while size > 0:\n                var = queue.pop(0)\n                if var.left is not None:\n                    queue.append(var.left)\n                if var.right is not None:\n                    queue.append(var.right)\n                size -= 1 \n            count += 1 \n        return count  \n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.155239163879461,
			6.257256860079568,
			5,
			3.0,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root: \n            return 0\n        \n        left_level = maxDepth(root.left) + 1 \n        right_level = maxDepth(root.right) + 1 \n        \n        return max(left_level, right_level) \n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.118540153140874,
			6.257251822249488,
			8,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        def travel(node):\n            if not node:\n                return 0\n            l=r=0\n            if node.left:\n                l = travel(node.left)\n            if node.right:\n                r = travel(node.right)\n            return 1+max(l,r)\n        return travel(root)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.101457368230124,
			6.257195088575497,
			5,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        return max(maxDepth(root.left), maxDepth(root.right)) + 1\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			8.815283825653733,
			6.2572619195058445,
			6,
			3.3333333333333335,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        def helper(node, depth):\n            if not node:\n                return depth\n            return max(helper(node.left, depth + 1), helper(node.right, depth + 1))\n        return helper(root, 0)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.17230242710209,
			6.2714969384903,
			9,
			3.75,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        q = [root]\n        max_depth = 0\n        while q:\n            size = len(q)\n            max_depth+=1\n            while size:\n                front = q.pop(0)\n                size-=1\n\n                if front.left:\n                    q.append(front.left)\n                if front.right:\n                    q.append(front.right)\n\n        return max_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.099033166329434,
			6.286657383959783,
			9,
			3.409090909090909,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root:TreeNode)->int:\n        stack,level,final,counter = deque(), [], [], 0\n        stack.append(root)\n        if not root:\n            return 0\n        while len(stack)>0:\n            for i in range(len(stack)):\n                popped = stack.popleft()\n                level.append(popped.val)\n                if popped.left:\n                    stack.append(popped.left)\n                if popped.right:\n                    stack.append(popped.right)\n            final.append(level)\n            counter+=1\n            level = []\n        return counter\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.005706801602177,
			6.257307753302621,
			8,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : DFS ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        def helper(node):\n            if(not node):   return 0\n            l = r = 0\n            if(node.left):\n                l = max(helper(node.left), 0)\n            if(node.right):\n                r = max(helper(node.right), 0)\n            return 1 + max(l, r)\n        return helper(root)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.05510628101194,
			6.257260587552219,
			5,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        \n        if not root:\n\t\t\t# Base case:\n            # Empty tree or empty leaf node\n            return 0\n        \n        else:\n            # General case\n            left = maxDepth( root.left )\n            right = maxDepth( root.right )\n            \n            return max(left, right)+1\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.129056868910208,
			6.2573300365475335,
			10,
			4.333333333333333,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculate_max(root, d):\n        if root.right == None and root.left == None:\n            return d\n        \n        d1 = d2 = 0\n        \n        if root.left != None:\n            d1 = calculate_max(root.left, d+1)\n        \n        if root.right != None:\n            d2 = calculate_max(root.right, d+1)\n        \n        return max([d1, d2])\n\n    def maxDepth(root: TreeNode) -> int:\n        if root != None:\n            return calculate_max(root, 1)\n        else:\n            return 0\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.069440132504546,
			6.257323154547725,
			8,
			3.6538461538461537,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        \n        tree_depth = 0\n        \n        def helper( node: TreeNode, depth: int):\n            \n            if not node:\n\t\t\t\t# Base case\n\t\t\t\t# Empty node or empty tree\n                return\n        \n            if not node.left and not node.right:\n\t\t\t\t# Base case\n\t\t\t\t# Update max depth when reach leaf node\n                tree_depth = max( tree_depth, depth )\n            \n            else:\n\t\t\t\t# General case\n\t\t\t\t# Keep DFS down to next level\n                helper( node.left, depth + 1)\n                helper( node.right, depth + 1)\n        \n        # ------------------------------------------------\n        helper( node = root, depth = 1 )\n        return tree_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			8.786946779775766,
			6.271008021940032,
			10,
			3.3333333333333335,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        queue=deque()\n        queue.append(root)\n        if(root is None): return 0\n        count,n2=1,1\n        while queue:\n            for _ in range(n2):\n                current=queue.popleft()\n                if(current.left): queue.append(current.left)\n                if(current.right): queue.append(current.right)\n            n2=len(queue)\n            if(n2!=0): count+=1\n        return count\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			8.788302824301903,
			6.27699875038876,
			9,
			3.2142857142857144,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if root == None:\n            return 0\n        max_depth = 0\n        L = [root]\n        while L:\n            max_depth += 1\n            L_next = []\n            for n in L:\n                if n.left != None:\n                    L_next.append(n.left)\n                if n.right != None:\n                    L_next.append(n.right)\n            L = L_next\n        return max_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.181799761974226,
			6.257241422258708,
			9,
			4.423076923076923,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        \n        left = maxDepth(root.left)\n        right = maxDepth(root.right)\n        \n        if not root.left:\n            return right + 1\n        \n        if not root.right:\n            return left + 1\n        \n        return max(left, right) + 1\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.422454176308007,
			6.257227732343153,
			5,
			2.909090909090909,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(node: TreeNode) -> int:\n        if node is None:\n            return 0\n\n        return max(maxDepth(node.left) + 1, maxDepth(node.right) + 1)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.221301454816182,
			6.257172798416027,
			6,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n            def traverse(x):\n                if not x:\n                    return 0\n                return 1 + max(traverse(x.left), traverse(x.right))\n            \n            return traverse(root)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			8.768223363082855,
			6.257247163886757,
			11,
			3.0,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def current_max_depth(node: TreeNode, current_max_depth_value: int) -> int:\n        \n        current_max_depth_value += 1\n        \n        if not node:\n            return current_max_depth_value\n        \n        if not node.left and not node.right:\n            return current_max_depth_value\n        \n        current_max_depth_value = max(current_max_depth(node.left, current_max_depth_value), current_max_depth(node.right, current_max_depth_value))\n        \n        return current_max_depth_value\n\n    def maxDepth(root: TreeNode) -> int:\n        \n        max_depth = 0\n        \n        if not root:\n            return max_depth\n        \n        if not root.left and not root.right:\n            return max_depth + 1\n            \n        max_depth = max(current_max_depth(root.left, 1), current_max_depth(root.right, 1))\n        \n        return max_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.301609937162992,
			6.257214745435809,
			5,
			3.0,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        left_max = 1 + maxDepth(root.left)\n        right_max = 1 + maxDepth(root.right)\n        \n        return max(left_max, right_max)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.227234139866216,
			6.279425646489693,
			9,
			2.8,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        res = []\n        que = []\n        que.append(root)\n        lenn = 0\n        if root is None:\n            return lenn\n        while que:\n            nodes = []\n            for x in range(len(que)):\n                node = que.pop(0)\n                nodes.append(node.val)\n                if node.left:\n                    que.append(node.left)\n                if node.right:\n                    que.append(node.right)\n                    \n            lenn += 1\n        return lenn\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.35874800819387,
			6.257245416408317,
			10,
			4.333333333333333,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculate_max(root, d):\n        if root.right == None and root.left == None:\n            return d\n        \n        d1 = d2 = 0\n        \n        if root.left != None:\n            d1 = calculate_max(root.left, d+1)\n        \n        if root.right != None:\n            d2 = calculate_max(root.right, d+1)\n        \n        return max([d1, d2])\n\n    def maxDepth(root: TreeNode) -> int:\n        if root != None:\n            return calculate_max(root, 1)\n        else:\n            return 0\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			8.841671619660007,
			6.257084962906931,
			8,
			3.6538461538461537,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        \n        tree_depth = 0\n        \n        def helper( node: TreeNode, depth: int):\n            \n            if not node:\n\t\t\t\t# Base case\n\t\t\t\t# Empty node or empty tree\n                return\n        \n            if not node.left and not node.right:\n\t\t\t\t# Base case\n\t\t\t\t# Update max depth when reach leaf node\n                tree_depth = max( tree_depth, depth )\n            \n            else:\n\t\t\t\t# General case\n\t\t\t\t# Keep DFS down to next level\n                helper( node.left, depth + 1)\n                helper( node.right, depth + 1)\n        \n        # ------------------------------------------------\n        helper( node = root, depth = 1 )\n        return tree_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.299249770646622,
			6.270973143252455,
			10,
			3.3333333333333335,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        queue=deque()\n        queue.append(root)\n        if(root is None): return 0\n        count,n2=1,1\n        while queue:\n            for _ in range(n2):\n                current=queue.popleft()\n                if(current.left): queue.append(current.left)\n                if(current.right): queue.append(current.right)\n            n2=len(queue)\n            if(n2!=0): count+=1\n        return count\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.05562596190894,
			6.277153316830373,
			9,
			3.2142857142857144,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if root == None:\n            return 0\n        max_depth = 0\n        L = [root]\n        while L:\n            max_depth += 1\n            L_next = []\n            for n in L:\n                if n.left != None:\n                    L_next.append(n.left)\n                if n.right != None:\n                    L_next.append(n.right)\n            L = L_next\n        return max_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.25558923647256,
			6.257234859748319,
			9,
			4.423076923076923,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        \n        left = maxDepth(root.left)\n        right = maxDepth(root.right)\n        \n        if not root.left:\n            return right + 1\n        \n        if not root.right:\n            return left + 1\n        \n        return max(left, right) + 1\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.094731995731326,
			6.257201261171235,
			5,
			2.909090909090909,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(node: TreeNode) -> int:\n        if node is None:\n            return 0\n\n        return max(maxDepth(node.left) + 1, maxDepth(node.right) + 1)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			8.9960385555684,
			6.257220286221338,
			6,
			2.888888888888889,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n            def traverse(x):\n                if not x:\n                    return 0\n                return 1 + max(traverse(x.left), traverse(x.right))\n            \n            return traverse(root)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.070421420361741,
			6.257206803787628,
			11,
			3.0,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def current_max_depth(node: TreeNode, current_max_depth_value: int) -> int:\n        \n        current_max_depth_value += 1\n        \n        if not node:\n            return current_max_depth_value\n        \n        if not node.left and not node.right:\n            return current_max_depth_value\n        \n        current_max_depth_value = max(current_max_depth(node.left, current_max_depth_value), current_max_depth(node.right, current_max_depth_value))\n        \n        return current_max_depth_value\n\n    def maxDepth(root: TreeNode) -> int:\n        \n        max_depth = 0\n        \n        if not root:\n            return max_depth\n        \n        if not root.left and not root.right:\n            return max_depth + 1\n            \n        max_depth = max(current_max_depth(root.left, 1), current_max_depth(root.right, 1))\n        \n        return max_depth\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			9.144069441645739,
			6.256993774172858,
			5,
			3.0,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        if not root:\n            return 0\n        \n        left_max = 1 + maxDepth(root.left)\n        right_max = 1 + maxDepth(root.right)\n        \n        return max(left_max, right_max)\n\n\n    return maxDepth(makeTree(0,l))\n"
		],
		[
			11.885966093645743,
			6.2795679650442935,
			9,
			2.8,
			"def maxDepth(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxDepth(root: TreeNode) -> int:\n        res = []\n        que = []\n        que.append(root)\n        lenn = 0\n        if root is None:\n            return lenn\n        while que:\n            nodes = []\n            for x in range(len(que)):\n                node = que.pop(0)\n                nodes.append(node.val)\n                if node.left:\n                    que.append(node.left)\n                if node.right:\n                    que.append(node.right)\n                    \n            lenn += 1\n        return lenn\n\n\n    return maxDepth(makeTree(0,l))\n"
		]
	],
	"MAX_PATH_SUM_BT": [
		"n",
		[
			9.359432594799204,
			6.257343002559292,
			6,
			3.4545454545454546,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float(\"-inf\")\n\n        def postorder(root):\n            if not root:  return 0\n\n            left_val, right_val = max(0, postorder(root.left)), max(0, postorder(root.right))\n            ans = max(ans, (root.val + left_val + right_val))\n            return max((root.val + left_val), (root.val + right_val))\n\n        postorder(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.256639728599401,
			6.257276842209757,
			6,
			4.0,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        answer =  - sys.maxsize - 1\n        def dfs(node):\n            if not node:\n                return 0\n            left_sub_tree = dfs(node.left)\n            right_sub_tree = dfs(node.right)\n            answer = max(answer , left_sub_tree + right_sub_tree + node.val)\n            return max(0 , node.val + max(left_sub_tree , right_sub_tree))\n        dfs(root)\n        return answer\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.202258057612193,
			6.311333206000482,
			6,
			3.3333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.398064363318838,
			6.257334004916799,
			8,
			5.4375,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(\"-inf\")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.235269114469526,
			6.257201378481136,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.212762633378025,
			6.257196156359804,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.33889348346457,
			6.2839408574865345,
			8,
			4.25,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.49534863625485,
			6.25693278167778,
			6,
			3.4615384615384617,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.082063520517591,
			6.257192564944179,
			6,
			4.230769230769231,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.063347481874139,
			6.257146557337214,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.363783335894421,
			6.257203074752438,
			7,
			4.038461538461538,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(\"-inf\")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(\"-inf\")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(\"-inf\") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.316034780268382,
			6.257212626593933,
			7,
			3.3,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.645372595847704,
			6.25724292091691,
			6,
			2.769230769230769,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.156755951302303,
			6.2571791828700905,
			6,
			3.4615384615384617,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.571591676117315,
			6.257366470962711,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.164726148898405,
			6.257171876073802,
			6,
			3.4545454545454546,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.500101493724204,
			6.257196065355728,
			6,
			3.4615384615384617,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.259923922808177,
			6.2568851987325145,
			6,
			4.181818181818182,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.195464319987215,
			6.257165498633183,
			11,
			3.235294117647059,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.347384477537839,
			6.257136937391685,
			8,
			2.1818181818181817,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.222704588472352,
			6.311642538707305,
			6,
			3.3333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n\n            result = [root.val]\n\n            def findValue(node):\n                if node == None:\n                    return 0\n                else:\n                    l = findValue(node.left)\n                    r = findValue(node.right)\n                    temp = max(l+node.val, r+node.val, node.val)\n                    result.append(temp)\n                    result.append(l+r+node.val)\n                    return temp\n\n\n            findValue(root)\n            return max(result)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.368310022004316,
			6.256989746970456,
			8,
			5.4375,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root:\n            return\n        \n        max_sum = 0\n        neg_sum = float(\"-inf\")\n        negFlag = False\n        def helper(root):\n            if not root:\n                return 0\n            \n            left = helper(root.left)\n            right = helper(root.right)\n            \n            max_sum = max(max_sum, left + root.val + right, root.val, root.val + left, root.val + right)\n            \n            \n            # Handling all -ve values\n            negFlag |= root.val > 0\n            neg_sum = max(neg_sum, root.val)\n\n            return max(root.val + left, root.val + right, root.val)\n            \n        helper(root)\n            \n        if not negFlag:\n            return neg_sum\n        return max_sum    \n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.359113378007736,
			6.256982793130067,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = root.val\n        nodeMax(root)\n        return res\n\n    def nodeMax(node):\n        if not node:\n            return 0\n        else:\n            lmax, rmax = nodeMax(node.left), nodeMax(node.right)\n            res = max(res, node.val + lmax + rmax)\n            return max(node.val + max(lmax, rmax), 0)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.295029423766819,
			6.25723867048548,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right= dfs(node.right)\n        res = max(res, left + right + node.val)\n        cur_max = max(left, right) + node.val\n        return max(cur_max, 0)\n\n    def maxPathSum(root: TreeNode) -> int:\n        res = float('-inf')\n        dfs(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.498170217233701,
			6.284363638690953,
			8,
			4.25,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if root.right==None and root.left==None:\n            return root.val\n        ans=[]\n        def recur(node):\n            if node==None:\n                return 0\n            left_max=0\n            right_max=0\n            left_max+=recur(node.left)\n            right_max+=recur(node.right)\n            ans.append(max(node.val+right_max,left_max+node.val,node.val+right_max+left_max,node.val))\n            return max(left_max+node.val,right_max+node.val,node.val)\n        recur(root)\n        # print(ans)\n        return max(ans)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.48287802458978,
			6.257075895458824,
			6,
			3.4615384615384617,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        _max = -float('inf')\n        def traverse(node):\n            if not node: return 0\n            left = traverse(node.left)\n            right = traverse(node.right)\n            # we keep traversing upwards\n            local_max = max(node.val, node.val + max(left, right))\n            # we cross the path and we are done\n            _max = max(_max, local_max, node.val+left+right)\n            return local_max\n        return max(traverse(root), _max)\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.533709971874476,
			6.257232395461106,
			6,
			4.230769230769231,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if root==None:\n            return(-math.inf,-math.inf)\n        l,lmax=helper(root.left)\n        r,rmax=helper(root.right)\n        c=max(root.val,l+root.val,r+root.val)\n        s=max(c,lmax,rmax,l+r+root.val)\n        return(c,s)\n\n    def maxPathSum(root: TreeNode) -> int:\n        return helper(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.593335348642217,
			6.257191207492743,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def helper(root):\n        if not root:\n            return 0\n        left, right = helper(root.left), helper(root.right)\n        res = max(res, root.val + left + right)\n        return max(root.val + max(left, right), 0)\n\n    def maxPathSum(root:TreeNode)->int:\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        res = float('-inf')\n        helper(root)\n        return res \n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.505506576642068,
			6.256899287174237,
			7,
			4.038461538461538,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        Max = float(\"-inf\")\n        def maxPath(root):\n            nonlocal Max\n            if not root:\n                return float(\"-inf\")\n            left1= maxPath(root.left)\n            right1= maxPath(root.right)\n            temp = max(root.val, root.val + left1, root.val + right1)\n            Max = max(Max, temp, left1+right1+root.val)\n            return temp\n        res = maxPath(root)\n        return Max if Max != float(\"-inf\") else 0\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.60631466921945,
			6.257127847653695,
			7,
			3.3,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def check(node: TreeNode):\n            (lps, ls) = check(node.left) if node.left else (0, float('-inf'))\n            (rps, rs) = check(node.right) if node.right else (0, float('-inf'))\n            return max(lps + node.val, rps + node.val, node.val), max(ls, rs, lps + node.val, rps + node.val, lps + rps + node.val, node.val)\n        return check(root)[1]\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.735395254222494,
			6.257161853340047,
			6,
			2.769230769230769,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def _maxPathSum(tree):\n        if tree == None:\n            return (float('-inf'), float('-inf'))\n\n        lsb, ls = _maxPathSum(tree.left)\n        rsb, rs = _maxPathSum(tree.right)\n        val = tree.val\n\n        cb = max(lsb, rsb)\n        b = max(cb + val, val)\n        r = max(lsb + val + rsb, b)\n        m = max(ls, rs, r)\n\n        return (b , m)\n\n    def maxPathSum(root: TreeNode) -> int:\n        _, m = _maxPathSum(root)\n        return m\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.425078863551738,
			6.257068668695717,
			6,
			3.4615384615384617,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = -math.inf\n        def dfs(r):\n            if not r:\n                return 0\n            left = dfs(r.left)\n            right = dfs(r.right)\n            ans = max(ans,r.val+ left+right)\n            return max(0,r.val+ max(left,right))\n        _ = dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.379303528417582,
			6.257098850737611,
			6,
			2.8333333333333335,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        def mpu(root):\n            if not root:\n                return 0\n            left=mpu(root.left)\n            right=mpu(root.right)\n            ms=max(max(left,right)+root.val,root.val)\n            m21=max(ms,left+right+root.val)\n            res=max(res,m21)\n\n            return ms\n        res=float('-inf')\n        mpu(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.307298222191966,
			6.2571669252990745,
			6,
			3.4545454545454546,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        result = root.val\n        def maxpath(node):\n            if not node:\n                return 0\n            x = node.val\n            l = fmax(0,maxpath(node.left )) # ignore \"left\" branch if negative\n            r = fmax(0,maxpath(node.right)) # ignore \"right\" branch if negative\n            result = fmax(result, x+l+r ) # Check if merged arc-path (left+node+right) beats the current result\n            return fmax(x+l,x+r) # Try to build maximum branch value\n        maxpath(root)\n        return result\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.58627614970164,
			6.25704065414837,
			6,
			3.4615384615384617,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode)->int:\n        ans = -float('inf')\n        \n        def path(root):\n            if not root:\n                return 0\n            left = max(path(root.left),0)\n            right = max(path(root.right),0)\n            val = root.val\n            ans = max(ans,val+left+right)\n            return val+max(left,right)\n        \n        path(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.275933260051112,
			6.2572585958760305,
			6,
			4.181818181818182,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        ans = float('-inf')\n        def dfs(root):\n            if not root:return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            ans = max(ans,root.val,root.val+left,root.val+right,root.val+left+right)\n            return max(root.val,root.val+left,root.val+right)\n        dfs(root)\n        return ans\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.570795943598217,
			6.257202639163324,
			11,
			3.235294117647059,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def maxPathSum(root: TreeNode) -> int:\n        if not root.left and not root.right:\n            return root.val\n        if not root:\n            return 0\n        \n        def solve(node):\n            nonlocal res\n            l=r=0\n            if not node:\n                return 0\n            if node.left:\n                l = max(solve(node.left), 0)\n            if node.right:\n                r = max(solve(node.right), 0)\n            res = max(res, node.val+l+r)\n            return node.val + max(l,r)\n            \n        res = float('-inf')\n        solve(root)\n        return res\n\n\n    return maxPathSum(makeTree(0,l))\n"
		],
		[
			9.573824004206307,
			6.257230247074929,
			8,
			2.1818181818181817,
			"def maxPathSum(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def calculateMaxPath(node):\n        if(node):\n            left = right = 0\n            if(node.left):\n                left = max(calculateMaxPath(node.left), 0)\n            if(node.right):\n                right = max(calculateMaxPath(node.right), 0)\n            max_sum = max(left + right + node.val, max_sum)\n            return max(left, right) + node.val\n\n    def maxPathSum(root: TreeNode) -> int:\n        ## RC ##\n        ## APPROACH : RECURSION ##\n        ## LOGIC : POST ORDER CALCULATION ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n        \n        max_sum = float('-inf')\n        calculateMaxPath(root)\n        return max_sum\n\n\n    return maxPathSum(makeTree(0,l))\n"
		]
	],
	"LEVELORDER_TRAVERSAL": [
		"n",
		[
			9.035470997577152,
			6.285452597386427,
			7,
			2.6666666666666665,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        sol = []\n        def _solve(node, depth=0):\n            if node:\n                if depth >= len(sol):\n                    sol.append([])\n                _solve(node.left, depth+1)\n                sol[depth].append(node.val)\n                _solve(node.right, depth+1)\n        _solve(root)\n        return sol\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.089449590066717,
			6.286636444892353,
			10,
			3.611111111111111,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        if not root: return\n        \n        q = collections.deque([root, None]) # here, None will let you know the level\n        tmp = []\n        res = []\n        while q:\n            node = q.popleft()\n            if node is None:\n                res.append(tmp)\n                tmp = []\n                if q: q.append(None)\n            \n            else:\n                tmp.append(node.val)\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n        \n        return res\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.173279408174995,
			6.299356873264268,
			10,
			3.5416666666666665,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        q = [root]\n        level = [[root.val]]\n        while q:\n            size = len(q)\n            l = []\n            while size:\n                front = q.pop(0)\n                size-=1\n\n                if front.left:\n                    q.append(front.left)\n                    l+=[front.left.val]\n                if front.right:\n                    q.append(front.right)\n                    l+=[front.right.val]\n            if l:\n                level.append(l)\n\n        return level             \n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.057579180828533,
			6.297191499820614,
			9,
			2.5,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        \n        \n        traversal_queue = [ root ] if root else []\n        \n        path = []\n        \n        while traversal_queue:\n            \n            cur_level_path, next_level_queue = [], []\n            \n            for node in traversal_queue:\n                \n                # update current level traversal path\n                cur_level_path.append( node.val )\n                \n                if node.left:\n                    next_level_queue.append( node.left )\n                \n                if node.right:\n                    next_level_queue.append( node.right )\n            \n            # add current level path into path collection\n            path.append( cur_level_path )\n            \n            # update next_level_queue as traversal_queu\n            traversal_queue = next_level_queue\n            \n        return path\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			8.749846956984282,
			6.284895170063076,
			7,
			2.625,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def get_nodes(root: TreeNode, level: int) -> None:\n        if root:\n            tmp = level_dict.get(level, [])\n            tmp.append(root.val)\n            level_dict[level] = tmp\n            get_nodes(root.left, level + 1)\n            get_nodes(root.right, level + 1)\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        level_dict = dict()\n        get_nodes(root, 0)\n        return [nodes for nodes in level_dict.values()]\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			8.928084369283736,
			6.303184326052212,
			10,
			3.5,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        order = []\n        if root is None:\n            return order\n        \n        level = [root]\n        while len(level) > 0:\n\t\t    # Add the new level to the final results.\n            order.append([node.val for node in level])\n\t\t\t\n\t\t\t# Clear our level cache, and get all the children of the current level.\n            parent = level\n            level = []\n            \n            for node in parent:\n                if node.left:\n                    level.append(node.left)\n                if node.right:\n                    level.append(node.right)\n            \n        return order\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.057908940156919,
			6.298087487587128,
			10,
			3.142857142857143,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        if not root: return []\n        result = [[root.val]]\n        n1 = []\n        n2 = [1]\n        while queue:\n            n1=[]\n            for _ in range(len(n2)):\n                current=queue.popleft()\n                if(current.left): \n                    queue.append(current.left)\n                    n1.append(current.left.val)\n                if(current.right): \n                    queue.append(current.right)\n                    n1.append(current.right.val)\n            n2=n1\n            if(len(n2)): result.append(n2)\n        return result\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			10.053533160689318,
			6.2865756245860425,
			9,
			3.3333333333333335,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        if root is None:\n            return []\n        \n        q = Queue()\n        q.put(root)\n        res = []\n        while (q.qsize()):\n            nextLevel = Queue()\n            levelArr = []\n            \n            # For all nodes on the same level, add child nodes from left to right\n            while (q.qsize()):\n                front = q.get()\n                levelArr.append(front.val)\n                if front.left != None:\n                    nextLevel.put(front.left)\n                if front.right != None:\n                    nextLevel.put(front.right)\n                    \n            # By this point, q has exhausted all nodes on that level\n            q = nextLevel\n            \n            # Add the level array to the result array\n            res.append(levelArr)\n        \n        return res\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			11.791727663130382,
			6.394474257971571,
			10,
			3.6363636363636362,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        \n        if(root==None):\n            return []\n           \n        minorList = []\n        ansList = []\n        i = 1\n        level = 0\n        queue = [(root, level)]\n        \n        while(queue):\n            node, level = queue.pop()\n            if(level == i):\n                ansList.append(minorList)\n                minorList = []\n                i += 1\n            minorList.append(node.val)\n            if(node.left):        \n                queue.insert(0, (node.left, level+1))\n            if(node.right):\n                queue.insert(0, (node.right, level+1))\n                \n        if(minorList):\n            ansList.append(minorList)\n            \n        return ansList\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			11.71185907662907,
			6.394854035913597,
			8,
			3.2,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        \n        if root == None:\n            return []\n        \n        Q = [(root, 0)]\n        level = defaultdict(list)\n        \n        while Q:\n            \n            node, l = Q.pop(0)\n            level[l].append(node.val)\n            \n            if node.left:\n                Q.append((node.left, l+1))\n                \n            if node.right:\n                Q.append((node.right, l+1))\n            \n        \n        return [*level.values()]\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.105536028851828,
			6.28533140318639,
			7,
			4.25,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def get_level(root, depth):\n        if(not root):\n            return\n        if(depth == len(_levels)):\n            _levels.append([])\n        _levels[depth].append(root.val)\n        get_level(root.left, depth + 1)\n        get_level(root.right, depth + 1)\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        _levels = []\n        get_level(root, 0)\n        return _levels\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.014653387886407,
			6.286761045248863,
			9,
			3.142857142857143,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        parent=deque() #using deque to use its feature of accesing element from left \n        \n        parent.append(root)\n        result=list()\n        \n        while parent:\n            \n            children=deque()\n            current=[]\n            temp=None\n            \n            while parent:#travesing through parrent level and simultaneously appending their right and left child to children deque\n                temp=parent.popleft()\n                current.append(temp.val)\n                if temp.left:\n                    children.append(temp.left)\n                if temp.right:\n                    children.append(temp.right)\n            \n            result.append(current) # appending value of all node of current level to final result for each level separately \n            parent=children # assigning children deque to parent deque for traversal through next level\n                   \n        return result\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			13.71886035511601,
			6.506369135271054,
			8,
			3.5555555555555554,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        q, d, res = [(root, 1)], {}, []\n        \n        while q:\n            node, level = q.pop(0)\n            if node:\n                if level in d: d[level].append(node.val)\n                else: d[level] = [node.val] \n                q.append((node.left, level+1))\n                q.append((node.right, level+1))\n                \n        for k in d:\n            res.append(d[k])\n                \n        return res\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.250112568006896,
			6.291247268878498,
			10,
			4.090909090909091,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        if not root or root.val is None:\n            return []\n\n        values = []\n        q = [root]\n        while q:\n            level_values = []\n            for _ in range(len(q)):\n                node = q.pop(0)\n                level_values.append(node.val)\n\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n            values.append(level_values)\n\n        return values\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.296658188811701,
			6.286101257078027,
			7,
			4.25,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        d = {}\n        \n        def level_order_traversal(node, k):\n            if not node:\n                return\n            else:\n                if k not in d:\n                    d[k] = [node.val]\n                else:\n                    d[k].append(node.val)\n                level_order_traversal(node.left, k + 1)\n                level_order_traversal(node.right, k + 1)\n                \n        level_order_traversal(root, 0)\n        return list(d.values())\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.136874867421891,
			6.323384917219166,
			9,
			2.5714285714285716,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n      if not root:\n        return []\n      a = root\n      l = [[root.val]]\n      d = [a.left, a.right]\n      while d:\n        temp = []\n        ll = []\n        for i in d:\n          if not i:\n            continue\n          ll += [i.val]\n          temp += [i.left, i.right]\n        else:\n          if ll:\n            l += [ll]\n          d = temp\n      return l\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			11.83583088075349,
			6.291406853258438,
			9,
			4.363636363636363,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        if root is None:\n            return root\n        \n        queue=[]\n        \n        queue.append(root)\n        ans=[]\n        while queue:\n            l=len(queue)\n            level=[]\n            while l!=0:\n                node= queue.pop(0)\n                level.append(node.val)\n            \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                l=l-1\n            ans.append(level)     \n                \n        return ans             \n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			8.92034903364472,
			6.286638400046038,
			9,
			3.142857142857143,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        # \u6a2a\u5411\u7684\u62c6 tree \u662f BFS \u95ee\u9898\uff0c\u7262\u8bb0\u53e3\u8bc0 \u201c\u6df1\u5ea6\u4f18\u5148\u7528\u9012\u5f52\uff0c\u5bbd\u5ea6\u4f18\u5148\u7528deque\u201d\n        # \u601d\u8def\u5c31\u662f \u628a\u6bcf\u5c42\u7684 root \u653e\u8fdb deque \u91cc\n        # \u7136\u540e\u6bcf\u6b21\u62ff\u5230 deque \u7684 \u957f\u5ea6\uff0cl, \u5faa\u73af l \u6b21\uff0c \u628a val \u653e\u5165 temp \u4e2d\uff0c\u628a left,right \u7ee7\u7eedappend \u8fdb\u5165 deque \u4e2d\uff0c\u7136\u540e\u5faa\u73af\u7ed3\u675f\u65f6\u5019\u628a\u6bcf\u6b21\u7684 temp append \u8fdb\u5165 result \u91cc\n        # deque \u7a7a\u7684\u65f6\u5019 tree \u5c31\u904d\u5386\u5c3d\u4e86\n        if not root: return None\n        \n        from collections import deque\n        q = deque([root])\n        result = []\n        \n        while q:\n            l = len(q)\n            temp = []\n            for i in range(l):\n                node = q.popleft()\n                temp.append(node.val)\n                if node.left: q.append(node.left)\n                if node.right: q.append(node.right)\n                    \n            result.append(temp)\n            \n        return result\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			8.829896676910572,
			6.286738509939712,
			13,
			3.5555555555555554,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        ## RC ##\n        ## APPROACH : BFS ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        if(not root):   return []\n        queue = collections.deque([root])\n        all_levels = []\n        while (queue): \n            size = len(queue)\n            curr_level = []\n            for _ in range(size):\n                curr = queue.popleft()\n                curr_level.append(curr.val)\n                if(curr.left):     queue.append(curr.left)\n                if(curr.right):    queue.append(curr.right)\n            all_levels.append(curr_level)\n        return all_levels\n    \n        ## RECURSIVE APPROACH ##\n        if not root:    return []\n        levels = collections.defaultdict(list)\n        def helper(node, level):\n            levels[level].append(node.val)\n            if node.left:   helper(node.left, level + 1)\n            if node.right:  helper(node.right, level + 1)\n        helper(root, 0)\n        return levels.values()\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			9.083546433230474,
			6.286657292297331,
			9,
			3.142857142857143,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        \n        levels = []\n        \n        if not root:   \n            return levels\n        \n        q = collections.deque([root])\n        \n        while q: \n       \n            level = []\n        \n            for _ in range(len(q)):\n                \n                node = q.popleft()\n                level.append(node.val)\n                \n                if node.left:     \n                    q.append(node.left)\n                    \n                if node.right:    \n                    q.append(node.right)\n                    \n            levels.append(level)\n            \n        return levels\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			8.843480777834708,
			6.2864445803352424,
			13,
			3.5555555555555554,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        ## RC ##\n        ## APPROACH : BFS ##\n        \n\t\t## TIME COMPLEXITY : O(N) ##\n\t\t## SPACE COMPLEXITY : O(N) ##\n\n        if(not root):   return []\n        queue = collections.deque([root])\n        all_levels = []\n        while (queue): \n            size = len(queue)\n            curr_level = []\n            for _ in range(size):\n                curr = queue.popleft()\n                curr_level.append(curr.val)\n                if(curr.left):     queue.append(curr.left)\n                if(curr.right):    queue.append(curr.right)\n            all_levels.append(curr_level)\n        return all_levels\n    \n        ## RECURSIVE APPROACH ##\n        if not root:    return []\n        levels = collections.defaultdict(list)\n        def helper(node, level):\n            levels[level].append(node.val)\n            if node.left:   helper(node.left, level + 1)\n            if node.right:  helper(node.right, level + 1)\n        helper(root, 0)\n        return levels.values()\n\n\n    return levelOrder(makeTree(0,l))\n"
		],
		[
			8.959282287025133,
			6.286524909429082,
			9,
			3.142857142857143,
			"def levelOrder(l:List[int]):\n    def makeTree(i:int,lt:List[int]):\n        if(i>=len(lt)):\n            return None\n        root = TreeNode(lt[i])\n        root.left = makeTree(2*i+1,lt)\n        root.right = makeTree(2*i+2,lt)\n        return root\n\n    def levelOrder(root: TreeNode) -> List[List[int]]:\n        \n        levels = []\n        \n        if not root:   \n            return levels\n        \n        q = collections.deque([root])\n        \n        while q: \n       \n            level = []\n        \n            for _ in range(len(q)):\n                \n                node = q.popleft()\n                level.append(node.val)\n                \n                if node.left:     \n                    q.append(node.left)\n                    \n                if node.right:    \n                    q.append(node.right)\n                    \n            levels.append(level)\n            \n        return levels\n\n\n    return levelOrder(makeTree(0,l))\n"
		]
	],
	"SUDOKU": [
		"2^n",
		[
			5377958385.156009,
			3800647944.6518297,
			16,
			4.078947368421052,
			"def SUDOKU(board={\"generator\":\"\"\"\ndef make_board():\n    m=3\n    import random\n    n = m**2\n    board = [[None for _ in range(n)] for _ in range(n)]\n\n    def search(c=0):\n        i, j = divmod(c, n)\n        i0, j0 = i - i % m, j - j % m \n        numbers = list(range(1, n + 1))\n        random.shuffle(numbers)\n        for x in numbers:\n            if (x not in board[i]                     \n                and all(row[j] != x for row in board) \n                and all(x not in row[j0:j0+m]       \n                        for row in board[i0:i])): \n                board[i][j] = x\n                if c + 1 >= n**2 or search(c + 1):\n                    return board\n        else:\n            board[i][j] = None\n            return None\n\n    x=search()\n    number_of_dots=random.randint(5,15)\n    for i in range(len(x)):\n        for j in range(len(x[0])):\n            if random.randint(0,1)==0 and number_of_dots>0:\n                x[i][j]=\".\"\n                number_of_dots-=1\n            else:\n                x[i][j]=str(x[i][j])\n    return x \"\"\"}):\n    dim = 9\n    horizontal = [set() for _ in range(dim)]\n    vertical = [set() for _ in range(dim)]\n    grid = [[set() for _ in range(3)] for _ in range(3)]\n    \n    for i in range(dim):\n        for j in range(dim):\n            curr = board[i][j]\n            if not curr == \".\":\n                curr = int(curr)\n                horizontal[i].add(curr)\n                vertical[j].add(curr)\n                grid[i // 3][j // 3].add(curr)\n    \n    def search():\n        for i in range(dim):\n            for j in range(dim):\n                curr = board[i][j]\n                if curr == \".\":\n                    possible_set = set([k for k in range(1, dim + 1)])\n                    possible_set -= horizontal[i]\n                    possible_set -= vertical[j]\n                    possible_set -= grid[i // 3][j // 3]\n                    if len(possible_set) == 0: \n                        return False\n                    for potential in possible_set:\n                        board[i][j] = str(potential)\n                        horizontal[i].add(potential)\n                        vertical[j].add(potential)\n                        grid[i // 3][j // 3].add(potential)\n                        valid = search()\n                        if valid:\n                            return True\n                        else:\n                            board[i][j] = \".\"\n                            horizontal[i].remove(potential)\n                            vertical[j].remove(potential)\n                            grid[i // 3][j // 3].remove(potential)\n                    return False\n        return True\n    search()\n    return board\n"
		],
		[
			5757356690.265017,
			3451390807.392293,
			27,
			5.739130434782608,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def can_place(i, j, num):\n            # Check row\n            if any(num == n for n in board[i]):\n                return False\n            \n            # Check col\n            if any(num == n for n in list(zip(*board))[j]):\n                return False\n            \n            # Check box\n            start_row, start_col = (i // 3) * 3, (j // 3) * 3\n            for r in range(start_row, start_row + 3):\n                for c in range(start_col, start_col + 3):\n                    if num == board[r][c]:\n                        return False\n            return True\n        \n        def find_unassigned():\n            for r in range(len(board)):\n                for c in range(len(board[0])):\n                    if board[r][c] == '.':\n                        return r, c\n            return -1, -1\n        \n        def solve():\n            r, c = find_unassigned()\n            \n            if r == -1 and c == -1:\n                return True\n            \n            for num in [str(n) for n in range(1, 10)]:\n                if can_place(r, c, num):\n                    board[r][c] = num\n                    if solve():\n                        return True\n                    board[r][c] = '.'\n            return False\n\t\t\n        if not board:\n            return\n        solve()\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3903335168.1391244,
			19,
			5.739130434782608,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def backtrack(cell_no, board):\n        # Base case: we filled all empty cells\n        if cell_no == 81: \n            return True\n\n        r, c = row_no(cell_no), col_no(cell_no)\n\n        if board[r][c] != empty:\n            return backtrack(cell_no + 1, board)\n\n        for val in sudoku_values:\n            # could_place? Is valid?\n            if val in rows_values[r] or val in cols_values[c] or val in boxs_values[box_no(r, c)]:\n                continue\n\n            # place:\n            board[r][c] = val\n            rows_values[r].add(val)\n            cols_values[c].add(val)\n            boxs_values[box_no(r, c)].add(val)\n\t\t\t\n            # next:\n            if backtrack(cell_no + 1, board):\n                return True\n\n            # remove:\n            board[r][c] = empty\n            rows_values[r].remove(val)\n            cols_values[c].remove(val)\n            boxs_values[box_no(r, c)].remove(val)\n\n        return False\n\n        box_no = lambda r, c: 3 * (r // 3) + c // 3   # Get box from row and column\n\n        col_no = lambda cell_no: cell_no % size  # Get col from cell. no\n\n        row_no = lambda cell_no: cell_no // size # Get row from cell. no\n\n    def solveSudoku(board: List[List[str]]) -> None:\n\n        # 1. Initialization: Store all board values\n        for i in range(size):\n            rows_values[i] = set()\n            cols_values[i] = set()\n            boxs_values[i] = set()\n\n        for r in range(size):\n            for c in range(size):\n                if board[r][c] != empty:\n                    rows_values[r].add(board[r][c])\n                    cols_values[c].add(board[r][c])\n                    boxs_values[box_no(r, c)].add(board[r][c])\n\t\t\n        # 2. Backtrack from cell no: 0\n        backtrack(0, board)\n\n        return board\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3762195581.164404,
			28,
			7.682926829268292,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        ## RC ##\n\t\t## APPROACH : BACKTRACKING ##\n\t\t## Similar to Leetcode : 51. N Queens, 36. Valid Sudoku ##\n\t\t## Time Complexity: O(9^(m * n))\n        ## Space Complexity: O(m*n)\n\t\n        n = len(board)        \n        rows= [set() for _ in range(n)]\n        cols = [set() for _ in range(n)]\n        grids = [set() for _ in range(n)]\n        \n        def add_val_to_board(row, col, val):\n            rows[row].add( val )\n            cols[col].add( val )\n            grids[(row//3)*3+ (col//3)].add( val )\n            board[row][col] = str(val)\n            \n        def remove_val_from_board(row, col, val):\n            rows[row].remove( val )\n            cols[col].remove( val )\n            grids[(row//3)*3+ (col//3)].remove( val )\n            board[row][col] = \".\"\n        \n        def fill_board(row, col, val, board):\n            \n            if( row < 0 or col < 0 or row >= n or col >= n ):\n                return\n            \n            ## GIST, incrementing row and col here\n            while not board[row][col] == '.':\n                col += 1\n                if col == 9: \n                    col, row = 0, row+1\n                if row == 9: \n                    return True\n                \n            for val in range( 1, n+1 ):\n                if( val in rows[row] or val in cols[col] or val in grids[(row//3)*3+ (col//3)]):\n                    continue\n                    \n                add_val_to_board(row, col, val)\n\n                if( fill_board(row, col, val, board) ):\n                    return board\n                \n                remove_val_from_board(row, col, val)\n\n        for i in range(n):\n            for j in range(n):\n                if( not board[i][j] == \".\" ):\n                    add_val_to_board( i, j, int(board[i][j]) )\n        \n        return fill_board(0, 0, board[0][0], board)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3760674960.1333632,
			28,
			7.682926829268292,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        ## RC ##\n\t\t## APPROACH : BACKTRACKING ##\n\t\t## Similar to Leetcode : 51. N Queens, 36. Valid Sudoku ##\n\t\t## Time Complexity: O(9^(m * n))\n        ## Space Complexity: O(m*n)\n\t\n        n = len(board)        \n        rows= [set() for _ in range(n)]\n        cols = [set() for _ in range(n)]\n        grids = [set() for _ in range(n)]\n        \n        def add_val_to_board(row, col, val):\n            rows[row].add( val )\n            cols[col].add( val )\n            grids[(row//3)*3+ (col//3)].add( val )\n            board[row][col] = str(val)\n            \n        def remove_val_from_board(row, col, val):\n            rows[row].remove( val )\n            cols[col].remove( val )\n            grids[(row//3)*3+ (col//3)].remove( val )\n            board[row][col] = \".\"\n        \n        def fill_board(row, col, val, board):\n            \n            if( row < 0 or col < 0 or row >= n or col >= n ):\n                return\n            \n            ## GIST, incrementing row and col here\n            while not board[row][col] == '.':\n                col += 1\n                if col == 9: \n                    col, row = 0, row+1\n                if row == 9: \n                    return True\n                \n            for val in range( 1, n+1 ):\n                if( val in rows[row] or val in cols[col] or val in grids[(row//3)*3+ (col//3)]):\n                    continue\n                    \n                add_val_to_board(row, col, val)\n\n                if( fill_board(row, col, val, board) ):\n                    return board\n                \n                remove_val_from_board(row, col, val)\n\n        for i in range(n):\n            for j in range(n):\n                if( not board[i][j] == \".\" ):\n                    add_val_to_board( i, j, int(board[i][j]) )\n        \n        return fill_board(0, 0, board[0][0], board)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			1.0,
			28,
			7.682926829268292,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        ## RC ##\n\t\t## APPROACH : BACKTRACKING ##\n\t\t## Similar to Leetcode : 51. N Queens, 36. Valid Sudoku ##\n\t\t## Time Complexity: O(9^(m * n))\n        ## Space Complexity: O(m*n)\n\t\n        n = len(board)        \n        rows= [set() for _ in range(n)]\n        cols = [set() for _ in range(n)]\n        grids = [set() for _ in range(n)]\n        \n        def add_val_to_board(row, col, val):\n            rows[row].add( val )\n            cols[col].add( val )\n            grids[(row//3)*3+ (col//3)].add( val )\n            board[row][col] = str(val)\n            \n        def remove_val_from_board(row, col, val):\n            rows[row].remove( val )\n            cols[col].remove( val )\n            grids[(row//3)*3+ (col//3)].remove( val )\n            board[row][col] = \".\"\n        \n        def fill_board(row, col, val, board):\n            \n            if( row < 0 or col < 0 or row >= n or col >= n ):\n                return\n            \n            ## GIST, incrementing row and col here\n            while not board[row][col] == '.':\n                col += 1\n                if col == 9: \n                    col, row = 0, row+1\n                if row == 9: \n                    return True\n                \n            for val in range( 1, n+1 ):\n                if( val in rows[row] or val in cols[col] or val in grids[(row//3)*3+ (col//3)]):\n                    continue\n                    \n                add_val_to_board(row, col, val)\n\n                if( fill_board(row, col, val, board) ):\n                    return board\n                \n                remove_val_from_board(row, col, val)\n\n        for i in range(n):\n            for j in range(n):\n                if( not board[i][j] == \".\" ):\n                    add_val_to_board( i, j, int(board[i][j]) )\n        \n        return fill_board(0, 0, board[0][0], board)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3475832127.8309093,
			21,
			5.03125,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def getCandidates(row, col):\n        board = board\n        \n        candidates = [\"1\", \"2\", \"3\", \"4\", \"5\",\"6\",\"7\",\"8\",\"9\"]\n        \n        # remove nums from rows and columns\n        for i in range(9):\n            if board[row][i] in candidates:\n                candidates.remove(board[row][i])\n            if board[i][col] in candidates:\n                candidates.remove(board[i][col])\n        \n        # remove nums from square\n        col_start = (col // 3) * 3\n        row_start = (row // 3) * 3\n        for i in range(row_start, row_start + 3):\n            for j in range(col_start, col_start + 3):\n                if board[i][j] in candidates:\n                    candidates.remove(board[i][j])\n        \n        return candidates\n\n    def solve(self):\n        board = board\n        open_squares = []\n        \n        # add all open suqares to a list\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == \".\":\n                    open_squares.append((i,j,getCandidates(i,j)))\n        \n        # if there are no more open squares, your board is complete\n        if not open_squares:\n            return True\n        \n        # get the open square with the fewest candidates\n        open_squares.sort(key = lambda x: len(x[2]))\n        a,b,candidates = open_squares[0]\n        \n        # try each candidate, and if the board\n        # can't be recursively solved, reset to \".\"\n        for can in candidates:\n            board[a][b] = can\n            if solve():\n                return True\n            board[a][b] = \".\"\n        \n        # if we've gotten here, we've gone down a bad recursive path\n        # i.e. all candidates have been tried and there are still open\n        # squares, so return False, causing our algo to backtrack. \n        return False\n\n    def solveSudoku(board:List[List[str]])->None:\n        board = board\n        solve()\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3799068104.2694087,
			17,
			4.108695652173913,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(B: List[List[str]]) -> None:\n    \tN, S = range(9), list('123456789')\n    \tR, C, T, V = {i:set() for i in N}, {i:set() for i in N}, {i:set() for i in N}, collections.deque()\n    \tfor i,j in itertools.product(N,N):\n    \t\tif B[i][j] != \".\": R[i].add(B[i][j]), C[j].add(B[i][j]), T[3*(i//3)+j//3].add(B[i][j])\n    \t\telse: V.append((i,j))\n    \tdef dfs():\n    \t\tif not V: return True\n    \t\ti, j, t = V[0][0], V[0][1], 3*(V[0][0]//3)+V[0][1]//3\n    \t\tfor n in S:\n    \t\t\tif n not in R[i]|C[j]|T[t]:\n    \t\t\t\tB[i][j], _ = n, [R[i].add(n), C[j].add(n), T[t].add(n), V.popleft()]\n    \t\t\t\tif dfs(): return True\n    \t\t\t\telse: B[i][j], _ = '.', [R[i].discard(n), C[j].discard(n), T[t].discard(n), V.appendleft((i,j))]\n    \t\treturn False\n    \tdfs()\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			1.0,
			27,
			4.605263157894737,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n\n        # convert str to int, \".\" to 0, \n\t\t# doing this means i cannot do it in-place, i will make board = str(board1) at the end\n        board1 = [[int(val) if val.isdigit() else 0 for val in row ] for row in board]\n\n        def is_valid(i, j, val):\n            # check row\n            if val in board1[i]: return False\n            # check col\n            if val in [board1[r][j] for r in range(9)]: return False\n            # check block (grp)\n            grp_r, grp_c = i//3, j//3\n            for r in range(3):\n                for c in range(3):\n                    if board1[grp_r*3 + r][grp_c*3 + c] == val: return False\n            return True\n\n        def backtrack(pos=0):\n            if pos == len(need): return True # reach the end, no more val left\n            i, j = need[pos] # get the coordinates from need\n            for num in range(1,10):\n                if is_valid(i, j, num):\n                    board1[i][j] = num\n                    if backtrack(pos+1): return True\n            # still not valid, reset val and backtrack\n            board1[i][j] = 0\n\t\t\t\n        # list out those cells == 0\n        need = [(i, j) for i in range(9) for j in range(9) if not board1[i][j]]\n\t\t\n        backtrack()\n\t\t\n        # convert int to str\n        board[:]=[[str(val) for val in row] for row in board1]\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			5943032091.497091,
			1.0,
			22,
			5.711538461538462,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\t\t# Function to get all the possible values for a blank space\n        def getPoss(board, a, b):\n            candidates = []\n            \n            for i in range(1, 10):\n                collision = False\n                for j in range(9):\n                  if board[a][j] == str(i) or\\\n                     board[j][b] == str(i) or\\\n                     board[(a - a%3) + j//3][(b - b%3) + j%3] == str(i):\n                    collision = True\n                    break\n                if not collision:\n                  candidates.append(str(i))\n\n            return candidates\n        \n        def sudoku_solver(board):\n            poten_vals = None\n            bs_avlb = False\n            a, b = -1, -1\n            flag = False\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                  if board[i][j] == '.':\n                    bs_avlb = True\n                    poten_vals = getPoss(board, i, j)\n                    a, b = i, j\n                    flag = True\n                    break\n                if flag:\n                  break\n\n            if not bs_avlb:    # if already all the blank spaces are filled\n                return True\n            \n            for val in poten_vals:\n                board[a][b] = val\n                if sudoku_solver(board):      # ie. using this val is correct and doesn't cause any conflict later\n                  return True\n                board[a][b] = '.'\n            return False       # backtrack\n        \n        sudoku_solver(board)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3393978355.269979,
			19,
			8.222222222222221,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def _boardStats(board: List[List[str]]) -> Tuple[List[int], List[int], List[List[int]],List[Tuple[int, int]]]:\n        \"\"\"\n        :param board:\n        :return: masks of included digits in rows, columns, 3x3\n        and cords of empties values\n        \"\"\"\n        # Define masks that indicate included digits in a row, col and 3x3 quadratic\n        row, col = [0] * 9, [0] * 9\n        cube = [[0] * 3 for _ in range(3)]\n        empties = []  # Cords of empties values('.')\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == \".\":\n                    empties.append((i, j))\n                else:\n                    hashed = 1 << (int(board[i][j]) - 1)  # Generate mask for digit\n                    # Added digit mask by bitwise operation(OR)\n                    row[i] |= hashed\n                    col[j] |= hashed\n                    cube[i // 3][j // 3] |= hashed\n        return row, col, cube, empties\n\n    @staticmethod\n    def _freeDigitMask(row: int, col: int, cube: int) -> int:\n        \"\"\"\n        This method returns masks of free digits.\n        :param row: mask of occupied digits of the row\n        :param col: mask of occupied digits of the columns\n        :param cube: mask of occupied digits of the 3x3 quadratic\n        :return: mask of free digits\n        \"\"\"\n        v = (1 << 9) - 1  # Mask of all possible digits(1-9), i.e, 0b111111111\n        mask = (v - row) & (v - col) & (v - cube)  # Intersection of free digits\n        return mask\n\n    def _solveSudoku(\n        \n        board: List[List[str]],\n        row: List[int],\n        col: List[int],\n        cube: List[List[int]],\n        empties: List[Tuple[int, int]],\n        k: int = 0,\n    ) -> bool:\n        if k >= len(empties):\n            return True  # Found a solution if out of the bounding\n        i, j = empties[k]  # Cords of empty cell\n        mask = _freeDigitMask(row[i], col[j], cube[i // 3][j // 3])\n        if mask == 0:  # If mask equals to 0 then not have a solution\n            return False\n        for shift in range(9):\n            h = 1 << shift\n            if mask & h:  # Check is digit free\n                # Add digit to the masks\n                row[i] |= h\n                col[j] |= h\n                cube[i // 3][j // 3] |= h\n                solved = _solveSudoku(board, row, col, cube, empties, k + 1)\n                if solved:\n                    board[i][j] = str(shift + 1)\n                    return True\n                else:\n                    # Remove digit to the masks\n                    row[i] -= h\n                    col[j] -= h\n                    cube[i // 3][j // 3] -= h\n        return False\n\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        row, col, cube, empties = _boardStats(board)\n        _solveSudoku(board, row, col, cube, empties)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			5547659703.198145,
			3193143420.4271855,
			24,
			4.333333333333333,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        # get a list of (row, col) of empty cells\n        def get_vacant_positions(board):\n            res = []\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        res.append((i, j))\n            return res\n        \n        # get valid candidates that can be filled at (row, col)\n        def get_candidates(board, row, col):\n            res = set()\n            for i in range(1, 10):\n                res.add(str(i))\n              \n            # check row and col\n            for i in range(9):\n                if board[row][i] in res:\n                    res.remove(board[row][i])\n                if board[i][col] in res:\n                    res.remove(board[i][col])\n            \n            # check box\n            sr = (row // 3) * 3\n            sc = (col // 3) * 3\n            for i in range(sr, sr+3):\n                for j in range(sc, sc+3):\n                    if board[i][j] in res:\n                        res.remove(board[i][j])\n            \n            return list(res)\n        \n        # fill using backtracking\n        def solve(board, pos):\n            if len(pos) == 0: # no more vacant positions to fill\n                return True\n            \n            r, c = pos[0]\n            candidates = get_candidates(board, r, c)\n            \n            if len(candidates) == 0: # no candidates, reject this path, backtrack\n                return False\n            \n            for num in candidates:\n                board[r][c] = num\n                if solve(board, pos[1:]):\n                    return True\n                board[r][c] = '.'\n            \n            return False\n\n        positions = get_vacant_positions(board)\n        solve(board, positions)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			1.0,
			26,
			4.615384615384615,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        def solve(r, c):\n            if r == 9 and c == 9:\n                return True\n            if board[r][c] == '.':\n                for num in range(1, 10):\n                    if can_put(r, c, num):\n                        board[r][c] = str(num)\n                        res = solve(*getNext(r, c))\n                        if res:\n                            return True\n                        else:\n                            board[r][c] = '.'\n            else:\n                return solve(*getNext(r, c))\n\n        \n        def can_put(r, c, num):\n            num = str(num)\n            for i in range(len(board)):\n                if board[i][c] == num:\n                    return False\n                \n            for i in range(len(board[0])):\n                if board[r][i] == num:\n                    return False\n                \n            base_r = (r // 3)*3\n            base_c = (c // 3)*3\n            \n            for i in range(base_r, base_r + 3):\n                for j in range(base_c, base_c + 3):\n                    if board[i][j] == num:\n                        return False                    \n            return True\n        \n        \n        def getNext(r, c):\n            if c==8 and r==8:\n                return 9, 9\n            if c == 8:\n                return r+1, 0\n            else:\n                return r, c+1\n            \n            \n        solve(0, 0)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			5581689042.627685,
			3778920067.393615,
			24,
			4.323529411764706,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def getPosNums(board, position, rows, columns, sub_boxes):\n        nums = []\n        row, column = position\n        box_idx = (row//3)*3 + column//3\n        for s in map(str,range(1,10)):\n            if (not s in rows[row]) and (not s in columns[column]) and (not s in sub_boxes[box_idx]):\n                nums.append(s)\n        return nums\n\n    def init(board, emptyPos, rows, columns, sub_boxes):\n        ## fill rows, columns, sub_boxes and emptyPos keys\n        for i in range(9):\n            for j in range(9):\n                tmp = board[i][j]\n                if tmp != '.':\n                    rows[i].add(tmp)\n                    columns[j].add(tmp)\n                    box_idx = (i//3)*3+(j//3)\n                    sub_boxes[box_idx].add(tmp)\n                else:\n                    emptyPos.append((i,j))\n        return\n\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        emptyPos = []       # record empty position(row,column)\n        rows = [set() for i in range(9)]    # record numbers in each rows\n        columns = [set() for i in range(9)] # record numbers in each columns\n        sub_boxes = [set() for i in range(9)]   #record numbers in each sub-boxes\n        \n        init(board, emptyPos, rows, columns, sub_boxes)\n        \n\n        def solve(board, positions):\n            if not positions:       # if all empty positions are filled, it's done\n                return True\n            \n            # we are working on first empty position\n            # find all possible numbers on this position\n            posNums = getPosNums(board, positions[0], rows, columns, sub_boxes)\n            \n            if not posNums:     #if there is no available numbers on this position, it's fail\n                return False\n            \n            row, column = positions[0]\n            box_idx = (row//3)*3 + (column//3)\n            for s in posNums:\n                board[row][column] = s\n                rows[row].add(s)\n                columns[column].add(s)\n                sub_boxes[box_idx].add(s)\n                \n                if solve(board, positions[1:]):\n                    return True\n                \n                rows[row].remove(s)\n                columns[column].remove(s)\n                sub_boxes[box_idx].remove(s)\n                \n            \n            # if all possible numbers don't work, it's fail.            \n            board[row][column] = '.'                    \n            return False        \n        \n        solve(board, emptyPos)\n        return\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			3653944330.177205,
			23,
			6.975,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def init(self):\n        row = []       # to check weather, we have nunber x \n                            # in the specific row, col, and block(grid) \n        col = []\n        block = []\n        for i in range(1, 10):\n            row.append(0)\n            col.append(0)\n            block.append(0)\n\n    def issafe(i , j, bit):\n        if (bit & row[i]) != 0:\n            return False\n        if (bit & col[j]) != 0:\n            return False\n        if (bit & block[(i//3)*3 + j//3]) != 0:\n            return False\n        return True\n\n    def solve(board, boxno):\n        i  = boxno // 9 \n        j  = boxno % 9\n        \n        if boxno == 81:\n            return True\n\n        if board[i][j] != '.':\n            return solve(board, boxno+1)\n        \n        else:\n            for k in range(1, 10):\n                bit  = 1 << k\n                if issafe(i,j,bit):\n                    \n                    toggle(i, j, bit)\n                    board[i][j]= str(k)\n                    \n                    if solve(board, boxno + 1) : \n                        return True\n                    \n                    board[i][j]= '.'\n                    toggle(i, j, bit)\n                    \n        return False            \n\n    def solveSudoku(board:List[List[str]])->None:\n        init()\n        for i in range(0, 9):\n            for j in range(0, 9):\n                if board[i][j] != '.':\n                    toggle(i, j,(1 << int(board[i][j])) )\n                    \n                    \n        solve(board, 0)\n\n                \n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n\n    def toggle(i, j, bit):\n        row[i] = row[i]^bit\n        col[j] = col[j]^bit\n        block[(i//3)*3 + j//3] = block[(i//3)*3 + j//3]^bit\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			1.0,
			23,
			4.9411764705882355,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board:List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        def validNumber(row: int, col:int, n:str)->bool:\n            cols = set(list(zip(*board))[col][:])\n            rows = set(board[row][:])\n            if n in cols: return False\n            if n in rows: return False\n            row0 = row//3\n            col0 = col//3\n            for i in range(row0*3, row0*3 + 3):\n                for j in range(col0*3, col0*3 + 3):\n                    if n == board[i][j]: return False\n            return True\n        \n        def getAllElement()->set:\n            ele = set()\n            for e in board:\n                for k in e:\n                    ele.add(k)\n            return ele\n        \n        def helper()->None:\n            for row in range(0,9):\n                for col in range(0,9):\n                    if board[row][col] == '.':\n                        for n in range(1,10):\n                            if validNumber(row, col, str(n)):\n                                board[row][col] = str(n)\n                                helper()\n                                if \".\" in getAllElement():\n                                    board[row][col]=\".\"\n                        return \n        helper()\n        return \n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			1.0,
			20,
			5.359375,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        spots = [] #empty spots\n        row = [set() for _ in range(9)]\n        col = [set() for _ in range(9)]\n        sub = [set() for _ in range(9)]\n        \n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == \".\": spots.append((i, j))\n                else: \n                    row[i].add(board[i][j])\n                    col[j].add(board[i][j])\n                    sub[i//3*3+j//3].add(board[i][j])\n                    \n        def fn(k):\n            \"\"\"return True if kth spot is filled properly\"\"\"\n            if k == len(spots): return True\n            i, j = spots[k]\n            for n in map(str, range(1, 10)): \n                if n not in row[i] and n not in col[j] and n not in sub[i//3*3+j//3]: \n                    board[i][j] = n\n                    row[i].add(n)\n                    col[j].add(n)\n                    sub[i//3*3+j//3].add(n)\n                    if fn(k+1): return True\n                    else:\n                        row[i].remove(n)\n                        col[j].remove(n)\n                        sub[i//3*3+j//3].remove(n)\n            return False \n        \n        fn(0) #change in place \n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			5401886887.794788,
			3441252184.5640793,
			16,
			4.125,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solve(B, C) -> bool:\n        def values(B, x, y):\n            s = { '1', '2', '3', '4', '5', '6', '7', '8', '9' }\n            sx = (x // 3) * 3\n            sy = (y // 3) * 3\n            for i in range(9):\n                s.discard(B[y][i])\n                s.discard(B[i][x])\n                s.discard(B[sy + i // 3][sx + i % 3])\n            return s\n        if len(C) == 0:\n            return True\n        x, y = C[0]\n        nC = C[1:]\n        for v in values(B, x, y):\n            B[y][x] = v\n            if solve(B, nC):\n                return True\n        B[y][x] = '.'\n        return False\n\n    def solveSudoku(B: List[List[str]]) -> None:\n        C = [(x, y) for y in range(9) for x in range(9) if B[y][x] == '.']\n        solve(B, C)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			1.0,
			1.0,
			17,
			4.108695652173913,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def solveSudoku(B: List[List[str]]) -> None:\n    \tN, S = range(9), list('123456789')\n    \tR, C, T, V = {i:set() for i in N}, {i:set() for i in N}, {i:set() for i in N}, collections.deque()\n    \tfor i,j in itertools.product(N,N):\n    \t\tif B[i][j] != \".\": R[i].add(B[i][j]), C[j].add(B[i][j]), T[3*(i//3)+j//3].add(B[i][j])\n    \t\telse: V.append((i,j))\n    \tdef dfs():\n    \t\tif not V: return True\n    \t\ti, j, t = V[0][0], V[0][1], 3*(V[0][0]//3)+V[0][1]//3\n    \t\tfor n in S:\n    \t\t\tif n not in R[i]|C[j]|T[t]:\n    \t\t\t\tB[i][j], _ = n, [R[i].add(n), C[j].add(n), T[t].add(n), V.popleft()]\n    \t\t\t\tif dfs(): return True\n    \t\t\t\telse: B[i][j], _ = '.', [R[i].discard(n), C[j].discard(n), T[t].discard(n), V.appendleft((i,j))]\n    \t\treturn False\n    \tdfs()\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		],
		[
			5444080764.346943,
			3058750771.9364567,
			19,
			4.333333333333333,
			"def solveSudoku(board:List[List[int]]={\"generator\":\"\"\"\ndef make_board():\nm=3\nimport random\nn = m**2\nboard = [[None for _ in range(n)] for _ in range(n)]\n\ndef search(c=0):\n    i, j = divmod(c, n)\n    i0, j0 = i - i % m, j - j % m \n    numbers = list(range(1, n + 1))\n    random.shuffle(numbers)\n    for x in numbers:\n        if (x not in board[i]                     \n            and all(row[j] != x for row in board) \n            and all(x not in row[j0:j0+m]       \n                    for row in board[i0:i])): \n            board[i][j] = x\n            if c + 1 >= n**2 or search(c + 1):\n                return board\n    else:\n        board[i][j] = None\n        return None\n\nx=search()\nnumber_of_dots=random.randint(5,15)\nfor i in range(len(x)):\n    for j in range(len(x[0])):\n        if random.randint(0,1)==0 and number_of_dots>0:\n            x[i][j]=\".\"\n            number_of_dots-=1\n        else:\n            x[i][j]=str(x[i][j])\nreturn x \"\"\"}):\n    def helper(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j]==\".\":\n                    for num in range(1,10):\n                        num=str(num)\n                        if isvalid(board,i,j,num):\n                            board[i][j]=num\n                            if helper(board):\n                                return True\n                            board[i][j]=\".\"\n                    return False\n        return True\n\n    def isvalid(board,row,col,num):\n        for i in range(9):\n            if board[i][col]==num:\n                return False\n            if board[row][i]==num:\n                return False\n            if board[3*(row//3) + i//3][ 3*(col//3)+i%3]==num:\n                return False\n        return True\n\n    def solveSudoku(board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        return helper(board)\n\n\n    myBoard = [[str(board[i][j]) if board[i][j]!=0 else \".\" for j in range(len(board))] for i in range(len(board))]\n    solveSudoku(myBoard)\n    return [[int(myBoard[i][j]) for j in range(len(board))] for i in range(len(board))]\n"
		]
	]
}
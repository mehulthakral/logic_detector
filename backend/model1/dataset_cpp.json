{
	"SORT": [
		"n",
		[
			5.522568037738943,
			4.573050519273264,
			4,
			22.0,
			"class Solution {\npublic:\n    #include<vector>\n    vector<int> sortArray(vector<int>& nums) {\n        int counts[100001] = {0};\n        // Maps negatives starting from 0\n        for (int &num : nums) {\n            counts[num + 50000]++;\n        }\n        vector<int> result(nums.size(), 0);\n        for (int i = 0, j = 0; i < 100001; i++) {\n            while (counts[i] > 0) {\n                result[j] = i - 50000;\n                j++;\n                counts[i]--;\n            }\n        }\n        return result;\n    }\n};\n"
		],
		[
			5.996443832266359,
			4.762282179025152,
			5,
			24.1579,
			"class Solution {\npublic:\n\tvoid countingsort(vector<int>& nums){\n\t\tint n=nums.size();\n\t\tvector<int> count(100001,0);\n\t\tfor(auto& x:nums){\n\t\t\tcount[x+50000]++;\n\t\t}\n\t\tfor(int i=1;i<count.size();i++){\n\t\t\tcount[i]+=count[i-1];\n\t\t}\n\t\tvector<int> ans(n);\n\t\tfor(auto& v:nums){\n\t\t\tans[count[v+50000]-1]=v;\n\t\t\tcount[v+50000]--;\n\t\t}\n\t\tnums=ans;\n\t}\n\tvector<int> sortArray(vector<int>& nums) {\n\t\tcountingsort(nums);\n\t\treturn nums;\n\t}\n};"
		],
		[
			5.653412927279669,
			4.762361941659144,
			5,
			45.2647,
			"class Solution {\npublic:\nvector<int> sortArray(vector<int>& arr) {\n        int max = *max_element(arr.begin(), arr.end()); \n        int min = *min_element(arr.begin(), arr.end()); \n        int range = max - min + 1; \n\n        vector<int> count(range), output(arr.size()); \n        for(int i=0; i<arr.size(); i++) count[arr[i]-min]++; \n\n        for(int i = 1; i<count.size(); i++) count[i] += count[i-1]; \n\n        for(int i = arr.size()-1; i >= 0; i--) {  \n             output[count[arr[i]-min] -1] = arr[i];  \n             count[arr[i]-min]--;  \n        } \n        for(int i=0; i < arr.size(); i++) \n                arr[i] = output[i]; \n        return arr;\n   }\n};"
		],
		[
			7.1253996124780965,
			5.506552659797817,
			11,
			63.65,
			"class Solution {\npublic:\n\tvoid merge(vector<int>& nums_left, vector<int>& nums_right, vector<int>& nums)\n\t{\n\t\tauto left = nums_left.begin();\n\t\tauto const left_end = nums_left.end();\n\n\t\tauto right = nums_right.begin();\n\t\tauto const right_end = nums_right.end();\n\n\t\tauto target = nums.begin();\n\t\tauto const target_end = nums.end();\n\n\t\twhile (target != target_end)\n\t\t{\n\t\t\twhile (left != left_end && (right == right_end || *left <= *right))\n\t\t\t{\n\t\t\t\t*target = *left;\n\t\t\t\t++left;\n\t\t\t\t++target;\n\t\t\t}\n\t\t\twhile (right != right_end && (left == left_end || *right < *left))\n\t\t\t{\n\t\t\t\t*target = *right;\n\t\t\t\t++right;\n\t\t\t\t++target;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid merge_sort(vector<int>& nums)\n\t{\n\t\tsize_t const size = nums.size();\n\t\tif (size <= 1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tauto const left = nums.begin();\n\t\tauto const right = nums.end();\n\t\tauto const middle = left + size / 2;\n\n\t\tvector<int> nums_left{ left, middle };\n\t\tmerge_sort(nums_left);\n\n\t\tvector<int> nums_right{ middle, right };\n\t\tmerge_sort(nums_right);\n\n\t\tmerge(nums_left, nums_right, nums);\n\t}\n\n\tvector<int> sortArray(vector<int>& nums)\n\t{\n\t\tmerge_sort(nums);\n\t\treturn nums;\n\t}\n};"
		],
		[
			6.956868806424159,
			5.675595226935674,
			16,
			39.4722,
			"class Solution {\npublic:\n    // Merges two arrays by sorting \n    void mergeArray(vector<int> &A, int left, int mid, int right) {\n        // Create temp arrays\n        int Lsize = mid - left + 1;\n        int Rsize = right - mid;\n        vector<int> L(Lsize);\n        vector<int> R(Rsize);\n        // Copy unsorted data from A to temp arrays\n        for (int i = 0; i < Lsize; i++) {\n            L[i] = A[left + i];\n        }\n        for (int j = 0; j < Rsize; j++) {\n            R[j] = A[mid + j + 1];\n        }\n        // Merge temp arrays back into A\n        int l = 0; // Left Temp Array\n        int r = 0; // Right Temp Array\n        int k; // Merged Original Array\n        for (k = left; k <= right && l < Lsize && r < Rsize; k++) {\n            if (L[l] <= R[r]) {\n                A[k] = L[l];\n                l++;\n            } else {\n                A[k] = R[r];\n                r++;\n            }\n        }\n        while (k <= r && l < Lsize && r < Rsize) {\n            if (L[l] <= R[r]) {\n                A[k] = L[l];\n                l++;\n            } else {\n                A[k] = R[r];\n                r++;\n            }\n            k++;\n        }\n        // Copy If Left Temp has any remaining elements\n        while (l < Lsize) {\n            A[k] = L[l];\n            l++;\n            k++;\n        }\n        // Copy If Right Temp has any remaining elements\n        while (r < Rsize) {\n            A[k] = R[r];\n            r++;\n            k++;\n        }\n    }\n\n    // Merge sort\n    void mergeSort(vector<int> &A, int left, int right) {\n        if (left < right) {\n            int mid = (left + right) / 2;\n            // Left Sub-Array\n            mergeSort(A, left, mid);\n            // Right Sub-Array\n            mergeSort(A, mid + 1, right);\n            // Merge Sub-Arrays\n            mergeArray(A, left, mid, right);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n"
		],
		[
			7.1522051231642685,
			5.052458019610304,
			3,
			14.0,
			"class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        int n=nums.size();\n        \n        priority_queue<int,vector<int>,greater<int>>minh;\n        vector<int>v;\n        \n        for(int i=0;i<n;i++){\n            minh.push(nums[i]);\n        }\n        for(int j=0;j<n;j++){\n              v.push_back(minh.top());\n            minh.pop();\n            \n        }\n        return v;\n    }\n};\n"
		],
		[
			5.750378187231969,
			4.573050519273264,
			4,
			19.5,
			"class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        vector<int> countArr(100001, 0);\n        // Count Each Element\n        for (int num : nums) {\n            countArr[50000 + num]++;\n        }\n        // Add previous counts \n        for (int i = 1; i < 100001; i++) {\n            countArr[i] += countArr[i - 1];\n        }\n        // Create n places array\n        vector<int> placesArr(nums.size(), 0);\n        for (int &num : nums) {\n            placesArr[countArr[50000 + num] - 1] = num;\n            countArr[50000 + num]--;\n        }\n        return placesArr;\n    }\n};\n"
		],
		[
			13.531191483771044,
			4.573050519273264,
			9,
			48.0789,
			"\nclass Solution {\npublic:\n    void ans(vector<int>& array,int l,int r){\n        if(l>=r)\n            return;\n        int leftidx=l+1;\n        int rightidx=r;\n        int pivotidx=l;\n        while(rightidx>=leftidx){\n            if(array[leftidx]>array[pivotidx]&&array[rightidx]<array[pivotidx])\n                swap(array[leftidx],array[rightidx]);\n            if(array[leftidx]<=array[pivotidx])\n                leftidx++;\n            if(array[rightidx]>=array[pivotidx])\n                rightidx--;\n        }\n        swap(array[rightidx],array[pivotidx]);\n        bool leftsubarraysmall=rightidx-1-l<r-(rightidx+1);\n        if(leftsubarraysmall){\n            ans(array,l,rightidx-1);\n            ans(array,rightidx+1,r);\n        }else{\n            ans(array,rightidx+1,r);\n            ans(array,l,rightidx-1);\n        }\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        ans(nums,0,nums.size()-1);\n        return nums;\n }\n};\n"
		],
		[
			12.134751543214735,
			4.573050519273264,
			6,
			35.4375,
			"class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        quickSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n    void quickSort(vector<int>& nums, int left, int right){\n        if(left < right){\n            // to make pivot rightmost element random\n            int random_idx = left + (rand() % (right-left));\n            swap(nums[random_idx],nums[right]);\n            \n            int pivot = left;\n            for(int j = left; j <= right - 1 ; j++){\n                if(nums[j] < nums[right]){\n                    swap(nums[pivot++], nums[j]);\n                }\n            }\n            swap(nums[pivot], nums[right]);\n            quickSort(nums, left, pivot-1);\n            quickSort(nums, pivot+1, right);\n        }\n    }\n    void swap(int& i, int& j){\n        int temp = i;\n        i = j;\n        j = temp;\n    }\n};\n"
		],
		[
			13.65177141049526,
			4.573050519273264,
			7,
			36.4286,
			"class Solution {\npublic:\n    void swap(int &a, int &b)\n    {\n        int t=a;\n        a = b;\n        b = t;\n    }\n    int partition(vector<int>& nums, int low, int high)\n    {\n        int i=low-1, pivot=nums[high];\n        for(int j=low; j<high; j++)\n        {\n            if(nums[j]<=pivot) \n            {\n                i++;\n                swap(nums[i], nums[j]);\n            }\n        }\n        swap(nums[i+1], nums[high]);\n        return i+1;\n    }\n    void quickSort(vector<int>& nums, int low, int high)\n    {\n        if(low<high)\n        {\n            int pivot=partition(nums, low, high);\n            quickSort(nums, low, pivot-1);\n            quickSort(nums, pivot+1, high);\n        }\n    }\n    vector<int> sortArray(vector<int>& nums) \n    {\n        int n=nums.size(), low=0, high=n-1;\n        quickSort(nums, low, high);\n        return nums;\n    }\n};\n"
		],
		[
			7.114215320199268,
			5.624817632428762,
			10,
			57.75,
			"class Solution {\npublic:\n    void merge(vector<int>& nums, int low, int mid, int high)\n    {\n        vector<int> t(high-low+1);\n        int i=0, j=low, k=mid+1; \n        while(j<=mid && k<=high)\n        {\n            if(nums[j]<=nums[k])\n            {\n                t[i] = nums[j];\n                j++;\n            }\n            else \n            {\n                t[i] = nums[k];\n                k++;\n            }\n            i++;\n        }\n        \n            while(j<=mid) t[i] = nums[j], i++, j++;\n            while(k<=high) t[i] = nums[k], i++, k++;\n            for(int i=low; i<=high; i++)\n            {\n                nums[i] = t[i-low];\n            }\n    }\n    void mergeSort(vector<int>& nums, int low, int high)\n    {\n        if(low<high) \n        {\n            int mid=low+(high-low)/2;\n            mergeSort(nums, low, mid);\n            mergeSort(nums, mid+1, high);\n            merge(nums, low, mid, high);\n        }\n    }\n    vector<int> sortArray(vector<int>& nums) \n    {\n        int n=nums.size();\n        int low=0, high=n-1;\n        mergeSort(nums, low, high);\n        return nums;\n    }\n};\n"
		],
		[
			6.566150991606108,
			4.573050519273264,
			1,
			7.5,
			"class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n       sort(nums.begin(), nums.end());\n       return nums; \n    }\n};\n"
		]
	],
	"CYCLE_GRAPH": [
		"n^2",
		[
			19.346945287379015,
			18.20530475528977,
			10,
			29.58,
			"class Solution {\npublic:\n    #include<vector>\n    vector<bool> vist; //int d=0;\n    bool dfs(int p,vector<bool> &vis,vector<int> adj[]){\n        //d++; cout<<d<<endl;\n        if(vis[p]) return false;\n        if(vist[p]) return true;\n        vis[p]=true; vist[p]=true;\n        for(int g:adj[p]){\n            if(!dfs(g,vis,adj)) return false;\n        }\n        vis[p]=false;\n        return true;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<int> adj[numCourses]; vector<bool> vis(numCourses,false), _vis(numCourses,false);\n        vist=_vis;\n        for(auto g:prerequisites) adj[g[1]].push_back(g[0]);\n        for(int i=0;i<numCourses;i++){\n            if(vist[i]) continue;\n            if(!dfs(i,vis,adj)) return false;\n        }\n        return true;\n    }\n};\n"
		],
		[
			19.650367188420695,
			17.468007681684202,
			12,
			35.4667,
			"class Solution {\npublic: \n    \n    vector<vector<int>> createList(vector<vector<int>> &prerequisites, int numCourses) { \n        \n        vector<vector<int>> adjList(numCourses); \n        \n        for(int i = 0; i < prerequisites.size(); i++) { \n            \n            adjList[prerequisites[i][0]].push_back(prerequisites[i][1]); \n            \n        } \n        \n        return adjList;\n    }\n    \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {  \n        \n        int count = 0;\n        \n        vector<vector<int>> adjList = createList(prerequisites, numCourses); \n        \n        unordered_map<int, int> indegree;\n        unordered_map<int, bool> visited; \n        \n        for(int i = 0; i < numCourses; i++) { \n            indegree[i] = 0;\n        } \n        \n        for(int i = 0; i < prerequisites.size(); i++) {  \n            indegree[prerequisites[i][1]]++;\n        } \n        \n        queue<int> q; \n\n        for(auto i : indegree) { \n            \n            if(i.second == 0) { \n                q.push(i.first); \n                visited[i.first] = true;  \n                count++;\n            }\n        }\n        \n        if(q.empty()) { \n            return false;\n        } \n        \n        else { \n            \n            while(!q.empty()) { \n            \n                for(int i : adjList[q.front()]) { \n                \n                    indegree[i]--; \n                \n                    if(!visited[i] && indegree[i] == 0) { \n                        q.push(i); \n                        visited[i] = true; \n                        count++;\n                    } \n                }  \n                q.pop();\n            } \n        } \n        \n        return count == numCourses;\n    }\n};\n"
		],
		[
			18.892155578316704,
			17.48069866579368,
			10,
			27.8182,
			"class Solution {\npublic:\n    bool CycleUtil(vector<int> Graph[], int start, vector<bool>& visited, vector<bool>& recSt){\n        visited[start] = true;\n        recSt[start] = true;\n        \n        for(int v : Graph[start]){\n            if(! visited[v] && CycleUtil(Graph, v, visited, recSt)) \n                return true;\n            else if(recSt[v]) return true;\n        }\n    recSt[start] = false;\n    return false;\n}\n    \n    bool canFinish(int n, vector<vector<int>>& preReq) {\n        vector<int> Graph[n];\n        \n        //Make a Graph\n        for(int i = 0; i < preReq.size(); i++){\n            Graph[preReq[i][0]].push_back(preReq[i][1]);\n        }\n        \n        //Check for cycle - if exist then taking all class not possible\n        vector<bool> visited, all_ve;\n        visited.assign(n, false);\n        all_ve.assign(n, false);\n        for(int i = 0; i < n; i++){\n            if(! all_ve[i])\n                if(CycleUtil(Graph, i,visited, all_ve)) return false; \n        }\n        return true;\n    }\n};\n"
		],
		[
			8.446965140349759,
			17.483685838017184,
			10,
			27.6556,
			"class Solution {\npublic:\n    bool dfs(int node, vector<vector<int>>& g, vector<bool>& visited, vector<bool>& recStack)\n    {\n        visited[node] = true;\n        recStack[node] = true; //Activate node\n        \n        for(int i=0; i<g[node].size(); i++)\n        {\n            int adj = g[node][i];\n            \n            if(recStack[adj] == true)  //node is activated\n                return true;\n            \n            if(visited[adj] == false) //if child is unvisited\n               if(dfs(adj, g, visited, recStack))\n                return true;\n        }\n            \n        \n        //post-call -> all children have been visited\n        recStack[node] = false; //node is deactivated\n        return false;\n    }\n    \n    bool canFinish(int n, vector<vector<int>>& pre) \n    {\n        vector<vector<int>> graph(n);\n        vector<int> res;\n        vector<bool> visited(n, false);\n        vector<bool> recStack(n, false);        \n        \n        for(int i=0; i<pre.size(); i++)\n        {\n            int dep = pre[i][0];\n            int indep = pre[i][1];\n            \n            graph[indep].push_back(dep);\n        }\n        \n        for(int i=0; i<n; i++) //for disconnected graph\n        {\n            if(visited[i] == false)\n            {\n                if(dfs(i, graph, visited, recStack)) //cycle exists\n                    return false; //courses cannot be taken up\n            }\n        }        \n        \n        return true;\n        \n    }\n};\n\n"
		],
		[
			17.650176021338265,
			17.48156696211649,
			10,
			36.9524,
			"class Solution {\npublic:\n    bool dfs(vector<int> nums[],vector<bool> &passedThrough,vector<bool> visited,int node)\n    {\n        if(visited[node] == true)\n        return false;\n        \n        visited[node] = true;\n\n        for(int i=0;i<nums[node].size();i++)\n        {\n            if(passedThrough[nums[node][i]] == false)\n            {\n                if(dfs(nums,passedThrough,visited,nums[node][i])==false)\n                return false;\n            }\n        }\n        passedThrough[node] = true;\n        return true;\n    }\n    \n    bool canFinish(int courses, vector<vector<int>>& pre) {\n        \n        vector<bool> passedThrough(courses,false);\n        vector<bool> visited(courses,false);\n        \n        int n= pre.size();\n        vector<int> nums[courses];\n        \n        for( int i=0;i<n;i++)\n        nums[pre[i][0]].push_back(pre[i][1]);\n\n        for(int i=0;i<courses;i++)\n        {\n            if(passedThrough[i] == false)\n            {\n                if(dfs(nums,passedThrough,visited,i ) == false)\n                return false;\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			8.646125742911709,
			18.205897826181538,
			10,
			19.987,
			"class Solution {\nprivate:\n    //2->visited and processing; 1->visited and processed; 0->unvisited\n    bool isCyclic(int v, vector<int>& vis, vector<vector<int>>& adj){\n        vis[v] = 2;\n        for(auto x : adj[v]) {\n            if(vis[x] == 2)\n                return true;\n            else if(vis[x] == 0 && isCyclic(x, vis, adj))\n                return true;\n        }\n        //if we reach here that means we've traversed all the vertices starting from vertex v and havent found a cycle so we mark the current vertex and visited and return false\n        vis[v] = 1;\n        return false;\n    }\npublic:\n    bool canFinish(int n, vector<vector<int>>& pre) {\n        //make adjacency list\n        vector<vector<int>> adj(n);\n        for(auto x: pre) \n            adj[x[0]].push_back(x[1]);\n        \n        vector<int> visited(n, 0); //graph coloring\n        for(int i = 0; i < n; ++i) { //takes care of disjoint graphs and tries all nodes to find possible cycles\n            if(visited[i] == 0) { //dfs only of current node is not visited, if it is visited that means we've tried the possible cycles(if there might be any) form the current node and have marked it processed.\n                if(isCyclic(i, visited, adj))\n                    return false;\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			18.73672026449063,
			18.204681003922786,
			9,
			23.4868,
			"class Solution {\npublic:\n    bool isCyclic(int v, vector<bool> &vis, vector<bool>&rec, vector<vector<int>>&Adj){\n        vis[v] = true;\n        rec[v] = true;\n        for (auto x: Adj[v]){\n            if (rec[x])\n                return true; // means we have a back edge here\n            else if (!vis[x] and isCyclic(x, vis,rec, Adj))\n                return true; // means we found a back edge in one of the descendants of this node\n        }\n        rec[v] = false;\n        return false;\n    }\n    bool canFinish(int n, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> Adj(n);\n        for (auto x: prerequisites){\n            Adj[x[0]].push_back(x[1]);\n        }\n        vector<bool> visited(n,false);\n        vector<bool> recStack(n,false);\n        for (int i =0; i < n; i++){\n            if (!visited[i])\n                if (isCyclic(i,visited,recStack, Adj))\n                    return false;\n        }\n        return true;\n    }\n};"
		],
		[
			18.266407008760698,
			17.482414376751773,
			8,
			23.2791,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {       \n        vector<vector<int>> vv_graph(numCourses);   //Directed graph representing node relations specified by only prerequisites. \n                                                        //(u,v)->(u is prereq/parent and v is req/child).\n        unordered_map<int, int> um_inFq;            //Map of nodes and their number of incoming edges\n        unordered_set<int> us_noIn;                 //Set of nodes that have no incoming edges\n        int count = 0;                              //Number of nodes added to topological ordering so far\n        \n        //Creates the graph. Initializes map.\n        for (auto& pReq : prerequisites) {\n            int chi = pReq[0], par = pReq[1];\n            vv_graph[par].push_back(chi);\n            um_inFq[chi] += 1;\n            if (um_inFq.count(par) == 0) {\n                um_inFq[par] = 0;\n            } \n        }\n        \n        //Adds nodes to the set\n        for (auto& node : um_inFq) {\n            if (node.second == 0) {\n                us_noIn.insert(node.first);\n            }\n        }\n        \n        //Take node with no incoming edges from set. Update incoming edge values of adjacent nodes by updating map.\n        while (!us_noIn.empty()) {\n            int curr = *(us_noIn.begin());\n            us_noIn.erase(us_noIn.begin());\n            for (auto& node : vv_graph[curr]) {\n                if (--um_inFq[node] == 0) {\n                    us_noIn.insert(node);\n                }\n            }\n            count++;\n        }\n        \n        return count == um_inFq.size();   //For true, # of Nodes in ordering must equal # of nodes depicted by prerequisites\n    }\nprivate:\n    \n};\n"
		],
		[
			15.836098834330297,
			17.465017068616746,
			11,
			21.3462,
			"class Solution {\npublic:\n\t//if course is done, similar to visited\n    map<int, int> done;\n\t//if we are still visiting/studying a course and its subcourses/recursion stack\n\tmap<int, int> pending;\n\t//our graph\n    map<int, vector<int>> mp;\n    \n    bool iscyclicutil(int v){\n\t\t//if course is not visited yet\n        if(!done[v])\n        {\n            done[v]=1;\n            pending[v]=1;\n            for(auto j : mp[v])\n\t\t\t{   //if a subcourse is not visited yet but the subcourse has a cycle then return true that \n\t\t\t    //there is a cycle\n                if(!done[j]&&iscyclicutil(j))\n                    return true;\n\t\t\t\t//if the subcourse itself is in pending state that means a cycle exists\n                else\n                    if(pending[j])\n                        return true;\n            }\n        }\n\t\t//if the course and all its courses couldnt return true for cycle it means we are done studying that course\n\t\t//remove it from pending list\n        pending[v]=0;\n        return false;\n    }\n    //function to check for cycles in the graph, if a cycle exists that means a superior course \n\t//is dependent on junior course, where we should return false\n    bool iscyclic(){\n        for(auto i : mp)\n            if(iscyclicutil(i.first))\n                return true;\n        \n        return false;\n    }\n    \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        //making adjacency list\n        int nedges=prerequisites.size();\n        for(int i=0;i<nedges;i++)\n        {\n            mp[prerequisites[i][1]].push_back(prerequisites[i][0]);\n        }\n        //detecting a cycle, if exists, that means, iscyclic is true, return false\n        return !iscyclic();\n    }\n};\n"
		],
		[
			16.641207129779144,
			17.469690167065455,
			7,
			25.0833,
			"// https://leetcode.com/problems/course-schedule/\n\n/*\n    I have multiple solution for this questions. I am discussing all solutions.\n\n    Solution 1: Detect A Cycle in directed Graph.\n\n    How do we think, this solution ?\n    If you plot all prerequiste, you will see a graph pointed toward a vertex. As, it is pointed, means it is directed.\n    Now if we got a cycle in directed graph. What does this implies? \n\n    Yes, It implies, we need to take course 1 for completing course 2 and need course 2 to complete course 1.\n    Which is'nt possible. So as long as we find a cycle we will return false. if there is no cycle, then return true.\n    I have written code already to detect a cycle. So please check 04_Detect_cycle_in_a_directed_graph.cpp in same folder.\n\n********************************************************************************************************************************\n\n    Solution 2: Topological Sorting\n    I will discuss topological sorting in new file. You can think how topological sorting can apply here.(As an exercise)\n\n*********************************************************************************************************************************\n\n    Solution 3: Kahn's Algorithm\n    If we complete all courses then return true else return false. Check comments (It is not most optimized solution but it is shortest)\n\n*/\n\nclass Solution\n{\npublic:\n    bool canFinish(int n, vector<vector<int>> &prerequisites)\n    {\n        // G is used to build a graph\n        vector<vector<int>> G(n);\n\n        //Degree will count prerequisites, bfs will store all completed courses.\n        vector<int> degree(n, 0), bfs;\n\n        // Build Graph (Add edges) & store how much courses are prerequisites to complete a course.\n        for (auto &e : prerequisites) \n            G[e[1]].push_back(e[0]), degree[e[0]]++;\n\n        // If we didnt need any prerequisites then directly add to bfs.\n        for (int i = 0; i < n; ++i)\n        {\n            if (!degree[i])\n                bfs.push_back(i);\n        }\n\n        for (int i = 0; i < bfs.size(); ++i)\n        {\n            // i'th course is done\n            for (int j : G[bfs[i]])\n            {\n                // If all prerequisites are done then add it to bfs\n                if (--degree[j] == 0)\n                    bfs.push_back(j);\n            }\n        }\n\n        //Now check does all courses completed or not.\n        return bfs.size() == n;\n    }\n};\n"
		],
		[
			8.541917370294142,
			18.205287248192164,
			9,
			25.1429,
			"class Solution {\npublic:bool iscycle(vector<int> adj[],vector<int> &vis,int id){\n        if(vis[id]==1)\n            return true;\n        if(vis[id]==0){\n            vis[id]=1;\n            for(auto edge : adj[id]){\n                if(iscycle(adj,vis,edge))\n                    return true;\n            }\n        }\n        vis[id] = 2;\n        return false;\n    }\n    bool canFinish(int n, vector<vector<int>>& pre) {\n        vector<int> adj[n];\n        for(auto edge : pre)\n            adj[edge[1]].push_back(edge[0]);\n        vector<int> vis(n,0);\n        \n        for(int i=0;i<n;i++){\n            if(iscycle(adj,vis,i))\n                return false;\n        }\n        return true;\n    }\n};"
		],
		[
			8.83019513468258,
			18.2069606536408,
			7,
			25.8261,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> adj(numCourses);\n        vector<int> indegrees(numCourses,0);\n        \n        queue<int>Q;\n        \n        for(auto e : prerequisites){\n            adj[e[1]].push_back(e[0]);\n            indegrees[e[0]]++;\n        }\n        \n        for(int i=0; i < numCourses; i++ ){\n            if(indegrees[i] == 0){\n                Q.push(i);\n            }\n        }\n        \n        int count =0;\n        \n        while(!Q.empty()){\n            \n            int ele = Q.front();\n            Q.pop();\n            count++;\n            \n            for(auto e : adj[ele]){\n                indegrees[e]--;\n                if(indegrees[e] == 0){\n                    Q.push(e);\n                }\n            }\n        }\n        return count == numCourses;\n    }\n};\n"
		],
		[
			17.417112618848847,
			17.480639344028447,
			12,
			23.3846,
			"class Solution {\npublic:\n    bool cycle = false;\n    map<int,vector<int>>m;\n    map<int,bool>vis;\n    void dfs(int root)\n    {\n        if(cycle)\n            return;\n        vis[root] =true;\n        for(auto i:m[root] )\n        {\n            if(m[i].size()!=0&&vis[i])\n            {\n               cycle = true;\n               return;\n            }\n             dfs(i); \n             m[root].pop_back();\n        }\n    }\n    bool dfsUtil(int n)\n    {\n        if(n==0)\n            return true;\n        for(int i=0;i<n;i++)\n        {\n            if(!vis[i]&&!cycle)\n                dfs(i);\n        }\n        return cycle;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        for(int i=0;i<prerequisites.size();i++)\n        {\n            m[prerequisites[i][0]].push_back(prerequisites[i][1]);\n        }\n        return !dfsUtil(numCourses);\n    }\n};\n"
		],
		[
			19.840851879454092,
			18.129139183948087,
			13,
			39.9655,
			"class Solution {\npublic:bool dfs(vector<int> adj[],vector<bool> &visited,vector<bool> &current,\n         int currentNode){\n    visited[currentNode]=true;\n    current[currentNode]=true;\n    for(int i=0;i<adj[currentNode].size();i++){\n        int node=adj[currentNode][i];\n        if(visited[node]==false && current[node]==false)\n        {\n            if(dfs(adj,visited,current,node))\n                return true;\n        }\n        else if(current[node]==true)\n            return true;\n    }\n    current[currentNode]=false;\n    return false;\n}\n                \n         \nbool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n    int n=prerequisites.size();\n    if(n==0)\n        return true;\n    int m=prerequisites[0].size();\n    \n    //adjacency list preparation\n    vector<int> adj[numCourses];\n    for(int i=0;i<n;i++){\n        int x=prerequisites[i][0];\n        for(int j=1;j<m;j++)\n            adj[x].push_back(prerequisites[i][j]);\n    }\n    //doing dfs\n    vector<bool> visited(numCourses,false);\n    vector<bool> current(numCourses,false);\n    for(int i=0;i<visited.size();i++){\n        if(visited[i]==false){\n            if(dfs(adj,visited,current,i)==true)\n                return false;\n        }\n    }\n    return true;\n}\n};"
		],
		[
			8.880369276321789,
			17.488546431397143,
			9,
			22.4615,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses, vector<int>());\n        vector<int> edgeCounts(numCourses, 0); // {node, incoming edges}\n        queue<int> todo; // nodes that has no incoming edges, meaning starting points\n        // Build the adjacency list\n        for (vector<int> &p : prerequisites) {\n            graph[p[1]].push_back(p[0]);\n            // Count the incoming edges\n            edgeCounts[p[0]]++;\n        }\n        // Find the nodes/roots that has no incoming edges\n        for (int node = 0; node < edgeCounts.size(); node++) {\n            // If a nodes has no incoming edge, this is a root\n            if (edgeCounts[node] == 0) {\n                todo.push(node);\n            }\n        }\n        // If there is no any root node\n        if (todo.empty()) {\n            return false;\n        }\n        // Start BFS\n        int processedCourseCount = 0; // Num of roots at the beginning\n        while (!todo.empty()) {\n            int cur = todo.front();\n            todo.pop();\n            // If we hit to 0 edge count, we don't need that node anymore\n            if (edgeCounts[cur] == 0) {\n                processedCourseCount++;\n            } \n            for (int &neighbor : graph[cur]) {\n                // Decrease our edge count\n                edgeCounts[neighbor]--;\n                if (edgeCounts[neighbor] == 0) {\n                    todo.push(neighbor);\n                }\n            }\n        }\n        return (processedCourseCount == numCourses);\n    }\n};"
		],
		[
			8.336190356652494,
			17.48419601058825,
			9,
			28.2162,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses, vector<int>());\n        vector<bool> seen(numCourses, false), cycle(numCourses, false);\n        // Build the adjacency list\n        for (vector<int> &p : prerequisites) {\n            graph[p[1]].push_back(p[0]);\n        }\n        // Start DFS for each Node\n        stack<int> topoSort;\n        bool hasCycle = false;\n        for (int node = 0; node < graph.size(); node++) {\n            if (seen[node] == false) {\n                dfs(graph, node, seen, topoSort, hasCycle, cycle);\n            }\n        }\n        int size = topoSort.size();\n        return (numCourses == size && !hasCycle);\n    }\n    \n    void dfs(vector<vector<int>> &graph, int cur, vector<bool> &seen, stack<int> &topoSort, bool &hasCycle, vector<bool> &cycle) {\n        seen[cur] = true;\n        cycle[cur] = true;\n        for (int &child : graph[cur]) {\n            if (seen[child] == false) {\n                dfs(graph, child, seen, topoSort, hasCycle, cycle);\n            }\n            else if (cycle[child] == true) {\n                hasCycle = true;\n                return;\n            }\n        }\n        cycle[cur] = false; // This is for cycle detection\n        topoSort.push(cur);\n    }\n};"
		],
		[
			14.465076952613916,
			17.48310127749224,
			12,
			38.88,
			"class Solution {\npublic:\n\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int> > children(numCourses);\n        vector<int> dependancy (numCourses, 0);\n        for(int i=0; i<prerequisites.size(); i++){\n            children[prerequisites[i][1]].push_back(prerequisites[i][0]);\n            dependancy[prerequisites[i][0]] ++;\n        }\n                  \n        \n        vector<int> visited (numCourses, 0);\n        queue<int> to_process;\n        \n        for(int i=0; i<numCourses; i++){\n            if(dependancy[i]==0){\n                to_process.push(i);\n                visited[i] = 1;\n            }\n        }\n        \n        \n        \n        while(to_process.size()>0){\n            while(to_process.size()>0){\n                int c = to_process.front();\n                for(int child: children[c]){\n                    dependancy[child] --;\n                }\n                visited[c] = 1;\n                to_process.pop();\n            }\n            \n            for(int i=0; i<numCourses; i++){\n                if(dependancy[i]==0 && visited[i]==0){\n                    to_process.push(i);\n                    visited[i] = 1;\n                }\n            }\n            \n        }\n        \n        for(int i=0; i<numCourses; i++){\n            if(visited[i]==0) return false;\n        }\n        \n        return true;\n    }\n};\n"
		],
		[
			8.882705095054217,
			18.20225278272677,
			7,
			23.4231,
			"class Solution {\npublic:\n    //TOPOLOGICAL SORT USING BFS\n    bool canFinish(int n, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(n,vector<int>());\n        queue<int> q;\n        vector<int> in_degree(n,0);\n        vector<int> ans;\n        //Making graph edge is unidirictional(p[1] --> p[0]) \n        for(auto p: prerequisites) {\n            graph[p[1]].push_back(p[0]);\n            ++in_degree[p[0]];\n        }\n        //Push all the elements in the queue which has 0 in_degree\n        for(int i=0;i<n;++i) {\n            if(in_degree[i]==0) {\n                q.push(i);\n            }\n        }\n        //if we remove the parent of a node then its in_degree will decreases by 1 unit\n        while(!q.empty()) {\n            int cur=q.front();\n            q.pop();\n            ans.push_back(cur);\n            for(int child: graph[cur]) {\n                --in_degree[child];\n                if(in_degree[child]==0) {\n                    q.push(child);\n                }\n            }\n        }\n        return ans.size()==n;\n    }\n};\n"
		],
		[
			9.080469233032286,
			18.176821999526325,
			8,
			27.3485,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        unordered_map<int, vector<int> > graph;\n        unordered_map<int, int> indegree;\n        int child, parent, i;\n        queue<int> source;\n        vector<int> result, children;\n        \n        // init graph\n        for(i=0; i<numCourses; i++) {\n            indegree[i] = 0;\n            graph[i] = vector<int>();\n        }\n        \n        // populate graph\n        for(auto req: prerequisites) {\n            parent = req[1];\n            child = req[0];\n            indegree[child]++;\n            graph[parent].push_back(child);\n        }\n        \n        // populate source\n        for(auto entry: indegree) {\n            if(entry.second == 0) {\n                source.push(entry.first);\n            }\n        }\n        \n        // bfs\n        while(source.size()) {\n            parent = source.front();\n            source.pop();\n            result.push_back(parent);\n            children = graph[parent];\n            for(auto child: children) {\n                indegree[child]--;\n                if(indegree[child] == 0) {\n                    source.push(child);\n                }\n            }\n        }\n        return result.size()==numCourses;\n    }\n};"
		],
		[
			1.0,
			18.850934545217658,
			10,
			26.5455,
			"class Solution {\npublic:\n    bool dfs(int z, vector<vector<int>>& courses, vector<int>& vis) {\n        vis[z] = 1;\n        for(auto it: courses[z]) {\n            if(vis[it] == 1 || (vis[it] == 0 && !dfs(it, courses, vis))) {\n                return false;\n            }\n        }\n        vis[z] = 0;\n        return true;\n    }\n    \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int n = prerequisites.size();\n        if(n == 0) {\n            return true;\n        }\n        vector<vector<int>> courses(numCourses);\n        for(auto i: prerequisites) {\n            courses[i[1]].push_back(i[0]);\n        }\n        vector<int> vis(numCourses, 0);\n        for(int i=0;i<numCourses;i++) {\n            if(!dfs(i, courses, vis)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"
		],
		[
			19.608654079721624,
			17.484365156633384,
			10,
			35.8261,
			"class Solution {\npublic:\n    bool cycle(vector<vector<int>> &graph, vector<bool> &visited, vector<bool> &rec_stack, int s){\n        visited[s] = true;\n        rec_stack[s] = true;\n        for(int i = 0; i < graph[s].size(); i++){\n            int u = graph[s][i];\n            if(!visited[u] && cycle(graph, visited, rec_stack, u)){\n                return true;\n            }else if(rec_stack[u]){\n                return true;\n            }\n        }\n        rec_stack[s] = false;\n        return false;\n    }\n\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int i, j;\n        vector<vector<int>> graph(numCourses, vector<int>());\n        for(i = 0; i < prerequisites.size(); i++){\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\n        }\n        \n        vector<bool> visited(numCourses, false), rec_stack(numCourses, false);\n        \n        for(i = 0; i < numCourses; i++){\n            if(!visited[i]){\n                if(cycle(graph, visited, rec_stack, i)){\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			19.074925989353513,
			17.479971302441953,
			9,
			27.0,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses);\n        for(auto& p : prerequisites) graph[p.front()].push_back(p.back());\n\n        vector<bool> done(numCourses);\n        vector<bool> visited(numCourses);\n\n        for(int i = 0; i < graph.size(); ++i)\n            if(! check(i, graph, visited, done)) return false;\n        return true;\n    }\n    \nprotected:\n    bool check(int course, vector<vector<int>>& graph, vector<bool>& visited, vector<bool>& done)\n    {\n        if(done[course]) return true;\n        if(visited[course]) return false;\n\n        visited[course] = true;\n        for(int n : graph[course])\n            if(!check(n, graph, visited, done)) return false;\n        visited[course] = false;\n\n        done[course] = true;\n        return true;\n    }\n};\n"
		],
		[
			17.94519484474508,
			17.44213126434902,
			11,
			38.4762,
			"class Solution {\npublic:\n    bool containsCycle(vector<vector<int>>& g, int i, vector<bool>& visited, vector<bool>& ongoing) {\n        visited[i]= true;\n        ongoing[i]= true;\n        \n        for(int j=0; j<g[i].size(); j++) {\n            if(!visited[g[i][j]]) {\n                if(containsCycle(g, g[i][j], visited, ongoing))\n                    return true;\n            }\n            else if(visited[g[i][j]] && ongoing[g[i][j]])\n                return true;\n        }\n        ongoing[i]= false;\n        return false;\n    }\n    \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int n= prerequisites.size();\n        vector<bool> visited(numCourses, false), ongoing(numCourses, false);\n        vector<vector<int>>g(numCourses);\n        \n        for(int i=0; i<n; i++) \n            g[prerequisites[i][0]].push_back(prerequisites[i][1]);\n               \n        for(int i=0; i<numCourses; i++) {\n            if(!visited[i]) {\n                if(containsCycle(g, i, visited, ongoing)) return false;\n            }\n        }\n        return true;\n    }\n};"
		],
		[
			8.729038093475646,
			18.202261633875374,
			11,
			28.44,
			"class Solution {\n    unordered_map<int,vector<int> > gr;\npublic:\n    bool iscyc(vector<int> &rec,vector<int> &vis,int u){\n        if(!vis[u]){\n            vis[u]=1;\n            rec[u]=1;\n            for(auto v:gr[u]){\n                if(!vis[v] && iscyc(rec,vis,v)){\n                    return true;\n                }\n                else if(rec[v]==1){\n                    return true;\n                }\n            }\n        }\n        rec[u]=0;\n        return false;\n    }\n    bool canFinish(int n, vector<vector<int>>& pr) {\n        for(auto p:pr){\n            gr[p[1]].push_back(p[0]);\n        }\n        vector<int> recs(n+1,0);\n        vector<int> vis(n+1,0);\n        for(int i=0;i<n;i++){\n            if(!vis[i]){\n            if(iscyc(recs,vis,i)){\n                return false;\n            }\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			13.931556536892085,
			17.480722103515983,
			10,
			27.2593,
			"class Solution {\npublic:\n    set <int> vis;\n    set <int> ordering;\n    \n    bool dfs(vector < vector<int> > &graph, int x) {\n        vis.insert(x);\n        ordering.insert(x);\n        \n        for(int i=0;i<graph[x].size();i++) {\n          int v = graph[x][i];\n            \n          if(vis.find(v) != vis.end()) {\n              if(ordering.find(v) != ordering.end()) {\n                  return false;\n              }\n          }\n            \n          if(!dfs(graph, v)) return false;\n        }\n\t\t\n        ordering.erase(x);\n        return true;\n    }\n        \n    bool canFinish(int numCourses, vector<vector<int>>& pq) {\n       vector < vector<int> > graph(numCourses);\n        \n       for(int i=0;i<pq.size();i++) {\n           int u = pq[i][0], v = pq[i][1];\n           \n           graph[u].push_back(v);\n       }\n        \n       for(int i=0;i<numCourses;i++) {\n           if(vis.find(i) == vis.end()) {\n               if(!dfs(graph, i)) return false;\n           }\n       }\n       return true;\n       \n    }\n};\n"
		],
		[
			8.367523924168445,
			18.205055146172814,
			10,
			23.3333,
			"class Solution {\n\tprivate:\n\tvector<vector<int>> graph;\n\tvector<int> dp;\npublic:\n\tbool dfs(int a){\n\t\tif(dp[a]==1) return true;\n\t\tif(dp[a]==2) return false;\n\t\tdp[a]=1;\n\t\tfor(auto v:graph[a]){\n\t\t\tif(dfs(v)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tdp[a]=2;\n\t\treturn false;\n\t}\n\tbool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n\t\tif(prerequisites.size()==0) return true;\n\t\tgraph=vector<vector<int>>(numCourses);\n\t\tfor(auto x:prerequisites){\n\t\t\tgraph[x[1]].push_back(x[0]);\n\n\t\t}\n\t\tdp=vector<int>(numCourses,0);\n\t\tfor(int i=0;i<numCourses;i++){\n\t\t\tif(dfs(i)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\n\t}\n};"
		],
		[
			8.590165571236493,
			17.517920046433783,
			6,
			23.4155,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n        // store graph as an adjacency list\n        vector<int> graph[numCourses];\n        \n        // use a vector to store the in-degree of each node\n        vector<int> indegrees(numCourses, 0);  \n        \n        // use a priority queue to store all the nodes by acending order of their in-degree\n        priority_queue<array<int,2>, vector<array<int,2>>, greater<array<int,2>>> nodesQueue;\n        \n        // graph construction\n        for(int i=0; i<prerequisites.size(); i++) {\n            int next = prerequisites[i][0];\n            int prev = prerequisites[i][1];\n            \n            graph[prev].push_back(next);\n            indegrees[next]++;\n            \n        }\n        \n        // add starting in-degrees to the node priority queue\n        for(int i=0; i<numCourses; i++) {\n            nodesQueue.push(array<int,2> {indegrees[i], i});\n        }\n        \n        // get from the nodesQueue n times (all nodes will be retrieved by topological order)\n        // if any node retrieved has in-degree > 0, a cycle must exist\n        for(int i=0; i<numCourses; i++) {\n            array<int,2> curNode = nodesQueue.top();\n            nodesQueue.pop();\n            if(curNode[0]>0) {\n                return false;\n            }\n            \n            //reduce the in-degree of all neighbours by -1 and put the updated in-degree to pq\n            for(int next : graph[curNode[1]]) {\n                indegrees[next]--;\n                nodesQueue.push(array<int,2> {indegrees[next], next});\n            }\n        }\n        \n        return true;\n            \n    }\n};"
		],
		[
			17.93617930753078,
			17.48044670563766,
			10,
			28.05,
			"class Solution {\nprivate:\n    int not_processed=0;\n    int processing=1;\n    int processed=2;\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prereq) {\n        vector<int> visited(numCourses,0);\n        \n        vector<vector<int>> graph(numCourses);\n        \n        for(int i=0;i<prereq.size();i++){\n            graph[prereq[i][0]].push_back(prereq[i][1]);\n        }\n        for(int i=0;i<numCourses;i++){\n            if(visited[i]==not_processed){\n                if(!dfs(i,graph,visited)){  //return false if cycle exist\n                    return false;  \n                }\n            }\n        }\n        return true;\n    }\n    bool dfs(int node,vector<vector<int>>& graph,vector<int>& visited){\n        if(visited[node]==processing){\n            return false;\n        }\n        if(visited[node]==processed){\n            return true;\n        }\n        visited[node]=processing;\n        for(int i=0;i<graph[node].size();i++){\n            if(!dfs(graph[node][i],graph,visited)){\n                return false;\n            } \n        }\n        visited[node]=processed;\n        return true;  //means the graph is acyclic\n    }\n};"
		],
		[
			8.890061893567044,
			17.484225061110124,
			7,
			33.0435,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prereq) {\n        vector<vector<int>> graph(numCourses);\n        vector<int> indegree(numCourses);\n        \n        for(int i=0;i<prereq.size();i++){\n            graph[prereq[i][0]].push_back(prereq[i][1]);\n            indegree[prereq[i][1]]++;\n        }\n        stack<int> zeroDegreeNodes;\n        for(int i=0;i<numCourses;i++){\n            if(indegree[i]==0){\n                //cout<<i<<\" \";\n                zeroDegreeNodes.push(i);\n            }\n        }\n        int count=0;\n        while(!zeroDegreeNodes.empty()){\n            int curr=zeroDegreeNodes.top();\n            //cout<<curr<<\" \";\n            zeroDegreeNodes.pop();\n            count++;\n            for(int i=0;i<graph[curr].size();i++){\n                if(--indegree[graph[curr][i]]==0){\n                    zeroDegreeNodes.push(graph[curr][i]);\n                }\n            }\n        }\n        return count==numCourses;\n        \n    }\n};"
		],
		[
			9.904993242388267,
			17.483050387349238,
			7,
			33.0435,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prereq) {\n        vector<vector<int>> graph(numCourses);\n        vector<int> indegree(numCourses);\n        \n        for(int i=0;i<prereq.size();i++){\n            graph[prereq[i][0]].push_back(prereq[i][1]);\n            indegree[prereq[i][1]]++;\n        }\n        queue<int> zeroDegreeNodes;\n        for(int i=0;i<numCourses;i++){\n            if(indegree[i]==0){\n                //cout<<i<<\" \";\n                zeroDegreeNodes.push(i);\n            }\n        }\n        int count=0;\n        while(!zeroDegreeNodes.empty()){\n            int curr=zeroDegreeNodes.front();\n            //cout<<curr<<\" \";\n            zeroDegreeNodes.pop();\n            count++;\n            for(int i=0;i<graph[curr].size();i++){\n                if(--indegree[graph[curr][i]]==0){\n                    zeroDegreeNodes.push(graph[curr][i]);\n                }\n            }\n        }\n        return count==numCourses;\n        \n    }\n};"
		],
		[
			9.496552868791273,
			17.475583757683147,
			9,
			30.963,
			"class Solution {\npublic:\n    vector<int>res;\n    vector<int>in;\n    void check(int numCourses,vector<vector<int>>& v)\n    {   queue<int>q;\n        for(int i=0;i<numCourses;i++)\n           if(in[i]==0)\n              q.push(i);   \n        while(q.size()>0)\n        {   int cur=q.front();\n            res.push_back(cur);\n            q.pop();\n            for(int node:v[cur])\n            {\n                in[node]--;\n                if(in[node]==0)\n                    q.push(node);\n            }\n        }\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>>v(numCourses);\n        in.resize(numCourses);\n        for(int i=0;i<prerequisites.size();i++)\n        {\n            v[prerequisites[i][0]].push_back(prerequisites[i][1]);\n            in[prerequisites[i][1]]++;\n        }\n        check(numCourses,v);\n        if(res.size()==numCourses) return true;\n        else return false;\n    }\n};"
		],
		[
			8.365373419567408,
			17.476711627091365,
			11,
			38.0769,
			"class Solution {\npublic:\n    bool isValid = false;\n     vector<int>vis;\n    bool dfs(int node,vector<vector<int>>& graph)\n    {\n        if(vis[node]==2)\n            return true;\n        vis[node]=2;\n        for(int i=0;i<graph[node].size();i++)\n        {\n            if(vis[graph[node][i]]!=1)\n            {\n                if(dfs(graph[node][i],graph))\n                    return true;\n            }\n        }\n        vis[node]=1;\n        return false;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>>graph(numCourses);\n        if(prerequisites.size()==0)\n            return true;\n        for(int i=0;i<prerequisites.size();i++)\n        {\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\n        }\n        /*\n        for(int i=0;i<numCourses;i++)\n        {\n           // cout<<\"rishu\"<<endl;\n            for(int j=0;j<graph[i].size();j++)\n            {\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n        */\n         vis.resize(graph.size(),0);\n        for(int i = 0; i < numCourses; i++)\n        {\n            if(vis[i] == 0)\n            {\n                if(dfs(i,graph))\n                    return false;\n            }\n        }\n         return true;\n    }\n};"
		],
		[
			2511886431.509583,
			8.035584269104683,
			10,
			20.0909,
			"class Solution {\npublic:\n    int WHITE = 0;  // Unvisited\n    int GREY = 1;   // Explore incomplete\n    int BLACK = 2;  // Fully explored\n    \n    // return true if no cycle otherwise return false\n    bool dfs(int node, vector<vector<int>>&graph,vector<int>&visited)\n    {\n        visited[node] = GREY;\n        \n        // go thourgh all parent nodes i.e., prerequisites courses\n        for(int j=0;j<graph[node].size();j++)\n        {\n            // If end up in an unexplored node then it is a cycle and return false\n            if(visited[graph[node][j]]==GREY) return false;\n            \n            // Explore all unvisited parent node\n            if(visited[graph[node][j]]==WHITE)\n                if(!dfs(graph[node][j],graph,visited)) return false;    // return false if find cycle\n        }\n        \n        visited[node] = BLACK;\n        \n        return true;\n    }\n    \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n        // create graph for each course to prerequisites Adjacency List\n        vector<vector<int>>graph(numCourses);\n        \n        // Visited track of each node\n        vector<int>visited(numCourses,WHITE);\n        \n        // Populate graph \n        for(int i=0;i<prerequisites.size();i++)\n            graph[prerequisites[i][0]].push_back(prerequisites[i][1]);\n        \n        // Run DFS on each unvisited node\n        for(int i=0;i<numCourses;i++)\n        {\n            if(visited[i]==WHITE)\n                if(!dfs(i,graph,visited))return false;  // return false if detect cycle\n        }\n            \n        return true;\n    }\n};"
		],
		[
			3.827163278418475,
			1.0,
			7,
			31.5714,
			"class Solution {\npublic:bool dfs(vector<vector<int>> & a, vector<int> & v, int i)\n{\n\tif(v[i]==1)  return true;\n\tif(v[i]==-1) return false;\n\tv[i] = -1;\n\n\tauto out{true};\n\tfor(const auto & k : a[i]) out &= dfs(a, v, k);\n\n\tv[i] = 1;\n\treturn out;\n}\n\nbool canFinish(int n, vector<vector<int>>& p)\n{\n\tvector a(n, vector<int>{});\n\tfor(const auto & i : p) a[i[0]].push_back(i[1]);\n\n\tvector v(n, 0);\n\tauto out{true};\n\tfor(auto i{0}; i<n; ++i)\n\t\tout &= dfs(a, v, i);\n\n\treturn out;\n}\n};"
		],
		[
			17.612700838378743,
			17.486574387654336,
			7,
			21.8919,
			"class Solution {//BEST2: BFS:Time/Space: O(N); O(N)\npublic:// prerequisites: {child, parent}\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> g(numCourses);\n        vector<int> degrees(numCourses, 0);\n        for(const auto& e: prerequisites){\n            g[e[1]].emplace_back(e[0]);\n            degrees[e[0]]++; //Note1\n        }\n        \n        queue<int> q;\n        for(int i = 0; i < numCourses; i++)\n            if(degrees[i] == 0) q.push(i);  // Note2\n        int todoCnt=numCourses;\n        while(!q.empty()){\n            auto cur = q.front(); q.pop(); todoCnt--;\n            for(const auto& next: g[cur])\n                if(--degrees[next]==0) q.push(next); //Note3\n        }\n        return todoCnt == 0;\n    }\n};"
		],
		[
			8.558516766212135,
			18.20945049004398,
			9,
			18.1452,
			"class Solution {\n    using vi  = vector<int>;\npublic:\n    template <typename Tmp, typename Tv>\n    bool iscycle(Tmp& adj, Tv& vis, int id){\n        if (vis[id] == 1) return true;\n        if (vis[id] == 0) {\n            vis[id]=1;\n            for (auto& edge : adj[id])\n                if (iscycle(adj,vis,edge)) return true;\n        }\n        vis[id] = 2;\n        return false;\n    }\n    \n    bool canFinish(int n, vector<vector<int>>& pre) {\n        unordered_map<int, vi> adj;\n        for(auto edge : pre)\n            adj[edge[1]].push_back(edge[0]);\n        \n        vi vis(n, 0);\n        for (const auto& pr : adj)\n            if(iscycle(adj,vis, pr.first)) return false;\n        return true;\n    }\n};"
		],
		[
			13.838853472330895,
			18.204705256080036,
			9,
			26.1818,
			"class Solution {\npublic:\n    typedef vector<vector<int>> vii;\n    typedef vector<int> vi;\n    bool cycle(vii & p, vi & v,int i)\n    {\n       if(v[i] == 1) return true; \n       if(v[i] == 2) return false; \n       v[i] = 1; \n       for(int x: p[i])\n          if(cycle(p,v,x)) return true; \n       v[i] = 2;\n       return false; \n    }\n    bool canFinish(int n, vii & p) {\n      vii adjList(n);  \n      vi v(n,0); \n        for(vi v : p)\n            adjList[v[1]].push_back(v[0]); \n        for(int i = 0 ; i < n;i++)\n            if(cycle(adjList,v,i)) return false; \n        return true;\n    }\n};"
		],
		[
			8.037859980675016,
			18.204900094142857,
			9,
			24.7273,
			"class Solution {\npublic:\n    bool cycle(vector<vector<int>> & pre, vector<int> & visited,int pos)\n    {\n       if(visited[pos] == 1) return true; \n       if(visited[pos] == 2) return false; \n       visited[pos] = 1; \n       for(int x: pre[pos])\n          if(cycle(pre,visited,x)) return true; \n       visited[pos] = 2;\n       return false; \n    }\n    bool canFinish(int numCourses, vector<vector<int>>& pre) {\n      vector<vector<int>> adjList(numCourses);  \n      vector<int> visited(numCourses,0); \n        for(auto v : pre)\n            adjList[v[1]].push_back(v[0]); \n        for(int i = 0 ; i < numCourses;i++)\n            if(cycle(adjList,visited,i)) return false; \n        return true;\n    }\n};"
		],
		[
			18.24100887932229,
			18.25044753403949,
			13,
			32.0625,
			"class Solution {\nprivate:\n    unordered_map<int, vector<int> > graph;\n    unordered_map<int, vector<int> > rgraph;\n    vector<bool> visited;\n    stack<int> st;\n    \n    void dfs1(int u) {\n        if(visited[u]) {\n            return;\n        }\n        \n        visited[u] = true;\n        for(int v: graph[u]) {\n            dfs1(v);\n        }\n        \n        st.push(u);\n    }\n    \n    int dfs2(int u) {\n        if(visited[u]) {\n            return 0;\n        }\n        \n        int count = 1;\n        visited[u] = true;\n        for(int v: rgraph[u]) {\n            count += dfs2(v);\n        }\n        \n        return count;\n    }\n    \npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int u, v, count;\n        \n        visited = vector<bool>(numCourses, false);\n        \n        for(auto req: prerequisites) {\n            u = req[1];\n            v = req[0];\n            graph[u].push_back(v);\n            rgraph[v].push_back(u);\n        }\n        \n        for(u=0; u<numCourses; u++) {\n            if(visited[u] == false) {\n                dfs1(u);\n            }\n        }\n        \n        visited = vector<bool>(numCourses, false);\n        \n        while(st.size()) {\n            u = st.top();\n            st.pop();\n            if(visited[u] == false) {\n                count = dfs2(u);\n                if(count>1) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n};"
		],
		[
			16.898195938840306,
			17.482715041737507,
			7,
			31.9091,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses,vector<int>());\n        vector<int> indegree(numCourses,0);\n\n        for (int i = 0; i < prerequisites.size(); ++i) {\n            ++indegree[prerequisites[i][0]];\n            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);\n        }\n\n        queue<int> myque;\n        for (int i = 0; i < indegree.size(); ++i)\n            if (!indegree[i])\n                myque.push(i);\n\n        int counter = 0;\n        while (!myque.empty()) {\n            int cur = myque.front();\n            myque.pop();\n            ++counter;\n\n            for (int i = 0; i < graph[cur].size(); ++i) \n                if (--indegree[graph[cur][i]] == 0)\n                    myque.push(graph[cur][i]);\n        }\n\n        return numCourses == counter;\n    }\n};"
		],
		[
			9.882657992024532,
			18.205795367399368,
			11,
			30.5455,
			"class Solution\n{\npublic:\n    bool has_cycle(vector<int>adj[],vector<bool>&vis,vector<bool>&stk,int src)\n    {\n        if(!vis[src])\n        {\n            vis[src]=true;\n            stk[src]=true;\n            for(auto it:adj[src])\n            {\n                if(stk[it])\n                {\n                    return true;\n                }\n                else if(!vis[it] && has_cycle(adj,vis,stk,it))\n                {\n                    return true;\n                } \n            }\n            stk[src]=false;\n        }\n        return false;\n    }\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites)\n    {\n        vector<int>adj[numCourses];\n        for(auto it:prerequisites)\n        {\n            adj[it[0]].push_back(it[1]);\n        }\n        vector<bool>vis(numCourses,false),stk(numCourses,false);\n        for(int i=0;i<numCourses;i++)\n        {\n            if(!vis[i])\n            {\n                if(has_cycle(adj,vis,stk,i))\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			1.0,
			17.488087922234126,
			9,
			34.2,
			"class Solution {\npublic:\n    bool canFinish(int nc, vector<vector<int>>& arr) {\n        vector<int>adj[nc+1];\n        int inc[nc+1];\n        memset(inc,0,sizeof(inc));\n        for(int i=0;i<arr.size();i++) \n        {\n            adj[arr[i][1]].push_back(arr[i][0]);\n            inc[arr[i][0]]++;\n        }\n        queue<int>que;\n        for(int i=0;i<nc;i++)\n        {\n            if(inc[i]==0)\n                que.push(i);\n        }\n        while(!que.empty())\n        {\n            int tmp = que.front();\n            que.pop();\n            for(int i=0;i<adj[tmp].size();i++)\n            {\n                inc[adj[tmp][i]]--;\n                if(inc[adj[tmp][i]]==0) que.push(adj[tmp][i]);\n            }\n        }\n        for(int i=0;i<nc;i++)\n        {\n            if(inc[i]!=0) return false;\n        }\n        return true;\n    }\n};\n"
		],
		[
			17.903174995610158,
			17.476853981899296,
			7,
			28.2692,
			"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<int> pre_req_count(numCourses,0);\n        unordered_map<int,vector<int>> before_after;\n        \n        for (int i=0; i<prerequisites.size(); ++i) {\n            // \n            before_after[prerequisites[i][1]].push_back(prerequisites[i][0]);\n            //increase pre-req count of this course needed by 1 \n            pre_req_count[prerequisites[i][0]]++;\n        }\n        \n        int total = 0, curr;\n        queue<int> q;\n        //find all courses that don't have any prerequisites and add to queue\n        for (int i=0; i<pre_req_count.size(); ++i) {\n            if (pre_req_count[i] == 0)\n                q.push(i);\n        }\n        \n        while (!q.empty()) {\n            curr = q.front(); q.pop();\n            //find all courses that has this course as pre-req\n            for (auto &i : before_after[curr]) {\n                //this course now has one less pre-req\n                pre_req_count[i]--;\n                //if now this course is pre-req free, add to q\n                if (pre_req_count[i] == 0)\n                    q.push(i);\n            } \n            ++total;\n        }\n        return total == numCourses;\n    }\n};\n"
		],
		[
			17.418164645879305,
			18.20578013004991,
			10,
			32.5806,
			"class Solution {\npublic:\n    bool dfs(vector<int>adj[],vector<int>&visited,vector<int>&rec,int node)\n{\n    visited[node]=1;\n    rec[node]=1;\n    for(auto it:adj[node])\n    {\n        if(rec[it]){\n            return true;\n        }\n        else if(!visited[it] && dfs(adj,visited,rec,it))\n        {\n            return true;\n        }\n    }\n    rec[node]=0;\n    return false;\n}\n    bool canFinish(int numCourses, vector<vector<int>>& pre) {\n        \n        // contruct a graph (adjacency list from Prerequisites)\n        vector<int>adj[numCourses];\n        for(auto it:pre)\n        {\n            adj[it[0]].push_back(it[1]);\n        }\n         int V=numCourses;\n        // for(int i=0;i<V;i++)\n        // {\n        //     cout<<i<<\"-->\";\n        //     for(auto it:adj[i])\n        //     {\n        //         cout<<it<<\" \";\n        //     }\n        //     cout<<endl;\n        // }\n       \n        vector<int>visited(V,0);\n        vector<int>rec(V,0);\n        for(int i=0;i<V;i++)\n        {\n            if(!visited[i])\n            {\n                if(dfs(adj,visited,rec,i))\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n        \n        \n    }\n};\n"
		]
	],
	"JUMP_GAME": [
		"n",
		[
			4.729918571480351,
			4.266807006446483,
			3,
			18.75,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int index=nums.size()-1;\n        for(int i=nums.size()-2;i>=0;--i){\n            if(i+nums[i]>=index){\n                index=i;\n            }\n        }\n        return index==0;\n    }\n};\n"
		],
		[
			4.738596291241468,
			4.266807006446484,
			4,
			24.6154,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        if(nums.size()==1)\n            return true;\n        int maxi = nums[0];\n        for(int i=1;i<nums.size()-1;i++){\n            if(i>maxi)\n                continue;\n            \n            maxi = max(maxi, i+nums[i]);\n        }\n        return (nums.size()-1)<=maxi;\n    }\n};\n"
		],
		[
			5.9384295034232135,
			4.279657409509342,
			9,
			34.125,
			"class Solution {\npublic:\n\nbool canJump(vector<int>& nums) {\n    \n    int n = nums.size();\n    \n    if(!n || (n>1 && !nums[0]))\n        return false;\n    \n    if(nums[0] >= (n-1))\n        return true;\n    \n    vector<bool> dp(n,false);\n    dp[n-1] = true;\n    \n    for(long i=n-2;i>=0;i--)\n    {\n        for(long j=i+nums[i];j>i;j--)\n        {\n            if(j >= n || (dp[j] == true))\n            {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    \n    return dp[0];\n}\n};"
		],
		[
			4.702922446966743,
			4.266807006446484,
			5,
			20.3571,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        // support variables\n        int iLen = nums.size();\n        bool canReach[iLen];\n        for (bool &b: canReach) b = false;\n        canReach[0] = {1};\n        for (int i = 0, jLen, lastChecked = 0, jumps; i < iLen - 1; i++) {\n            // exiting when unreachable/unreached blocks are met\n            if (!canReach[i]) break;\n            // updating canReach with the latest jump\n            jumps = nums[i];\n            jLen = min(iLen, i + jumps + 1);\n            for (int j = max(lastChecked, i) + 1; j < jLen; j++) canReach[j] = true;\n            // updating lastChecked\n            lastChecked = jLen - 1;\n        }\n        return canReach[iLen - 1];\n    }\n};"
		],
		[
			4.517440679533891,
			4.266807006446483,
			3,
			17.1429,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        // support variables\n        int last = 0, len = nums.size() - 1;\n        for (int i = 0; i < len; i++) {\n            // exit condition - unreachable cell met\n\t\t\tif (i > last) break;\n\t\t\t// updating last\n            last = max(last, nums[i] + i);\n        }\n        return last >= len;\n    }\n};"
		],
		[
			4.802435968171864,
			4.266807006446484,
			4,
			17.6071,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n=nums.size();\n        if(n==0) return 0;\n        \n        int maxreach=0;\n        for(int i=0; i<n; i++){\n            if(maxreach<i)\n                return false;\n            maxreach=max(maxreach, i + nums[i]);\n        }\n        return true;\n    }\n};"
		],
		[
			4.676294088601096,
			4.266807006446484,
			5,
			18.45,
			"//Jump Game\n//O(1) space solution\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        if (nums.size() == 0) return false;\n        if (nums.size() == 1) return true;\n        \n        int n = nums.size();\n        int jump = 0;\n        for (int i = 1; i < n; i++) {\n            jump = max(nums[i-1], jump) - 1;\n            if (jump < 0) return false;\n        }\n        return true;\n    }\n};"
		],
		[
			4.770179601221479,
			4.266807006446483,
			4,
			20.0357,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        for(int i = 0, max_jump = 0; i < nums.size() && max_jump < nums.size()-1; ++i)\n        {\n            if(i > max_jump) return false;\n            max_jump = max(max_jump, i+nums[i]);\n        }\n        return true;\n    }\n};"
		],
		[
			4.841829743985941,
			4.266807006446484,
			3,
			20.3571,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        for(int i = 0, max_jump = 0; i <= max_jump; ++i)\n        {\n            max_jump = max(max_jump, i+nums[i]);\n            if(max_jump >= nums.size()-1) return true;\n        }\n        return false;   \n    }\n};"
		],
		[
			4.820324861244558,
			4.266807006446484,
			5,
			15.0,
			"class Solution \n{\npublic:\n    //AC - 16ms - backwards searching for zero jump length and then make sure it can be jumped over;\n    bool canJump(vector<int>& nums) \n    {\n        int d = 0;\n        for(int i = nums.size()-2; i >= 0; --i)\n        {\n            if(nums[i] == 0)\n            {\n                int d = 1;\n                while(d > nums[i])\n                {\n                    d++;\n                    i--;\n                    if(i < 0) return false;\n                }\n            }\n        }\n        return true;\n    }\n};"
		],
		[
			7.810781186943741,
			4.36558790866042,
			10,
			31.1389,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        if(nums.empty()) return true;\n        if(nums[0]==0)\n        {\n            if(nums.size()==1) return true;\n            else return false;\n        }\n        vector<int> zero;\n        for(int i=0;i<nums.size()-1;i++)\n        {\n            if(nums[i]==0)\n            {\n                zero.push_back(i);\n            }\n        }\n        bool flag;\n        for(int i=0;i<zero.size();i++)\n        {\n            flag=false;\n            for(int j=0;j<zero[i];j++)\n            {\n                if(nums[j]+j>zero[i]) \n                {\n                    flag=true;\n                    break;\n                }\n            }\n            if(!flag) return false;\n        }\n        return true;\n    }\n};"
		],
		[
			4.598332447870326,
			4.266807006446484,
			3,
			18.75,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int reachable = nums.size()-1;\n        for(int i=nums.size()-2;i>=0;--i)\n            if(i+nums[i] >= reachable) reachable = i;\n        return reachable == 0;\n    }\n};\n"
		],
		[
			4.704930196778218,
			4.266807006446483,
			5,
			22.3929,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        if(nums.size()==1) return true;\n        if(nums[0]==0) return false;\n        int step = nums[0];\n        for(int i=1; i<nums.size()-1; i++){\n            step = max(--step, nums[i]);\n            if(step<=0) return false;\n        }\n        return true;\n    }\n};"
		],
		[
			4.668808143775618,
			4.266807006446484,
			3,
			21.0,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int closest_stand=nums.size()-1;\n        for (int i=closest_stand;i>=0;--i) {\n            if (i+nums[i]>=closest_stand) closest_stand=i;\n        }\n        return closest_stand==0;\n    }\n};"
		],
		[
			4.436007008422013,
			4.266807006446483,
			3,
			16.0714,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int distance = 0;\n        for(int i = 0; i < nums.size() - 1; i++){\n            distance = max(distance, i + nums[i]);\n            if(distance == i) return false;\n        }\n        return true;\n    }\n};\n"
		],
		[
			4.604992982712588,
			4.266807006446483,
			9,
			29.0588,
			"class Solution {\npublic:\n\tbool canJump(vector<int>& nums) {\n\t\tif (nums.empty())\n\t\t\treturn false;\n\t\tif (nums.size() == 1)\n\t\t\treturn true;\n\t\tif (nums[0] == 0)\n\t\t\treturn false;\n\t\tbool can_over;\n\t\tfor (int i = nums.size() - 2; i > 0; --i)\n\t\t{\n\t\t\tif (nums[i])\n\t\t\t\tcontinue;\n\t\t\tcan_over = false;\n\t\t\tint j;\n\t\t\tfor (j = i - 1; j >= 0; --j)\n\t\t\t{\n\t\t\t\tif (nums[j] > i - j)\n\t\t\t\t{\n\t\t\t\t\tcan_over = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!can_over)\n\t\t\t\treturn false;\n\t\t\ti = j;\n\t\t}\n\t\treturn true;\n\t}\n};\n"
		],
		[
			4.401966499861366,
			4.266807006446483,
			3,
			21.4286,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int size = nums.size();\n        int k = nums[0];\n        for(int i = 0; i <= k; ++i) {\n            if((i+nums[i]) >= (size-1)) return true;\n            else k = max(k, i+nums[i]);\n        }\n        return false;\n    }\n};\n"
		],
		[
			4.48161884528892,
			4.266807006446483,
			4,
			15.4062,
			"class Solution {\npublic:\nbool canJump(vector<int>& nums) {\n    if(nums.empty()) return true;\n    int m = nums[0];\n    for(auto i = 1; i < nums.size(); ++i)\n    {\n        if(m <= 0) return false;\n        m = max(m - 1, nums[i]);\n    }\n    return true;\n}\n};"
		],
		[
			4.497560168358014,
			4.266807006446484,
			5,
			17.0946,
			"class Solution {\n    public:\n        bool canJump(vector<int>& nums) {\n            int n=nums.size();// get first constraint\n            \n            if(n==0)// corner case\n            return false;\n            int maxIndex=0;\n            for(int i=0;i<n&&i<=maxIndex;i++)// two constraints. It will stop when either one terminates\n                maxIndex=max(maxIndex,i+nums[i]);// update dynamic range every time\n                \n                if(maxIndex>=n-1)// cover last index\n                return true;\n                else// not cover\n                return false;\n            \n            \n        }\n    };"
		],
		[
			4.651944707695098,
			4.266807006446484,
			6,
			25.5244,
			"/*\n *  The idea is to jump 1 index at a time while keeping the max jump value by \n *  comparing current jump value vs max jump value. max jump value decreases by 1\n *  each time I jump 1 index.\n *  This way, if I have more zeroes than I can jump, my max jump value will\n *  become 0 before I reach the last index.\n */class Solution {\npublic:\nbool canJump(vector<int>& nums) \n{\n    if (nums.empty()) return false;\n    \n    int maxJumpVal = 0;\n    int curIndex = -1;\n    while (++curIndex + maxJumpVal < nums.size()) // if jump from where I am right now goes beyond the end, return true\n    {\n        int curJumpVal = nums.at(curIndex);\n        maxJumpVal = max(curJumpVal, --maxJumpVal); // if my current jump value is bigger than the max jump value, update it. Otherwise, use max jump value where I am jumping from previous index.\n        \n        if (curJumpVal == 0) // if current jump value is 0, just continue with one less max jump value\n        {\n            if (maxJumpVal == 0 && curIndex < nums.size()-1) // if, however, max jump value is also zero and I am not on the last index, return false. If I am on the last index, curIndex will increment in the while loop condition and break out of the loop resulting in returning true\n                return false;\n            continue;\n        }   \n    }\n    \n    return true;\n}\n };"
		],
		[
			4.529639176361969,
			4.266807006446484,
			3,
			13.1429,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int u = 1;\n        for (int i = 0; i < nums.size(); i ++){\n            if (--u < 0) return false;\n            u = max(nums[i], u);\n        }\n        return true;\n    }\n};"
		],
		[
			4.757510457091475,
			4.266807006446484,
			5,
			20.3571,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        // support variables\n        int iLen = nums.size();\n        bool canReach[iLen];\n        for (bool &b: canReach) b = false;\n        canReach[0] = {1};\n        for (int i = 0, jLen, lastChecked = 0, jumps; i < iLen - 1; i++) {\n            // exiting when unreachable/unreached blocks are met\n            if (!canReach[i]) break;\n            // updating canReach with the latest jump\n            jumps = nums[i];\n            jLen = min(iLen, i + jumps + 1);\n            for (int j = max(lastChecked, i) + 1; j < jLen; j++) canReach[j] = true;\n            // updating lastChecked\n            lastChecked = jLen - 1;\n        }\n        return canReach[iLen - 1];\n    }\n};\n"
		],
		[
			4.544183956610552,
			4.266807006446484,
			4,
			20.7143,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int farthest = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            farthest = max(farthest, i + nums[i]);\n            if (farthest >= nums.size() - 1) {\n                return true;\n            } else if (farthest == i) {\n                return false;\n            }\n        }\n        return false;\n    }\n};\n"
		],
		[
			4.62536339322144,
			4.266807006446484,
			5,
			26.8235,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        \n        if(n == 1)\n            return true;\n        \n        int max_so_far = 0;\n        \n        for(int i = 0; i < n-1; i++){\n            \n            if(nums[i] == 0 and i == max_so_far)\n                return false;\n            \n            if(i + nums[i] >= n-1)\n                return true;\n            max_so_far = max(max_so_far, i + nums[i]);\n        }\n        return false;\n    }\n};\n"
		],
		[
			4.537737738771282,
			4.266807006446484,
			4,
			18.3077,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n       int jump = 0, size = nums.size(); \n       for(int i = 0 ; i < size-1;i++)\n       {\n           jump = nums[i] > jump ? nums[i] : jump;\n           if(!jump) return false;\n           jump--;\n       } \n        return true;\n    }\n};\n"
		],
		[
			4.434892773457009,
			4.266807006446483,
			3,
			14.7692,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int last=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(i>last) return false;            \n            last=max(last,i+nums[i]);\n        }\n        return true;\n    }\n};\n"
		],
		[
			4.596770933544274,
			4.266807006446483,
			4,
			20.5882,
			"typedef long long ll;\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        ll store = nums.size()-1;\n        ll r = nums.size()-2;\n        ll l = 0;\n        while(l<=r)\n        {\n            if(nums[r]>=(store-r))\n            {\n                store = r;\n                r--;\n            }\n            else\n                r--;\n        }\n        if(store==0)\n            return true;\n        else\n            return false;\n        \n    }\n};\n"
		],
		[
			4.45257825839876,
			4.266807006446484,
			3,
			12.7273,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL);\n        \n        int n = nums.size();\n        int maxReach = 0;\n        \n        for(int i=0; i<n; i++){\n            if(maxReach < i)\n                return false;\n            maxReach = max(maxReach, nums[i]+i);\n        }\n        return true;\n    }\n};\n"
		],
		[
			4.576769777190841,
			4.266807006446484,
			4,
			18.1364,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int minSteps=1;      //no of steps required from any index to reach last index\n        for(int i=nums.size()-2;i>=0;i--)\n            nums[i]<minSteps?minSteps++:minSteps=1;   //if we can reach to last index from here, minSteps from i-1th index is 1\n        return minSteps>1?false:true;    //if minSteps>1, we were not able to reach last index from first\n    }\n};\n"
		],
		[
			4.583140347996499,
			4.266807006446484,
			3,
			18.0,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int len=nums.size();\n        int last=len-1;\n        for(int i=len-2;i>=0;i--)\n        {\n            if((nums[i]+i)>=last)\n            {\n                last=i;\n            }\n        }\n        return last==0;\n    }\n};\n"
		],
		[
			4.569890221754246,
			4.266807006446483,
			3,
			19.6364,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int target = nums.size()-1;\n        \n        for(int i = target-1; i >= 0; i--){\n            if(nums[i]+i >= target) target = i;\n        }\n        \n        return target == 0;\n    }\n};"
		],
		[
			4.416167737638117,
			4.266807006446484,
			6,
			19.425,
			"class Solution {\npublic:\nbool canJump(vector<int>& nums) {\n    int len = nums.size() - 1; // ignore last step\n\n    // If there is none 0, then it is OK.\n    // If there is a 0, it should be like this:\n    // 7,[?],5,4,3,2,1,0, ... the [?] should be greater than 6\n    for (int i=0; i<len; ++i) {\n        if (0 == nums[i]) {\n            bool breakZero = false;\n            for (int j=i-1, count=1; j>=0; --j, ++count) {\n                if (nums[j] > count) {\n                    breakZero = true;\n                    break;\n                }\n            }\n            if (false == breakZero) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n};"
		],
		[
			4.531113705465802,
			4.266807006446484,
			4,
			18.4722,
			"class Solution {\npublic:\nbool canJump(vector<int>& nums) {\n    unsigned int maxReach = 0;\n    for (unsigned int i = 0; i < nums.size(); i++) {\n        if (maxReach < i)  // cannot reach i \n            return false;\n        if (maxReach >= nums.size()-1)\n            return true;  //early return \n        maxReach = max(maxReach, i+nums[i]);\n    }\n    return true;\n}\n};"
		],
		[
			4.435168581749873,
			4.266807006446484,
			8,
			47.25,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        \n        if(nums.size()==1)\n            return 1;\n        else if(nums[0]==0)\n            return 0;\n        \n        int count=0;\n        \n        for(int i=0;i<nums.size()-1;i++)\n        {\n            if(nums[i]==0)\n            {\n                count=0;\n                for(int j=i-1;j>=0;j--)\n                {\n                   if(nums[j]+j>=i+1)\n                   {\n                      i=nums[j]+j-1;\n                      ++count;\n                      break;\n                   }\n                }\n                if(count==0)\n                    return 0;\n            }\n            else\n                i=i+nums[i]-1;\n        }\n        \n        \n        return 1;\n    }\n};\n"
		],
		[
			4.480237847940689,
			4.266807006446484,
			5,
			28.875,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n=nums.size(), max_so_far=0;;\n        if(n==0) return true;\n        \n        for(int i=0; i<= max_so_far && max_so_far<n; i++){\n            max_so_far= max(max_so_far, i + nums[i]);\n        }\n        if(max_so_far>=n-1)\n                return true;\n        else\n            return false;\n        \n    }\n};"
		],
		[
			4.568070518816127,
			4.266807006446483,
			4,
			20.0,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int i,minjump=0;\n        for(i=nums.size()-2;i>=0;i--){\n            minjump++;\n            if(nums[i]>=minjump)minjump=0;\n        }\n        if(minjump==0)return true;\n        else return false;\n    }\n};\n"
		],
		[
			13.664565948149187,
			12.755811928116483,
			5,
			21.4773,
			"class Solution {\n    \npublic:\n    bool canJump(const vector<int>& nums) {\n        if (nums.size() == 1) return true; // Handle edge case of a vector being given of size 1\n        for (int i{nums[0]}; i > 0; --i) {\n            bool res = nums.begin() + i >= nums.end() - 1 ? true : canJump({nums.begin() + i, nums.end()});\n            if (res) return true;\n        }\n        return false;\n    }\n};\n"
		],
		[
			4.762254102036435,
			4.266807006446484,
			5,
			24.0667,
			"class Solution {\npublic:bool canJump(vector<int>& a) {\n        int n = a.size();\n        int currrent_max = 0;\n        \n        for(int i=0; i<n; i++){\n            currrent_max = max(currrent_max, i+a[i]);\n            if(currrent_max == n-1)\n                return true;\n            \n            if(a[i] == 0 && currrent_max <= i)\n                return false;\n        }\n        return true;\n    }\n};"
		],
		[
			4.642410780698236,
			4.266807006446484,
			3,
			16.8,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int valid = 0; // Furthest it can reach currently.\n        for (int i(0); i < nums.size() && i <= valid; ++i) {\n\t\t\t// maximum between the current furthest reached and the current value + index.\n            valid  = max(valid, i + nums[i]); \n        }\n        return valid >= nums.size() - 1; // if valid >= length - 1, then true else false.\n    }\n};\n"
		],
		[
			4.670398924731002,
			4.266807006446484,
			5,
			20.7692,
			"class Solution {\npublic:\n\tbool canJump(vector<int>& nums) {\n\t\tint cur=0;\n\t\tfor(int i=0;i<nums.size()-1;i++){\n\t\t\tif(i+nums[i]>cur){\n\t\t\t\tcur=i+nums[i];\n\t\t\t}\n\t\t\tif(nums[i]==0){\n\t\t\t\tif(cur<=i){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n};"
		],
		[
			4.854062160569239,
			4.266807006446484,
			5,
			20.1875,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int jump=nums[0]; // first jump\n        for(int i=1;i<nums.size();i++){\n            if(jump<=0) return false; \n            jump--;\n            if(jump<=nums[i])\n                jump=nums[i]; // update jump - greedy\n        }\n        if(jump>=0)\n            return true;\n        return false;\n    }\n};\n"
		],
		[
			4.696267535764189,
			4.266807006446483,
			3,
			17.25,
			"class Solution {\npublic:\n    int canJump(vector<int>& nums) {\n        int a=0;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(a>=i)\n                a=max(a,i+nums[i]);\n            else\n                return false;\n        }\n        return true;\n    }\n};\n"
		],
		[
			4.669076377959913,
			4.266807006446484,
			5,
			20.0769,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) { \n     int maxindex = 0;\n     for(int i=0;i<nums.size()-1;i++){\n       if(nums[i]){\n         if(nums[i]+i > maxindex) maxindex = nums[i]+i;\n       }else if(maxindex <= i) return false;\n     } \n     return true;   \n    }\n};\n"
		],
		[
			4.7096971894621475,
			4.266807006446484,
			4,
			15.7857,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int reach = nums.size() - 1;\n        for(int i = nums.size() - 2; i >= 0; i--){\n            if(i + nums[i] >= reach) reach = i;\n        }\n        if(!reach) return true;\n        return false;\n    }\n};\n"
		],
		[
			4.868379636900066,
			4.266807006446484,
			4,
			22.1667,
			"class Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n=nums.size();\n        int max_position=0;\n        for(int i=0;i<n;i++){\n            max_position=max(max_position,nums[i]+i);\n            if(max_position>=n-1)\n                return true;\n            if(max_position==i)\n                return false;\n        }\n        return false;\n    }\n};\n"
		],
		[
			4.604010325979182,
			4.266807006446484,
			3,
			18.4062,
			"class Solution {\npublic:\n\tbool canJump(vector<int>& nums) {\n\t\tint n = nums.size();\n\n\t\tint can_reach = 0;\n\n\t\tfor(int i=0;i<=can_reach;i++){\n\t\t\tif(i == n-1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcan_reach = max(can_reach , i+nums[i]);\n\t\t}\n\n\t\treturn false;\n\t}\n};"
		]
	],
	"COIN_CHANGE": [
		"m",
		[
			7.020829327832227,
			4.762282179025152,
			5,
			24.0625,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<double> dp(amount+1, INT_MAX);\n        dp[0] = 0;\n        \n        // dp[i] represents the fewest number of coins to make up the amount i\n        for (int i = 1; i <= amount; i++) {\n            \n            for (auto coin : coins) {\n                \n                if (coin <= i) {\n                    \n                    dp[i] = min(dp[i], dp[i-coin]+1);\n                }\n            }\n        }\n        \n        return dp.back() == INT_MAX ? -1 : dp.back();\n    }\n};\n"
		],
		[
			6.354946980608282,
			4.266807006446483,
			4,
			25.5,
			"class Solution {\npublic:\n\tint coinChange(vector<int>& coins, int amount) {\n\t\tvector<int> dp(amount+1,amount+1);\n\t\tdp[0]=0;\n\t\tfor(auto x:coins){\n\t\t\tfor(int i=x;i<=amount;i++){\n\t\t\t\tdp[i]=min(dp[i],dp[i-x]+1);\n\t\t\t}\n\t\t}\n\t\treturn dp[amount]>=amount+1 ? -1:dp[amount];\n\n\t}\n};"
		],
		[
			6.8190288716415175,
			4.573050519273264,
			4,
			25.5,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1,amount+1);\n        dp[0] = 0;\n        for(auto x:coins)\n            for(int i=x; i<=amount; i++)\n                dp[i] = min(dp[i],dp[i-x]+1);\n        int ans = -1;\n        if(dp[amount]!=amount+1) ans = dp[amount];\n        return ans;\n    }\n};\n"
		],
		[
			19.285582924285396,
			4.573050519273264,
			5,
			36.1538,
			"class Solution {\npublic:    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp (amount+1, amount+1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++)\n            for (int j = 0; j < coins.size(); j++)\n                if (i-coins[j] >= 0)\n                    dp[i] = min(dp[i-coins[j]]+1, dp[i]);\n        return (dp[amount] == amount+1) ? -1 : dp[amount];\n    }\n};"
		],
		[
			6.978311306587633,
			4.266807006446483,
			9,
			44.5,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        // unbounded Knspascak Problem\n        \n        int n = coins.size();\n        int m = amount;\n        \n        int t[n+1][m+1];\n        \n        for(int i=0;i<n+1;i++)\n        {\n            for(int j=0;j<m+1;j++)\n            {\n                if(i==0 && j==0)\n                {\n                    t[i][j]=0;\n                }\n                else if(i==0)\n                {\n                    t[i][j]=INT_MAX-100;\n                }\n                else if(j==0)\n                {\n                    t[i][j]=0;\n                }\n                else if(coins[i-1]<=j)\n                {\n                    t[i][j]=min((1+t[i][j-coins[i-1]]),t[i-1][j]);\n                }\n                else\n                {\n                    t[i][j]=t[i-1][j];\n                }\n            }\n            \n        }\n        return (t[n][m]==INT_MAX-100)?-1:t[n][m];\n    }\n};\n"
		],
		[
			7.274057607290383,
			4.573050519273264,
			6,
			26.1333,
			"class Solution {\npublic:    int coinChange(vector<int>& coins, int amount) {\n        // coin change solution will be stored in dp[i] upto 'amount' where i = amount\n\t\tvector<int> dp(amount + 1, -1); // initially all solution upto amount is -1 (unknown)\n        dp[0] = 0; // 0 is solution for amount 0\n\t\tfor (int i = 1; i <= amount; i++) {\n            int minCnt = amount + 1;  //minCnt is used to count minimum coin for i amount. initially assigned to coin numbers more than amount\n            for (auto v : coins) \n                if( i >= v && dp[i - v] > -1)\n                    minCnt = min(dp[i - v], minCnt); /*get the minimum coin count if amount is greater than coin value  and solution exists for that particular coin*/\n            if (minCnt != amount + 1)\n                dp[i] = minCnt + 1; // update dp[i] if solution exist\n        }\n        return dp[amount];\n    }\n};"
		],
		[
			7.191278239696133,
			4.762282179025152,
			9,
			42.6667,
			"/*\ndp[amount] = dp[amount-coins[i]] + 1;\n*/\n\nclass Solution {\npublic:\n    int coinChange(vector<int>& nums, int amount) {\n        long long int n=nums.size();\n        sort(nums.begin(),nums.end());\n        //dp[i] -> min no of coins required to make amount 'i'\n        vector<long long int> dp(amount+1,INT_MAX);\n        dp[0]=0;\n        for(long long int i=0;i<n;i++){\n            if(nums[i]>amount)\n                break;\n            dp[nums[i]]=1;\n        }\n        \n        for(long long int i=1;i<=amount;i++){\n            if(dp[i]!=INT_MAX){\n                for(long long int j=0;j<n && i+nums[j]<=amount;j++){\n                    int new_val=i+nums[j];\n                    if(new_val>amount)\n                        break;\n                    dp[new_val]=min(dp[new_val],dp[i]+1);\n                }\n            }\n            \n        }\n        if(dp[amount]==INT_MAX){\n            return -1;\n        }\n        return dp[amount];\n    }\n};\n"
		],
		[
			7.0903750405168395,
			4.573050519273264,
			6,
			26.4,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1,-1); dp[0] = 0;\n        for(int i = 1;i<=amount;i++)\n        {\n            int mi = 100000000;\n            for(auto a:coins)\n                if(i>=a && dp[i-a]!=-1)  mi = min(mi,dp[i-a]);\n            if(mi != 100000000)  dp[i] = 1+mi;\n        }\n        return dp[amount];\n    }\n};\n"
		],
		[
			7.0983065613722305,
			4.573050519273264,
			5,
			23.8718,
			"class Solution\n{\npublic:\n    int coinChange(vector<int> &coins, int amount)\n    {\n        vector<int> memo(amount + 1, amount + 1);\n        memo[0] = 0;\n        for (int amt = 1; amt <= amount; amt++)\n        {\n            for (int coin : coins)\n            {\n                // If this coin can be used to make amt\n                if (coin <= amt)\n                {\n                    // Number of coins required to make amt amount is\n                    // Minimum of (current minimum number of coins required to make amt) and\n                    //            (Sum of Current coin value and minimum number of coins\n                    //               required for (amt - coin val) amount)\n                    memo[amt] = min(memo[amt], memo[amt - coin] + 1);\n                }\n            }\n        }\n        // Return memo of amount if making that amount with given coins is possible.\n        // Otherwise, return -1\n        return memo[amount] > amount ? -1 : memo[amount];\n    }\n};\n"
		],
		[
			18.686406378599358,
			4.266807006446483,
			6,
			33.9231,
			"class Solution {\npublic:int coinChange(vector<int>& coins, int amount) { \n        int dp[amount+1];\n        dp[0] = 0;    \n        for(int e=1;e<amount+1;e++)\n            dp[e] = amount+1;\n        for(int i=1;i<amount+1;i++){\n            for(int j:coins){\n                if(i-j>=0)\n                    dp[i] = min(dp[i],dp[i-j]+1);\n            }\n        }\n        if(dp[amount]==amount+1)\n            return -1;\n        \n        return dp[amount];\n    }\n};"
		],
		[
			6.817718156195993,
			4.266807006446484,
			8,
			48.8235,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n\n        int n=coins.size();\n        if(n==0) return 0;\n        \n        int dp[n+1][amount+1];\n        \n        for(int i=0;i<=amount;i++)\n        {\n            dp[0][i]=INT_MAX-1;\n        }\n        \n        for(int i=1;i<=n;i++)\n        {\n            dp[i][0]=0;\n        }\n        \n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=amount;j++)\n            {\n                if(j<coins[i-1])\n                {\n                    dp[i][j]=dp[i-1][j];\n                }\n                else\n                {\n                dp[i][j]=min(1+dp[i][j-coins[i-1]],dp[i-1][j]);\n                }\n            }\n        }\n        int ans= dp[n][amount];\n        \n        if(ans==INT_MAX-1) return -1;\n        else return ans;\n        return {};\n    }\n};"
		],
		[
			18.600885534039787,
			4.573050519273264,
			6,
			22.75,
			"class Solution {\npublic:    int coinChange(vector<int>& coins, int amount) {\n        if(coins.size()==0)return 0;\n        vector<int> dp(amount+1);             //Note that dp[0]=0 because for amount 0 there is no possible way to pay using the given coins\n        for(int i=1;i<=amount;i++)\n        {\n            int t=INT_MAX/2;                     //we cannot use INT_MAX cuz anything above INT_MAX will cause an overflow.\n            for(int j=0;j<coins.size();j++)\n            {\n                if(i-coins[j]>=0)\n                    t=min(t,dp[i-coins[j]]+1);\n            }\n            dp[i]=t;\n        }\n        return dp[amount]>=INT_MAX/2?-1:dp[amount];      //Sometimes it impossible to get an amount using the coins given eg: amount 3 using coins 2 and 5.\n    }\n};"
		],
		[
			6.852099693122493,
			4.762282179025152,
			7,
			45.5,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n\t\tif (amount == 0) return 0;\n\t\tvector<double> result(amount + 1, amount + 1);\n\t\tresult[0] = 0;\n\t\tfor (int i = 1; i <= amount; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < coins.size(); j++)\n\t\t\t{\n\t\t\t\tif (i >= coins[j] && result[i] - 1 > result[i - coins[j]])\n\t\t\t\t{\n\t\t\t\t\tresult[i] = result[i - coins[j]] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (int)result[amount] > amount ? -1 : (int)result[amount];\n\t}\n};\n"
		],
		[
			6.944176020689601,
			4.573050519273264,
			5,
			31.6667,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1,INT_MAX-1);\n        dp[0]=0;\n        \n        for(int i=1;i<=coins.size();i++)\n        {\n            for(int j=1;j<=amount;j++)\n            {\n                if(coins[i-1]<=j)\n                {\n                    dp[j]=min(dp[j],1+dp[j-coins[i-1]]);\n                }\n            }\n        }\n        \n        return (dp[amount]>=INT_MAX-1 ? -1 : dp[amount]);\n    }\n};\n"
		],
		[
			19.24816860341597,
			4.266807006446483,
			11,
			57.5,
			"#define MAX 9999\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        if(amount==0)\n            return 0;\n\t\t\t\n        int dp[coins.size()+1][amount+1];\n\t\t\n        for(int i=0;i<=coins.size();i++)\n            for(int j=0;j<=amount;j++)\n                if(i==0||j==0)\n                 dp[i][j]=MAX;\n\t\t\t\t \n        for(int i=1;i<=coins.size();i++)\n        {\n            for(int j=1;j<=amount;j++)\n            {\n                if(coins[i-1]>j)\n                    dp[i][j]=dp[i-1][j];\n                else if(coins[i-1]==j)\n                    dp[i][j]=1;\n                else\n                    dp[i][j]=min(dp[i-1][j],1+dp[i][j-coins[i-1]]);\n            }\n        }\n\t\t\n        if(dp[coins.size()][amount]==MAX)\n            return -1;\n\t\t\t\n        return dp[coins.size()][amount];\n    }\n};\n"
		],
		[
			6.78173228186286,
			4.266807006446484,
			6,
			33.8889,
			"class Solution {\npublic:\n    \n    int coinChange(vector<int>& coins, int amount) {\n        int dp[amount+1];\n        dp[0] = 0;\n        \n        // for every amt = [1, amount], find min coins req\n        for(int amt=1; amt<=amount ; amt++){\n            dp[amt] = INT_MAX;\n            for(int i=0 ; i<coins.size() ; i++){\n                if(amt - coins[i] >= 0 && \n                   dp[amt-coins[i]] != INT_MAX)\n                        dp[amt] = min(dp[amt], dp[amt-coins[i]]+1);\n            }\n        }\n        \n        if(dp[amount] <= amount)\n            return dp[amount];\n        \n        return -1;\n    }\n};\n"
		],
		[
			6.763925934898144,
			4.266807006446483,
			8,
			35.625,
			"class Solution {\npublic:\n\tint coinChange(vector<int>& coins, int amount) {\n\t\tint dp[amount+1];\n\t\tdp[0]=0;\n\t\tfor(int i=1;i<=amount;++i)\n\t\t\tdp[i] = INT_MAX;\n\t\t\n\t\tint len = coins.size();\n\n\t\tfor (int i = 1; i <= amount; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < len; ++j)\n\t\t\t{\n\t\t\t\tif(coins[j] <= i){\n\t\t\t\t\tint rest = dp[i-coins[j]];\n\t\t\t\t\tif(rest != INT_MAX && rest+1<dp[i]){\n\t\t\t\t\t\tdp[i] = rest+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dp[amount]==INT_MAX ? -1 : dp[amount];\n\t}\n};\n"
		],
		[
			7.249942042566421,
			4.266807006446483,
			7,
			47.5,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int n = coins.size();\n        int dp[n+1][amount+1];\n        \n        for(int i=0;i<=n;i++) dp[i][0]=0;\n        for(int i=1;i<=amount;i++) dp[0][i]=1e5;\n        \n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=amount;j++){\n                if(coins[i-1]>j) dp[i][j]=dp[i-1][j];\n                else dp[i][j] = min(1+dp[i][j-coins[i-1]], dp[i-1][j]); \n            }\n        }\n        \n        if(dp[n][amount]>=1e4) return -1;\n        return dp[n][amount];\n    }\n};\n"
		],
		[
			18.91221550768334,
			4.573050519273264,
			5,
			26.4717,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount){\n       vector<int> dp(amount+1,amount+1) ;                 //Initialise the vector of size  amount +1 with anything greater than amount\n        dp[0]=0;                                           //Base case i.e 0 can be made from 0 coins\n        sort(coins.begin(),coins.end());                   // In case if any coin is greater than the amount then we need not check for other coins rather break the loop\n        for (int i = 1; i <= amount; i++)                  //Varying all amount ,i represents different amounts i.e subproblems\n        {\n            for (int j = 0; j < coins.size(); j++)         //Varying all coins,j represents different coins\n            {  if(i>=coins[j])\n                {\n                    dp[i]=min(dp[i],dp[i-coins[j]]+1);\n                    \n                }\n             else{\n                 break;\n             }\n                  \n            }\n        }\n        return dp[amount]>=amount+1?-1:dp[amount];         //if final cell is greater than amount which is impossible then return -1 else return that cell value\n    }\n};\n"
		],
		[
			6.976946974455174,
			4.573050519273264,
			6,
			30.5556,
			"class Solution {\npublic:\n    \n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1);\n        for(int i=0;i<=amount;i++) dp[i]=INT_MAX-1;// -1 for not to overflow\n        dp[0]=0;\n        for(int i=1;i<=amount;i++)\n        {\n            for(auto x: coins)\n            {\n               \n                    if(i-x>=0)\n                {\n                    dp[i]=min(dp[i],dp[i-x]+1);\n                }\n            }\n        }\n        if(dp[amount]==INT_MAX-1) return -1;\n        return dp[amount];\n    }\n};\n"
		],
		[
			20.557476954284954,
			4.573050519273264,
			6,
			39.7273,
			"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp (amount+1,amount+1);\n        dp[0] = 0;\n        for(int i=1;i<=amount;++i){\n            for(int coin:coins){\n                if(i-coin < 0) continue;\n                dp[i] = (dp[i] < dp[i-coin]+1)?dp[i]:dp[i-coin]+1;\n            }\n        }\n        return (dp[amount] == amount+1)?-1:dp[amount];\n    }\n};\n"
		],
		[
			7.475400252551959,
			4.573050519273264,
			5,
			29.0769,
			"class Solution {\npublic:    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1, amount+1);\n        dp[0] = 0;        \n        for(int i = 0; i <= amount; i++){            \n            for(auto c : coins){\n                if(i - c < 0) {\n                    continue;\n                }                \n                dp[i] = min(dp[i], dp[i-c]+1);\n            }            \n        }        \n        return dp[amount] < amount+1 ? dp[amount] : -1;\n    }\n};"
		],
		[
			19.35380562855652,
			4.266807006446484,
			7,
			23.5667,
			"const int m = 1e4 + 100; // max allowed amount < 1e4\nclass Solution {\n    int dp[m];\npublic:\n    int coinChange(vector<int>& coins, int amount){\n        sort(coins.begin(), coins.end()); // sort on basis on coin value\n        \n        for(int i=0;i<=amount;i++)\n            dp[i] = INT_MAX; // initialize\n        \n        dp[0] = 0; // no coin needed for 0 value\n        \n        for(int i=coins[0];i<=amount;i++){ // we can only make values > coins[0]\n            for(int j=0;j<coins.size();j++){\n                if(i < coins[j]) // we cant take any coin which comes after this\n                    break;\n                if(dp[i-coins[j]]!=INT_MAX) \n                    dp[i] = min(dp[i], 1 + dp[i-coins[j]]);// recurrence obvious\n            }\n        }\n        \n        if(dp[amount]==INT_MAX)\n            return -1;\n        \n        return dp[amount];\n    }\n};\n"
		]
	],
	"SIEVE": [
		"n",
		[
			6.4774429404455205,
			1.0,
			8,
			18.2143,
			"class Solution {\npublic:\n    bool isPrime(int num)\n    {\n        for(int i=2;i*i<=num;i++)\n        {\n            if(num%i==0)\n              return false;\n            \n        }\n        return true;\n    }\n    \n    int countPrimes(int n) \n    {\n      if(n==0 || n==1)\n          return 0;\n      int c=0;\n        \n      for(int i=2;i<n;i++)\n      {\n          if(isPrime(i))\n              c++;\n      }\n        return c;\n        \n    }\n};\n"
		],
		[
			5.829677344013032,
			1.0,
			6,
			22.1176,
			"class Solution {\npublic:\n    int countPrimes(int n)\n    {\n        std::bitset<1500000> primes;\n        primes.set();\n        primes.reset(0);\n        primes.reset(1);\n\n        for (int i = 2; i * i < n; ++i) {\n            if (!primes.test(i))\n                continue;\n\t\t\t\t\n            for (int j = i + i; j < n; j += i)\n                primes.reset(j);\n        }\n\n        int ret = 0;\n        for (int i = 2; i < n; ++i) {\n            if (primes.test(i))\n                ++ret;\n        }\n        \n        return ret;\n    }\n};\n"
		],
		[
			5.37398886408501,
			4.266807006446483,
			7,
			36.4167,
			"class Solution {\npublic:\n    int countPrimes(int n) \n    {\n        if(n<=1) return 0;\n        vector<int> sieve(n, -1);\n        sieve[0] = sieve[1] = 1;\n        for(int i=2; i<n; i++)\n        {\n            if(sieve[i]!=-1) continue;\n            for(int j=i+i; j<n; j+=i)\n            {\n                sieve[j] = 1;\n            }\n        }\n        int ans=0;\n        for(int i=2; i<n; i++)\n        {\n            if(sieve[i]==-1) ans++;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			6.322372194939005,
			1.0,
			7,
			16.5526,
			"class Solution {\npublic:\n    bool checkprime(int&number){\n        int stop = ceil((double)(sqrt(number)));\n        for(int div=3;div<=stop;div+=2){\n            if(number%div==0){return false;}\n        }\n        return true;\n    }\n    int countPrimes(int n) {\n        int result=(n>2)?1:0;\n        for(int numbers=3;numbers<n;numbers+=2){\n            if(checkprime(numbers)){result++;}\n        }\n        return result;\n    }\n};\n"
		],
		[
			6.766750934492882,
			1.0,
			9,
			20.8929,
			"class Solution\n{\nprivate:\n\nbool isPrime(int n)\n{\n    if(n == 0) return false;\n    if(n == 1) return false;\n    if(n == 2) return true;\n    \n    for(int i = 2; i * i <= n; i++)\n    {\n        if(n % i == 0) return false;\n    }\n    \n    return true;\n}\n\npublic:\n\nint countPrimes(int n) \n{\n    int res = 0;\n    \n    for(int i = 0; i < n; i++)\n    {\n        if(isPrime(i)) res++;\n    }\n    \n    return res;\n}\n};"
		],
		[
			5.358678581773735,
			1.0,
			7,
			27.7667,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        //Sieve of Eratosthenes\n        int primeNumbers = 0;\n        int arr[n+1];\n        for(int i=0;i<n;++i) arr[i] =1;\n        for(int i=2; i<=sqrt(n); ++i){\n            if(arr[i]==1)\n                for(int j=i*i; j<n; j+=i)\n                    arr[j] = 0;\n        }\n        for(int i=2;i<n;++i){\n            if(arr[i]==1)\n                ++primeNumbers;\n        }\n        return primeNumbers;\n    }\n};"
		],
		[
			5.529612508591848,
			4.266807006446484,
			6,
			27.0,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        vector<int> prime(n+1,1);\n        int p = 2;\n\n        while (p * p <= n) {\n            if (prime[p])\n                for (int i = p*p; i < n+1; i += p)        \n                    prime[i] = 0;\n            \n            ++p;\n        }\n    \n        int res = 0;\n        for (int k = 2; k < n; ++k)\n            if (prime[k])\n                ++res;\n    \n        return res;\n    }\n};"
		],
		[
			5.931294422759386,
			3.017083418859238,
			5,
			20.8125,
			"class Solution {\npublic:\nint countPrimes(int n) {\n        if(n < 2) return 0;\n        vector<bool> isPrime(n, true);\n        for(int i = 2; i*i < n; i++) {\n            if(!isPrime[i]) continue; \n            for(int j = i*i; j < n; j += i) isPrime[j] = false;\n        }\n        return accumulate(isPrime.cbegin() + 2, isPrime.cend(), 0);\n    }\n};"
		],
		[
			5.993372718229236,
			3.0170873154702496,
			6,
			35.0625,
			"class Solution {\npublic:int countPrimes(int n) {\n        if(n <= 2) return 0;\n        vector<bool> isPrime(n);\n        int total = (n - 2);\n        for(int i = 2; i*i < n; i++) {\n            if(isPrime[i]) continue;\n            for(int j = i; i*j < n; j ++) {    // j = i*i; j < n; j += i\n                if(!isPrime[j*i]) {\n                    isPrime[j*i] = true; total--;\n                }\n            }\n        }\n        // return accumulate(isPrime.cbegin() + 2, isPrime.cend(), 0);\n        return total;\n    }\n};"
		],
		[
			6.4425569183887275,
			3.017094467554443,
			5,
			18.4091,
			"class Solution {\npublic:\n    int countPrimes(int n)\n    {\n        if(n<=1)return 0;\n        vector<bool> V(n,true);\n        for(size_t i{2},s=sqrt(n);i<=s;++i)\n        {\n            if(V[i])\n            {\n                for(size_t jump{i*i};jump<V.size();jump+=i)\n                    V[jump]=false;\n            }\n        }\n        return std::accumulate(V.cbegin()+2,V.cend(),0);\n    }\n};"
		],
		[
			6.285060645517337,
			3.017120614593673,
			5,
			18.4091,
			"class Solution {\npublic:\n    int countPrimes(int n)\n    {\n        if(n<=1)return 0;\n        vector<bool> V(n,true);\n        for(size_t i{2},s=sqrt(n);i<=s;++i)\n        {\n            if(V[i])\n            {\n                for(size_t jump{i*i};jump<V.size();jump+=i)\n                    V[jump]=false;\n            }\n        }\n        return std::count(V.cbegin()+2,V.cend(),true);\n    }\n};"
		],
		[
			4.995801557004825,
			1.0,
			7,
			21.8947,
			"class Solution {\npublic:int countPrimes(int n) {\n        bool sieve[n+1];\n        memset(sieve, true, sizeof(sieve));\n        int cnt = 0;\n        \n         for(int even=4; even< n; even+=2){\n             sieve[even] = false;\n         }\n        \n        for(int i=2; i < sqrt(n); i++){\n            if(sieve[i] == true){\n                for(int j=i*i; j < n; j+=i){\n                    sieve[j] = false;\n                }\n            }\n        }\n        \n        for(int i=2; i < n; i++){\n            if(sieve[i]) cnt++;\n        }\n        return cnt;\n        \n    }\n};"
		],
		[
			5.616691641200909,
			3.01708573485726,
			6,
			27.4167,
			"class Solution {\npublic:int countPrimes(int n) {\n        if(n <= 2) return 0;\n        vector<bool> isPrime(n);\n        int total = (n - 2) / 2;\n        for(int i = 3; i*i < n; i += 2) {\n            if(isPrime[i]) continue;\n            for(int j = 3*i; j < n; j += 2*i) {\n                if(!isPrime[j]) {\n                    isPrime[j] = true; total--;\n                }\n            }\n        }\n        // return accumulate(isPrime.cbegin() + 2, isPrime.cend(), 0);\n        return total + 1;\n    }\n};"
		],
		[
			5.754592499739965,
			3.0171025655765233,
			6,
			21.7143,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> sieve(n, true);\n        for (int i = 2; i*i < n; ++i) {\n            if (sieve[i]) {\n                for (int j = 2*i; j < n; j += i) {\n                    sieve[j] = false;\n                }\n            }\n        }\n\t\tint count = 0;\n        for (int i = 2; i < n; ++i) {\n            if (sieve[i]) ++count;\n        }\n        return count;\n    }\n};"
		],
		[
			5.897248894070738,
			3.7836318622820992,
			6,
			17.0,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        if (n <= 2) return 0;\n        vector<int> primes{2};\n        for (int i = 3; i < n; i += 2) {\n            for (const int &p : primes) {\n                if (p*p > i) {\n                    primes.push_back(i);\n                    break;\n                }\n                if (!(i % p)) break;\n            }\n        }\n        return primes.size();\n    }\n};"
		],
		[
			5.8923362169271,
			3.0170822183660766,
			6,
			33.6471,
			"class Solution {\npublic:int countPrimes(int n) {\n        if(n <= 2) return 0;\n        vector<bool> isPrime(n, true);\n        int total = (n - 2);\n        for(int i = 2; i*i < n; i++) {\n            if(!isPrime[i]) continue;\n            for(int j = i; i*j < n; j ++) {    // j = i*i; j < n; j += i\n                if(isPrime[j*i]) {\n                    isPrime[j*i] = false; total--;\n                }\n            }\n        }\n        // return accumulate(isPrime.cbegin() + 2, isPrime.cend(), 0);\n        return total;\n    }\n};"
		],
		[
			6.182072986422277,
			3.0170683990392164,
			4,
			18.8214,
			"class Solution {\n\n public :\n     int countPrimes( int n) {\n\t \n         int res = 0 ;\n        vector < bool > prime(n, true );\n\t\t\n         for ( int i = 2 ; i <n; ++ i) {\n\t\t \n             if (prime[i]==false) continue ;\n             ++ res;\n\t\t\t \n             for ( int j = 2 ; i * j <n; ++ j) {\n                prime[i * j] = false ;\n            }\n        }\n        return res;\n    }\n};"
		],
		[
			5.803744032975024,
			3.6996821463185343,
			10,
			31.15,
			"class Solution {\npublic:\n    vector<int> primes = {2, 3, 5, 7, 11};\n    bool isPrime(int n) {\n        int lmt = sqrt(n), i = 1;\n        while (primes[i] <= lmt) {\n            if (n % primes[i++] == 0) return false;\n        }\n        return true;\n    }\n    int countPrimes(int n) {\n        if  (primes.back() < n) {\n            int lastBase, a, b;\n            if ((primes.back() - 1) % 6 == 0) lastBase = primes.back() + 5;\n            else {\n                lastBase = primes.back() + 7;\n                if (isPrime(primes.back() + 2)) primes.push_back(primes.back() + 2);\n            }\n            while (primes.back() < n) {\n                a = lastBase - 1;\n                b = lastBase + 1;\n                if (isPrime(a)) primes.push_back(a);\n                if (isPrime(b)) primes.push_back(b);\n                lastBase += 6;\n            }\n        }\n        return lower_bound(begin(primes), end(primes), n) - begin(primes);\n    }\n};\n"
		],
		[
			5.524443908665913,
			4.266807006446484,
			6,
			26.9167,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        vector<int> a(n,1);\n        for (int i = 2; i < n; ++i)\n            if (a[i] == 1)\n                for (int j = i * 2; j < n; j += i)\n                    a[j] = 0;\n        int cnt = 0;\n        for (int i = 2; i < n; ++i)\n            if (a[i] == 1)\n                ++cnt;\n        return cnt;\n    }\n};\n"
		],
		[
			6.702297307780915,
			1.0,
			5,
			17.2308,
			"class Solution {\npublic:int countPrimes(int n) {\n       int count=0;\n        for (int i=2;i<n; i++) \n       {\n        bool prime=true;\n        for (int j=2; j*j<=i; j++)\n        {\n            if (i % j == 0) \n            {\n                prime=false;\n                break;    \n            }\n        }   \n        if(prime) \n        count++;\n    } \n    \n       return count;\n    }    \n};"
		],
		[
			5.468294758049136,
			4.266807006446484,
			4,
			20.9231,
			"class Solution {\npublic:\n\tint countPrimes(int n) {\n\t\tint ans=0;\n\t\tvector<int> dp(n,1);\n\t\tfor(int i=2;i<n;i++){\n\t\t\tif(dp[i]==1){\n\t\t\t\tans++;\n\t\t\t\tint cur=i;\n\t\t\t\tint tem=2;\n\t\t\t\twhile(cur*tem<n){\n\t\t\t\t\tdp[cur*tem]=0;\n\t\t\t\t\ttem++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;   \n\t}\n};"
		],
		[
			5.453485108757373,
			4.266807006446484,
			6,
			26.1724,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        if(n == 0) return 0;\n        \n        vector <int> primes(n+1, 1);\n        primes[0] = primes[1] = 0;\n        for(int i=2;i*i<=n;i++) {\n            if(primes[i] == 1) {\n                for(int j=2;i*j<=n;j++) {\n                    primes[i*j] = 0;\n                }\n            }\n        }\n        \n\t\t// just doing this in case there were many test cases (couting number of ones uptill n-1 would have worked too!)\n        for(int i=1;i<=n;i++) primes[i] += primes[i-1];\n        \n        return primes[n-1];\n    }\n};\n"
		],
		[
			5.479687030304013,
			3.017069929018344,
			7,
			26.1071,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        if(n<2)return 0;\n        vector<bool> ans(n,true);\n        for(int i=2;i*i<n;i++){\n            if(ans[i]==true){\n                for(int j=i*i;j<n;j+=i){\n                    ans[j]=false;\n                }\n            }\n        }\n        int count=0;\n        for(int i=2;i<n;i++){\n            if(ans[i]==true)count++;\n        }\n        return count;\n    }\n};\n"
		],
		[
			5.5209432094999995,
			4.266807006446484,
			6,
			22.5,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        if (n==0 || n==1) return false;\n        vector<int> prime(n+1, 1);    // vector<int> is much faster than vector<bool>\n        for (int p = 2; p*p < n; ++p) {\n            if (!prime[p]) continue;\n            for (int d = 2; (p*d) < n; ++d)\n                prime[p*d] = 0;\n        }\n        return accumulate(prime.begin(), prime.end(), -3);\n    }\n};\n"
		],
		[
			1.0,
			4.092673215965582,
			7,
			33.8889,
			"class Solution {\npublic:\n  int countPrimes(int n) {\n    static vector<int> sieve;\n    if (n <= 2) return 0;\n    if (sieve.size() < n/2) {\n      sieve.resize(n/2, 1);\n      for (int p = 3; p*p < n; p += 2) {\n        if (!sieve[p/2]) continue;\n        int pp = max(sieve[p/2], p*p);\n        for (; pp < n; pp += 2*p)\n          sieve[pp/2] = 0;\n        sieve[p/2] = pp;\n      }\n    }\n    int result = 0;\n    for (int i = 0; i < n/2; ++i)\n      result += !!sieve[i];\n    return result;\n  }\n};\n"
		],
		[
			4.884746356965687,
			4.266807006446484,
			6,
			24.6667,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        vector<int> primes(n+1,0);\n        int totalPrimes=0;\n        //Making all odd numbers as potential prime numbers bcz except 2(special case) no other number is prime\n        for(long long int i=3;i<n;i+=2){\n            primes[i]=1;\n        }\n        //sieve of eratosthenes\n        for(long long int i=3;i<n;i++){\n            //if the current number is assigned 1 it is a prime number bcz we only assign 1 to prime numbers\n            if(primes[i]==1){\n                //if the number is prime increase the total count of prime numbers\n                totalPrimes++;\n                //mark all of its multiple as 0(not prime)\n                // we have started the loop from i*i bcz before that the multiples of i are already marked 0 by the previous prime numbers as they were divisible by atleast one previos prime number.\n                for(long long int j=i*i;j<=n;j+=i){\n                    primes[j]=0;\n                }\n            }\n        }\n        //special case to handle 2 as 2 is the only even prime number\n        if(n>2){\n            totalPrimes++;\n        }\n        return totalPrimes;\n    }\n};\n"
		],
		[
			4.811715132951366,
			1.0,
			9,
			26.0,
			"class Solution {\npublic:\n\tint countPrimes(int n) {\n\t\tif(n==0 ||n==1)return 0;\n\n\t\tbool prime[n+1];\n\n\t\tfor(int i=2;i<n;i++){\n\t\t\tprime[i]=true;\n\t\t}\n\n\t\tfor(int p=2; p*p<n; p++){\n\n\t\t\tif(prime[p]==true){\n\n\t\t\t\tfor(int j=p*p;j<n;j+=p)\n\t\t\t\t\tprime[j]=false;\n\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\tfor(int i=2;i<n;i++){\n\t\t\tif(prime[i]==true)ans++;\n\t\t}\n\n\t\treturn ans;\n\n\t}\n};\n"
		],
		[
			5.595381829770765,
			3.01708482540534,
			5,
			20.6522,
			"class Solution {\npublic:int countPrimes(int n) {\n        if(n<=1) return 0;\n \n        vector<bool> isPrime(n,true);\n//         we will mark 0 and 1 as false manually \n        isPrime[0]=isPrime[1]=false;\n        \n        for(int i=2;i*i<n;++i) {\n            \n            if(isPrime[i]) {\n                for(int j=i*i;j<n;j+=i) {\n                    isPrime[j]=false;\n                }\n            }\n        }\n        return count(isPrime.begin(),isPrime.end(),true);\n}\n};"
		],
		[
			5.242272857230396,
			3.0171254048488114,
			6,
			22.8704,
			"class Solution {\npublic:\n    int countPrimes(int n) {\n        if(n<3)return 0;\n        vector<bool>ntp(n,false);//ntp::=notPrime,initially assuming all odd numbers are prime so for of them ntp is false\n        int lim=sqrt(n),ans=n/2;//assuming all odd numbers are prime,so assumed no of primes=n/2 (half of the numbers are odd)\n        for(int i=3;i<=lim;i+=2)//i+=2 for loading only odd numbers.\n            if(!ntp[i])//if prime we need to subtract it's odd multiples\n                for(int j=i*i;j<n;j+=2*i)//odd multiples only j=i*i+even*i=i*(i+even)=odd multiples as i is odd,so (i+even) is odd.\n                {\n                    if(!ntp[j]){//wrongly assumed before so we need to update the anwer as it was included in the answer number.\n                        ans--;\n                        ntp[j]=true;\n                    }\n                }\n        return ans;\n    }\n};\n"
		]
	],
	"FIB": [
		"2^n",
		[
			1631787956.8847885,
			1.0,
			3,
			11.4286,
			"class Solution {\npublic:\n    int fib(int n) {\n        if(n==0){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        return fib(n-1)+fib(n-2);\n    }\n};\n\n\n\n"
		],
		[
			4.292815967586478,
			1.0,
			3,
			14.7727,
			"class Solution {\npublic:\n    int fib(int N) {\n        if (N <= 1)\n            return N;\n        int a = 0;\n        int b = 1;\n        for (int j = 2; j < N; j++) {\n            int c = a + b;\n            a = b;\n            b = c;\n        }\n        return a + b;\n    }\n};\n"
		],
		[
			4.299485062549888,
			1.0,
			2,
			12.6667,
			"class Solution {\npublic:\n    int fib(int N) {\n        int cur = 0;\n        int pre = 1;\n        int i = 0;\n        while(i++<N){\n            cur = cur + pre;\n            pre = cur - pre;\n        }\n        return cur;\n    }\n};\n"
		],
		[
			4.400034069373604,
			1.0,
			4,
			17.1818,
			"class Solution {\npublic:\n    int fib(int n) {\n        if(n==0||n==1)\n            return n;\n        int a=0,b=1,c;\n        for(int i=2;i<=n;i++)\n        {\n            c=a+b;\n            a=b;\n            b=c;\n        }\n        return c;\n    }\n};\n"
		],
		[
			4.395888834978805,
			1.0,
			3,
			15.9091,
			"class Solution {\npublic:\n    int fib(int N) {\n        int a=0,b=1,c;\n        if(N<2)\n            return N;\n        for(int i=2;i<=N;i++)\n        {\n            c  =a + b;\n            a = b; \n            b = c; \n        }\n        return b;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			23.5455,
			"class Solution \n{\nprivate:\n  int cache[31];\npublic:\n    Solution()\n    {\n        cache[0] = 0;\n        cache[1] = 1;\n        for(int i=2;i<31;i++)\n            cache[i]=-1;\n    }\n    \n    int fib(int N) \n    {\n      if(cache[N] != -1)\n      {\n        return cache[N];   \n      }\n      cache[N] = fib(N-1)+fib(N-2);\n\n      return cache[N];\n    }\n};\n"
		],
		[
			4.459007483069866,
			1.0,
			4,
			17.1364,
			"class Solution {\npublic:\nint fib(int N) {\n\n    if(N == 0) return 0;\n    if(N == 1) return 1;\n    \n    int xNm2 = 0;\n    int xNm1 = 1;\n    int xN = 0;\n    \n    for(int i = 2; i <= N; i++)\n    {\n        xN = xNm1 + xNm2;\n        xNm2 = xNm1;\n        xNm1 = xN;\n    }\n    \n    return xN;\n    \n}\n};"
		],
		[
			29171703.867576417,
			1.0,
			2,
			19.5,
			"class Solution {\npublic:\n    int fib(int N) {\n        int fib[31];\n        fib[0] = 0;\n        fib[1] = 1;\n        for(int i=2;i<=N;i++){\n            fib[i] = fib[i-1]+fib[i-2];\n        }\n        return fib[N];\n    }\n};\n"
		],
		[
			4.274069761753719,
			1.0,
			4,
			20.3,
			"class Solution {\npublic:\n    int fib(int N) {\n        int f=0, a=0, b=1;\n        if(N==0)    return 0;\n        if(N==1)    return 1;\n        for(int i=0; i<N; i++)\n        {\n            f=a+b;\n            a=b;\n            b=f;\n        }\n        return a;\n    }\n};\n"
		],
		[
			4.3429037031408155,
			1.0,
			4,
			17.8182,
			"class Solution {\npublic:int fib(int N) {\n        if(N==0)\n            return 0;\n        if(N==1)\n            return 1;\n        int a=0,b=1,ans;\n        for(int i=2;i<=N;i++)\n        {  \n            ans = a + b;\n            a=b;\n            b=ans;\n        }\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.0,
			"class Solution {\npublic:\n\tint dp[31];\n\tint getResult(int n)\n\t{\n\t\tif(n <= 0)\n\t\t\treturn 0;\n\t\tif(dp[n] != 0)\n\t\t\treturn dp[n];\n\t\tdp[n] = getResult(n-1) + getResult(n-2);\n\t\treturn dp[n];\n\t}\n\tint fib(int N) {\n\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[1] = 1;\n\t\treturn getResult(N);\n\t}\n};"
		],
		[
			4.475706336107635,
			1.0,
			4,
			21.0909,
			"class Solution {\npublic:\n    int fib(int n) {\n        if (n==0) return 0;\n        if(n<2) return 1;\n        long a=0,b=1,c=0;\n        for(int i=2;i<=n;i++){\n            c=a+b;\n            a=b;\n            b=c;\n        }\n        return c;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			13.4615,
			"class Solution {\npublic:\n    int fib(int N) {\n\t\tfloat z = sqrt(5);\n        long long int t = (pow(2,N)*z);\n        long long int a = (pow(1+z,N));\n        long long int b = (pow(1-z,N));\n        return (a-b)/t;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			57.12,
			"class Solution {\npublic:\nvoid matvec_update(const uint32_t* A, uint32_t* s){\n    uint32_t s_new[2];\n    s_new[0] = A[0]*s[0] + A[1]*s[1];\n    s_new[1] = A[2]*s[0] + A[3]*s[1];\n    s[0] = s_new[0]; s[1] = s_new[1];\n}\n\nvoid mat_squared(uint32_t* A){\n    uint32_t A_sq[4];\n    A_sq[0] = A[0]*A[0] + A[1]*A[2];\n    A_sq[1] = A[1]*(A[0] + A[3]);\n    A_sq[2] = A[2]*(A[0] + A[3]);\n    A_sq[3] = A[3]*A[3] + A[1]*A[2];\n    A[0] = A_sq[0];\n    A[1] = A_sq[1];\n    A[2] = A_sq[2];\n    A[3] = A_sq[3];\n}\n\n    int fib(int N) {\n        if( N == 0 ){ return 0; }\n        const uint32_t n = N-1;\n        uint32_t A[4] = {1, 1, 1, 0}, sn[2] = {1, 0};\n        uint32_t bit_idx = 1;\n        while( bit_idx <= n ){\n            if( n & bit_idx ){\n                matvec_update(A, sn);\n            }\n            mat_squared(A);\n            bit_idx = bit_idx << 1;\n        }\n        \n        return sn[0];\n    }\n};"
		],
		[
			4.986662432246396,
			4.266807006446484,
			4,
			28.9,
			"class Solution {\npublic:\n    int fib(int N) {\n        if(N == 0) return 0;\n        if(N == 1) return 1;\n        vector<int> a(N + 1);\n        a[0] = 0;\n        a[1] = 1;\n        int i = 2;\n        while(i <= N)\n            a[i++] = a[i - 1] + a[i - 2];\n        return a[N];\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			17.1364,
			"class Solution {\npublic:\n    Solution(){\n        f[0] = 0;\n        f[1] = 1;\n        for(int i=2; i<31; ++i) f[i] = f[i-1] + f[i-2];\n    }\n    int fib(int N) {\n        return f[N];\n    }\nprivate:\n    int f[31];\n};\n"
		],
		[
			4.4270942931717405,
			1.0,
			3,
			15.9091,
			"class Solution {\npublic:\n    int fib(int N) {\n        int a = 0, b = 1, c;\n        if (N < 2) return N;\n        \n        for (int i=2; i<=N; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return c;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			7.5,
			"class Solution {\npublic:    int fib(int n) {\n        \n\t\tdouble phi = (1 + sqrt(5)) / 2; \n\t\treturn round(pow(phi, n) / sqrt(5));\n    \n    }\n};"
		],
		[
			1458216926.6480389,
			1.0,
			3,
			11.4286,
			"class Solution {\npublic:\n    int fib(int N) {\n        if(N==0) return 0;\n        if(N==1) return 1;\n        return fib(N-1)+fib(N-2);\n    }\n};\n"
		],
		[
			4.93239603643032,
			1.0,
			2,
			9.16667,
			"class Solution {\npublic:int fib(int n)\n{\n\tint a=0, b=1;\n\tfor (; n--; a=exchange(b,a+b));\n\treturn a;   \n}\n};"
		],
		[
			4.407948588744117,
			1.0,
			4,
			17.1364,
			"class Solution {\npublic:\n    int fib(int N) \n    {\n        int n1 = 0;\n        int n2 = 1;\n        int answer = 0;\n        if(N == 0) return 0;\n        if(N == 1) return 1;\n        \n        for(int i = 2 ; i <= N; i++)\n        {\n            answer = n1+n2;\n            n1 = n2;\n            n2 = answer;\n        }\n        return answer;\n    }\n};\n"
		],
		[
			4.983068297412377,
			4.266807006446484,
			2,
			21.6,
			"class Solution {\npublic:int fib(int N) {\n        vector<int> dp(N+2, 0);\n        dp[1] = 1;\n        for(int i = 2; i <= N; i++){\n            dp[i] = dp[i-1] + dp[i-2];\n        }    \n        return dp[N];\n    }\n};\n"
		],
		[
			4.38299194750407,
			1.0,
			4,
			19.6,
			"class Solution {\npublic:\n    int fib(int n) {\n        int t1=0;\n        int t2=1;\n        int total;\n        if (n==0)\n\t\t{\n            return 0;\n        }\n        else if (n==1)\n\t\t{\n            return 1;\n        }\n        else\n\t\t{\n\t\t\tfor (int i=1; i<n; i++)\n\t\t\t{\n\t\t\t\ttotal = t1 + t2;\n\t\t\t\tt1 = t2;\n\t\t\t\tt2 = total;\n\t\t\t}\n        return total;\n        }\n    }\n};\n \n"
		],
		[
			4.306997079044316,
			1.0,
			3,
			24.8,
			"class Solution {\npublic:\n    int fib(int N)\n    {\n        int prev[] = { 0, 1 }; \n        int p = 0; \n        if (N <= 1) {\n            return N;\n        } else {\n            for (int i = 2; i <= N; i++) {\n                prev[p] = prev[0] + prev[1];\n                p = (p + 1) % 2;\n            }\n            return prev[(p + 1) % 2];\n        }\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			24.375,
			"template <int N>\nstruct Fib {\n\tenum {\n\t\tvalue = Fib<N - 2>::value + Fib<N - 1>::value,\n\t};\n};\n\ntemplate <>\nstruct Fib<1> {\n\tenum {\n\t\tvalue = 1,\n\t};\n};\n\ntemplate <>\nstruct Fib<0> {\n\tenum {\n\t\tvalue = 0,\n\t};\n};\n\ntemplate <int N>\nstatic inline int fibn(int n)\n{\n\tif (n == N)\n\t\treturn Fib<N>::value;\n\treturn fibn<N - 1>(n);\n}\n\ntemplate <>\nint fibn<-1>(int n)\n{\n\treturn -1;\n}\n\n\nclass Solution {\npublic:\n    int fib(int N) {\n        return fibn<30>(N);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			7.5,
			"class Solution {\npublic:int fib(int N) {\n       double phi = (1 + sqrt(5)) / 2; \n        return round(pow(phi, N) / sqrt(5)); \n    }\n};"
		],
		[
			1485784728.3351612,
			1.0,
			2,
			10.8333,
			"class Solution {\npublic:int fib(int n) {\n\tif (n < 2) {\n\t\treturn n;\n\t}\n\treturn fib(n - 1) + fib(n - 2);\n}\n};"
		],
		[
			5.953090011171787,
			4.266807006446483,
			4,
			33.4444,
			"class Solution {\npublic:\nint fib(int n) {\n\tvector<int> cache(n + 1, -1);\n\treturn fib_impl(n, cache);\n}\n\nint fib_impl(int n, vector<int>& cache) {\n\tif (n < 2) {\n\t\tcache[n] = n;\n\t\treturn n;\n\t}\n\tif (cache[n] != -1) {\n\t\treturn cache[n];\n\t}\n\tcache[n] = fib_impl(n - 1, cache) + fib_impl(n - 2, cache);\n\treturn cache[n];\n}\n};"
		],
		[
			4.236069991776071,
			1.0,
			2,
			14.7692,
			"class Solution {\npublic:\nint fib(int n) {\n\tsize_t a = 0;\n\tsize_t b = 1;\n\tfor (size_t i = 0; i != n; ++i) {\n\t\t// a, b = a + b, a\n\t\tauto tmp = a;\n\t\ta += b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			31.3438,
			"// @return x^n.\nclass Solution {\npublic:\nint pow(int x, int n) {\n\t// ...\n\tint ret = 1;\n\twhile (n != 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tret *= x;\n\t\t}\n\t\tx *= x;\n\t\tn /= 2;\n\t}\n\treturn ret;\n}\n\nint fib(int n) {\n\t// matrix:\n\t// |r00 r01|\n\t// |r10 r11|\n\tsize_t r00 = 1;\n\tsize_t r01 = 0;\n\t// r10 and r11 can be ignored, because r01 doesn't depend on them.\n\n\tsize_t x00 = 1;\n\tsize_t x01 = 1;\n\tsize_t x10 = 1;\n\tsize_t x11 = 0;\n\twhile (n != 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tconst auto r00_t = r00;\n\t\t\tr00 = r00 * x00 + r01 * x10;\n\t\t\tr01 = r00_t * x01 + r01 * x11;\n\t\t}\n\t\tconst auto x01_x_x10 = x01 * x10;\n\t\tx01 = x00 * x01 + x01 * x11;\n\t\tx10 = x00 * x10 + x10 * x11;\n\t\tx00 = x00 * x00 + x01_x_x10;\n\t\tx11 = x01_x_x10 + x11 * x11;\n\n\t\tn /= 2;\n\t}\n\treturn r01;\n}\n};"
		],
		[
			1.0,
			1.0,
			1,
			7.33333,
			"class Solution {\npublic:\nint fib(int n) {\n\tconst double phi = (1 + sqrt(5)) / 2;\n\treturn round(pow(phi, n) / sqrt(5));\n}\n};"
		],
		[
			5.029606386423588,
			4.266807006446483,
			4,
			28.6364,
			"class Solution {\npublic:\n    int fib(int n) {\n        if (n == 0 || n == 1) {\n            return n;\n        }\n        vector<int> dp(n, 0);\n        dp[0] = dp[1] = 1;\n        for (int i = 2; i < dp.size(); i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n - 1];\n    }\n};"
		],
		[
			1493891715.8973358,
			1.0,
			3,
			10.7143,
			"class Solution {\npublic:\n    int fib(int n) {\n        if (n == 1 || n == 0) {\n            return n;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n};"
		],
		[
			1519910917.438066,
			1.0,
			3,
			10.7143,
			"class Solution {\npublic:\n    int fib(int n) {\n        if (n == 1 || n == 0) {\n            return n;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n};\n"
		],
		[
			1509807807.3914726,
			1.0,
			2,
			11.25,
			"//recursion [Runtime: 12 ms, faster than 27.75% ]\nclass Solution {\npublic:\n    int fib(int n) {\n         if (n <= 1) \n            return n; \n         return fib(n-1) + fib(n-2); \n    }\n};"
		],
		[
			1.0,
			1.0,
			1,
			21.6364,
			"//memoization \nclass Solution {\npublic:\n    int fib(int n,int dp[]) {\n        if (n <= 1) \n           return n; \n        \n        if (dp[n] != -1) \n           return dp[n];\n        \n        return dp[n]=fib(n-1) + fib(n-2);\n    }\n    int fib(int n) {\n        int dp[31];\n        memset(dp, -1, sizeof(dp)); \n        return fib(n,dp);\n    }\n};"
		],
		[
			6.033851488586934,
			4.266807006446484,
			5,
			28.5,
			"class Solution {\npublic:\nint fib(int n) {\n        vector<int> dp(n+1,-1);\n        return findFib(n,dp);\n    }\n    int findFib(int n,vector<int>& dp){\n        if(n == 0 || n==1)\n            return n;\n        if(dp[n]!= -1)\n            return dp[n];\n        dp[n]=findFib(n-1,dp) + findFib(n-2,dp);\n        return dp[n];\n    }\n};"
		],
		[
			5.007952531633456,
			4.266807006446484,
			4,
			29.45,
			"class Solution {\npublic:\n    int fib(int n) {\n        vector<int> dp(n+1,-1);\n        for(int i=0;i<=n;i++){\n            if(i==0 || i==1)\n                dp[i]=i;\n            else{\n                dp[i]=dp[i-1]+dp[i-2];\n            }\n        }\n        return dp[n];\n    }\n   \n};"
		],
		[
			1523198658.4991193,
			1.0,
			3,
			12.5714,
			"class Solution {\npublic:\nint fib(int N) {\n\n    if(N==0){\n        return 0;\n    }else if(N==1){\n        return 1;\n    }else{\n        return fib(N-1)+fib(N-2);\n    }\n}\n};"
		],
		[
			4.368606345922862,
			1.0,
			3,
			18.2,
			"class Solution {\npublic:\n    int fib(int N) {\n        if(N == 1){\n            return 1;\n        }\n        int result = 0,a = 0,b = 1;\n        for(int i = 1;i < N;i++){\n            result = (a+b);\n            a = b;\n            b = result;\n        }\n        return result;\n    }\n};"
		],
		[
			6.57800785717457,
			1.0,
			7,
			45.6,
			"class Solution {\npublic:\nint countways(int N, int* memo)\n{\nif(N<0) return 0;\nelse if(N==0) return 0;\nelse if(N==1) return 1;\nelse if(memo[N]>-1) return memo[N];\nelse memo[N] = (countways((N-1), memo)+countways((N-2), memo));\nreturn (memo[N]);\n}\n\nint fib(int N) \n{           \n    int memo[N+1];\n    for(int i=0; i<N+1; i++)\n        memo[i] = -1;\n    return (countways(N, memo));\n}\n};"
		],
		[
			4.359625943595786,
			1.0,
			4,
			17.0455,
			"class Solution {\npublic:\nint fib(int N) {\nif(N == 1) return 1;\nif(N == 0) return 0;\nunsigned int a = 0, b = 1, i = 2;\nwhile(i++ <= N) {\nb += a;\na = b - a;\n}\nreturn b;\n}\n};"
		],
		[
			1.0,
			1.0,
			1,
			9.57895,
			"// formula for nth term in the fibonacci series Fn = {[(\u221a5 + 1)/2] ^ n} / \u221a5 \nclass Solution {\npublic:\n    int fib(int n) {\n         double phi = (1 + sqrt(5)) / 2; \n         return round(pow(phi, n) / sqrt(5));\n    }\n};\n"
		],
		[
			4.3691022474671435,
			1.0,
			3,
			15.3636,
			"class Solution {\npublic:\n    int fib(int n) {\n        if(n<2)return n;\n        int x=0,y=1,res=0;\n        for(int i=1;i<n;i++){\n            res=x+y;\n            x=y;\n            y=res;\n        }\n        return res;\n    }\n};\n"
		],
		[
			1515796499.3140943,
			1.0,
			2,
			11.9167,
			"class Solution {\npublic:\n    int fib(int n) {\n        if(n<2)return n;\n        else return fib(n-1)+fib(n-2);\n    }\n};\n"
		],
		[
			7.466472481061607,
			1.0,
			3,
			16.0,
			"class Solution {\npublic:\n\nSolution() {\n\n    res[0] = 0;\n    res[1] = 1;\n         \n    int xNm2 = 0;\n    int xNm1 = 1;\n    int xN = 0;\n    \n    for(int i = 2; i <= 30; i++)\n    {\n        xN = xNm1 + xNm2;\n        xNm2 = xNm1;\n        xNm1 = xN;\n        \n        res[i] = xN;\n    }\n}\n\nint fib(int N) {\n    return res[N];\n}\n\nstatic int res[31];\n};\n\nint Solution::res[31];"
		],
		[
			1.0,
			1.0,
			3,
			14.6667,
			"class Solution {\npublic:\n    int fib(int N) {\n        if (N < 2) return N;\n        if (N == 2) return 1;\n        return fib(N - 1) + fib(N - 2);\n    }\n};"
		]
	],
	"INORDER_TRAVERSAL": [
		"n",
		[
			7.0839815269577455,
			15.216675489641679,
			2,
			14.3929,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> ans;\n    vector<int> inorderTraversal(TreeNode* root) {\n        if(root==NULL)\n            return {};\n        inorderTraversal(root->left);\n        ans.push_back(root->val);\n        inorderTraversal(root->right);\n        return ans;\n    }\n};\n"
		],
		[
			7.720443369934414,
			5.763290953010267,
			6,
			20.8,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode *root) {\n        vector<int> result;\n        stack<TreeNode*> visit;\n        set<TreeNode*> visited;\n        if(root == NULL)\n            return result;\n        visit.push(root);\n        while(!visit.empty()) {\n            TreeNode* node = visit.top();\n            if(visited.find(node) == visited.end()) {\n                visited.insert(node);\n                if(node->left != NULL)\n                    visit.push(node->left);\n            } else {\n                result.push_back(node->val);\n                visit.pop();\n                if(node->right != NULL)\n                    visit.push(node->right);\n            }\n        }\n        return result;\n    }\n};"
		],
		[
			6.886775927321179,
			16.312042386575154,
			2,
			13.3226,
			"class Solution {\n\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) \n    {\n\t\t//do traversal only if the tree is not empty\n        if( root )\n        {\n\t\t\t//traverse left sub tree first\n            inorderTraversal(root->left);\n\t\t\t\n\t\t\t//visit the root node\n            result.push_back(root->val);\n\t\t\t\n\t\t\t//traverse right sub tree last\n            inorderTraversal(root->right);\n        }\n\t\t//return the result \n        return result;\n    }\nprivate:\n\t//vector to store values if any\n    vector<int> result;\n};\n"
		],
		[
			6.106240609349004,
			5.356860999865066,
			4,
			19.4318,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tvector<int> inorderTraversal(TreeNode* root)\n\t{\n\t\tvector<int> traversed_values;\n\t\tstack<TreeNode*> to_traverse;\n\n\t\tTreeNode* current = root;\n\n\t\twhile (current != nullptr || !to_traverse.empty()) {\n\t\t\tif (current != nullptr) {\n\t\t\t\tto_traverse.push(current);\n\t\t\t\tcurrent = current->left;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent = to_traverse.top();\n\t\t\t\tto_traverse.pop();\n\t\t\t\ttraversed_values.push_back(current->val);\n\t\t\t\tcurrent = current->right;\n\t\t\t}\n\t\t}\n\t\treturn traversed_values;\n\t}\n};\n"
		],
		[
			5.843457696493484,
			5.398445811221528,
			3,
			18.375,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n   void pot(TreeNode*root,vector<int>&v)\n    {    if(root==NULL) return;\n         pot(root->left,v);\n         v.push_back(root->val);\n         pot(root->right,v);\n        \n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int>v;\n        pot(root,v);\n        return v;\n    }\n};\n"
		],
		[
			6.121956001905447,
			5.394852370811171,
			5,
			19.975,
			" class Solution {\n public:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n     vector<int> inorderTraversal(TreeNode* root){ \n         if(root==NULL)\n            return {};\n         vector<int> vec;\n         stack<TreeNode*> s;\n         while(true){\n             if(root!=NULL){\n                s.push(root);\n                root=root->left; \n             }\n             else{\n                 if(s.empty())\n                     break;\n                 root=s.top();\n                 s.pop();\n                 vec.push_back(root->val);\n                 root=root->right;\n             }\n         }\n         return vec;\n     }\n };\n"
		],
		[
			5.823345905767972,
			5.383632550181898,
			3,
			18.375,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> v;\n        helper(root,v);\n        return v;\n    }\n    void helper(TreeNode* root,vector<int> &v)\n    {\n        if(root==NULL)\n            return ;\n        helper(root->left,v);\n        v.push_back(root->val);\n        helper(root->right,v);\n    }\n};\n"
		],
		[
			6.0976424700769485,
			5.3985998500447305,
			5,
			19.5,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> v;\n        if(root==NULL)\n            return v;\n        stack<TreeNode*>s;\n        TreeNode* current=root;\n        while(!s.empty() || current!=NULL)\n        {\n            while(current!=NULL)\n            {\n                s.push(current);\n                current=current->left;\n            }\n            current=s.top();\n            s.pop();\n            v.push_back(current->val);\n            current=current->right;\n        }\n        return v;\n    }\n};\n"
		],
		[
			5.926818800930843,
			5.389782360941895,
			7,
			35.0,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> v;\n        if(root==NULL)\n            return v;\n        \n        TreeNode* current=root;\n        \n        while(current!=NULL)\n        {\n            if(current->left==NULL)\n            {\n                v.push_back(current->val);\n                current=current->right;\n            }\n            else{\n                TreeNode* preNode=current->left;\n                \n                while(preNode->right!=NULL && preNode->right!=current)\n                    preNode=preNode->right;\n                \n                if(preNode->right==current)\n                {\n                    v.push_back(current->val);\n                    preNode->right=NULL;\n                    current=current->right;\n                }\n                else\n                {\n                    preNode->right=current;\n                    current=current->left;\n                }\n            }\n        }\n        return v;\n    }\n};\n"
		],
		[
			5.920213364743193,
			5.325545378623863,
			3,
			16.7222,
			"class Solution {\n\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        \n        inOrder(root, ans);\n        \n        return ans;\n    }    \n    private:\n    void inOrder(TreeNode* root, vector<int> &vec){\n        \n        if(root != NULL){\n            inOrder(root->left, vec);\n            vec.push_back(root->val);\n            inOrder(root->right, vec);\n        }\n        \n    }\n    \n};\n"
		],
		[
			5.858426994029267,
			5.320931467183026,
			2,
			19.6,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector <int> vec;\n        inorderTraversal (root, vec);\n        return vec;  \n    }\n    \n   void inorderTraversal(TreeNode* root , vector <int> &vec){\n       if (root != NULL){\n           inorderTraversal (root->left , vec);\n           vec.push_back(root->val);\n           inorderTraversal (root->right , vec);\n       }\n   }\n    \n};\n"
		],
		[
			6.817662079356847,
			15.219540448675755,
			2,
			14.3929,
			"class Solution {\npublic:\n#include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> vec;\n    vector<int> inorderTraversal(TreeNode* root) {\n        if(root==nullptr) return {};\n        inorderTraversal(root->left);\n        vec.push_back(root->val);\n        inorderTraversal(root->right);\n        return vec;\n    }\n};\n"
		],
		[
			6.176112955670824,
			5.380154208145435,
			5,
			24.9153,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    // Recursive Method\n    \n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root)\n    {\n        TreeNode *ptr = root;\n        vector <int> ans;\n        stack <TreeNode*> address;\n        \n        if(root == NULL)\n            return ans;\n        \n        // until address stack is empty and ptr points to NULL i.e. Traversal is over\n        while( !address.empty() || ptr != NULL )\n        {\n            // if ptr points to a child\n            if(ptr != NULL)\n            {\n                // pushing the address to the stack\n                address.push(ptr);\n                // moving left\n                ptr = ptr->left;                    // LEFT\n            }\n            else\n            {\n                // popping the address and making ptr point to it, kinda backtrack a step\n                ptr = address.top();\n                address.pop();\n                // printing or pushing the value of node to array\n                ans.push_back(ptr->val);            // PRINT\n                // movinf left\n                ptr= ptr->right;                    // RIGHT\n            }\n        }  \n        return ans;\n    }\n};\n"
		],
		[
			6.4429024444222325,
			5.384990699992939,
			7,
			31.8778,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void inorder(TreeNode* root,stack<pair<TreeNode*,int>> &s,vector<int> &ans){\n        while(!s.empty()){\n            while(s.top().first->left && s.top().second==0){\n                s.top().second=1;\n                s.push(make_pair(s.top().first->left,0));\n            }\n            ans.push_back(s.top().first->val);\n            s.top().second=1;\n            pair<TreeNode*,int> temp=s.top();\n            s.pop();\n            if(temp.first->right){\n                s.push(make_pair(temp.first->right,0));\n            }\n        }\n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        stack<pair<TreeNode*,int>> s;\n        /*will have to maintain if left subtree has\n        been checked for this node or not 0 for not checked 1 for checked*/\n        if(root){\n            s.push(make_pair(root,0));\n            inorder(root,s,ans);\n        }\n        return ans;\n    }\n};\n"
		],
		[
			6.091276357041339,
			5.325477395298673,
			5,
			19.3421,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> out;\n        stack<TreeNode*> s;\n        if(root == NULL)\n            return out;\n        while(root!=NULL || !s.empty())\n        {\n            while(root!=NULL)\n            {\n                s.push(root);\n                root = root->left;\n            }\n            \n            root = s.top();\n            s.pop();\n            out.push_back(root->val);\n            root = root->right;\n        }\n        return out;\n    }\n};\n"
		],
		[
			5.850846765211419,
			5.4104886893102355,
			3,
			18.375,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void Traverse(TreeNode* root, vector<int>& res){\n        if(root != NULL){\n            Traverse(root->left, res);\n            res.push_back(root->val);\n            Traverse(root->right, res);\n        }\n    }\n    vector<int> inorderTraversal(TreeNode* root){\n        vector<int> res;\n        Traverse(root, res);\n        return res;\n    }\n};"
		],
		[
			6.114995913622996,
			5.275986558179746,
			4,
			14.4828,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    stack <TreeNode * > s;\n    void mypush(TreeNode * node) // pushes a node and all its left members onto stack\n    {\n        while(node)\n        {\n            s.push(node);\n            node = node->left;\n        }\n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector <int> res; \n        mypush(root);\n        while(!s.empty())\n        {\n            TreeNode * p = s.top();\n            res.push_back(p->val);\n            s.pop();\n            mypush(p->right);\n        }\n        return res;\n    }\n};\n"
		],
		[
			5.897298611979611,
			5.3578684544403705,
			5,
			21.0,
			"class Solution {\npublic:\n#include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> v;\n        inorder(&v,root);\n        return v;\n    } \n    void inorder(vector<int> *v,TreeNode* root)\n{   if(root==NULL)\n        return ;\n    if(root->left!=NULL)\n        inorder(v,root->left);\n    v->push_back(root->val);\n    if(root->right!=NULL)\n        inorder(v,root->right);\n    \n    return;\n}\n};\n"
		],
		[
			6.105029314046028,
			5.364116314201602,
			4,
			20.4545,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        //insertNode(root,ans);\n        stack<TreeNode*> nodes;\n        // nodes.push(root);\n        while(!nodes.empty() || root!=NULL){\n            while(root!=NULL){\n                //cout<<root->val<<endl;\n                nodes.push(root);    \n                root=root->left;\n            }\n            root=nodes.top();\n            // cout<<root->val<<endl;\n            ans.push_back(root->val);\n            nodes.pop();\n            root=root->right;\n        }\n        return ans;\n    }\n    \n    \n};\n"
		],
		[
			5.887424135674839,
			5.443567509546898,
			3,
			15.0312,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> ans;\n    vector<int> inorderTraversal(TreeNode* root) {\n        make(root);\n        return ans;\n        \n    }\n    void make(TreeNode* root){\n        if(root==NULL){\n            return;\n        }\n        make(root->left);\n        ans.push_back(root->val);\n        make(root->right);\n        return;\n    }\n};\n"
		],
		[
			5.826593386154606,
			5.385218946634187,
			5,
			20.0,
			"class Solution {\npublic:\n#include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> vect;\n        traverse(root,vect);\n        return vect;\n    }\n    void traverse(TreeNode* t,vector<int> &v){\n    if(t==nullptr)return;\n    if(t->left!=nullptr)traverse(t->left,v);\n    v.push_back(t->val);\n    if(t->right!=nullptr)traverse(t->right,v);\n}\n};\n"
		],
		[
			6.152007401463297,
			5.381698743912403,
			5,
			21.375,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        stack<TreeNode*> inOrder;\n        TreeNode* temp;\n        vector<int> ret;\n        if(root)\n        {\n            inOrder.push(root);\n            while(!inOrder.empty())\n            {\n                temp=inOrder.top();\n                if(temp->left)\n                {\n                    inOrder.push(temp->left);\n                    temp->left=NULL;\n                }\n                else\n                {\n                    inOrder.pop();\n                    ret.push_back(temp->val);\n                    if(temp->right)\n                    {\n                        inOrder.push(temp->right);\n                        temp->right=NULL;\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};\n"
		],
		[
			6.10404836562963,
			5.388917729867501,
			5,
			19.975,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root){ \n        if(root==NULL)\n           return {};\n        vector<int> vec;\n        stack<TreeNode*> s;\n        while(true){\n            if(root!=NULL){\n               s.push(root);\n               root=root->left; \n            }\n            else{\n                if(s.empty())\n                    break;\n                root=s.top();\n                s.pop();\n                vec.push_back(root->val);\n                root=root->right;\n            }\n        }\n        return vec;\n    }\n};\n"
		],
		[
			5.839996858677657,
			5.3733564843176485,
			4,
			18.6333,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> values;\n        if (!root) return values;\n        inorder(root, values);\n        return values;        \n    }\n    \n    void inorder(TreeNode* root, vector<int>& values) {\n        if (root) {\n            inorder(root->left, values);\n            values.push_back(root->val);\n            inorder(root->right, values);\n        }\n        return;\n        \n    }\n};\n"
		],
		[
			5.898195698877669,
			5.3460341022483995,
			6,
			30.0,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        while (root) {\n            if (root -> left) {\n                TreeNode* pre = root -> left;\n                while (pre -> right && pre -> right != root) {\n                    pre = pre -> right;\n                }\n                if (!pre -> right) {\n                    pre -> right = root;\n                    root = root -> left;\n                } else {\n                    pre -> right = NULL;\n                    nodes.push_back(root -> val);\n                    root = root -> right;\n                }\n            } else {\n                nodes.push_back(root -> val);\n                root = root -> right;\n            }\n        }\n        return nodes;\n    }\n};\n"
		],
		[
			7.193049786054426,
			5.806006294346353,
			4,
			22.7368,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        if (root == NULL) return std::vector<int>{};\n        //std::cout << root->val << '\\n';\n        std::vector<int> left, right;\n        if (root->left) left = inorderTraversal(root->left);\n        if (root->right) right = inorderTraversal(root->right);\n        left.push_back(root->val);\n        left.insert(end(left), begin(right), end(right));\n        return left;\n    }\n};\n"
		],
		[
			6.2517329065929985,
			5.375912292374426,
			5,
			21.6456,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        if (!root) return {}; // If there is no root return empty.\n        \n        vector<int> resVec; // Store results here\n        stack<TreeNode*> ourStack; // Store the nodes we traverse here\n        TreeNode* currentNode = root; // Set a pointer ot the first node.\n        \n        while (1) { // Continue running until our break condition is reached\n            if (currentNode) { // If the node exists, push it into the stack\n                ourStack.push(currentNode);\n                currentNode = currentNode->left; // Move left.\n            } else { // If there is no left, and the stack isn't empty, push the topmost element\n                if (ourStack.empty()) break; // into our result (this is the last number that entered the stack)\n                resVec.push_back(ourStack.top()->val);\n                currentNode = ourStack.top(); // take this same node and see if you can go right with it\n                ourStack.pop(); // Now that it's captured in currentNode, you can remove it from the stack\n                currentNode = currentNode->right;\n            } // If you can't go right with it, then you take the next top element, push its value into the\n        } // result vector, and see whether you can go right with it. This ccontinues until your stack is empty.\n        return resVec;\n    }\n};"
		],
		[
			5.856685098347801,
			5.3639107137156845,
			4,
			19.3333,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        // traverse the left tree first \n        // display the root information\n        // traverse the right sub tree\n    vector<int> ans;\n        \n    if(root ==NULL) return ans; \n    traversal(root,ans);\n        \n    return ans;\n    }\n    \n    void  traversal(TreeNode* head, vector<int>& ans)\n    {\n        if(!head) return ;\n        traversal(head->left,ans);\n        ans.push_back(head->val);\n        traversal(head->right,ans);\n    }\n};\n\n\n\n\n"
		],
		[
			5.846498948843708,
			5.312551649563679,
			3,
			17.7667,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        helper(root, ans);\n        return ans;\n    }\n    \n    void helper(TreeNode* root, vector<int>& ans) {\n        if(!root) return;\n        helper(root->left, ans);\n        ans.push_back(root->val);\n        helper(root->right, ans);\n    }\n};\n"
		],
		[
			6.122688641997838,
			5.373839529202117,
			4,
			18.5526,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        stack<TreeNode*> visit;\n        TreeNode* cur = root;\n        while(cur || !visit.empty()) {\n            if(cur) {\n                visit.push(cur);\n                cur = cur->left;\n            }else {\n                cur = visit.top();\n                visit.pop();\n                ans.push_back(cur->val);\n                cur = cur->right;\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			5.929208580122882,
			5.361323335723392,
			6,
			29.5312,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        TreeNode* cur = root;\n        while(cur) {\n            if(!cur->left) {\n                ans.push_back(cur->val);\n                cur = cur->right;\n            } else {\n                TreeNode* pred = cur->left;\n                while(pred->right && pred->right != cur) pred = pred->right;\n                if(!pred->right) {\n                    pred->right = cur;\n                    cur = cur->left;\n                } else {\n                    pred->right = nullptr;\n                    ans.push_back(cur->val);\n                    cur = cur->right;\n                }\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			5.9220589954747,
			5.340741533091769,
			8,
			36.0,
			"class Solution {\n\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    //AC - Morris Traversal;\n    vector<int> inorderTraversal(TreeNode* root) \n    {\n        vector<int> v;\n        while(root)\n        {\n            if(!root->left)\n            {\n                v.push_back(root->val);\n                root = root->right;\n\n            }\n            else\n            {\n                TreeNode *pre = root->left;\n                while(pre->right && pre->right!=root) pre = pre->right;\n                if(!pre->right)\n                {\n                    pre->right = root;\n                    root = root->left;\n                }\n                else\n                {\n                    v.push_back(root->val);\n                    root = root->right;\n                    pre->right = NULL;\n                }\n            }\n        }\n        return v;\n    }\n    private:\n    void traverse(TreeNode* root, vector<int>& v)\n    {\n        if(!root) return;\n        traverse(root->left, v);\n        v.push_back(root->val);\n        traverse(root->right, v);\n    }\n};"
		],
		[
			6.147528939133534,
			5.359654630044804,
			6,
			22.125,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n       vector<int> ans;\n       if(root == NULL) return ans;\n       stack<TreeNode*> st;\n      while(root != NULL) {\n          st.push(root);\n          root = root->left;\n      }\n       while(st.size() != 0) {\n           root = st.top();\n           st.pop();\n           ans.push_back(root->val);\n           if(root->right != NULL) {\n               root = root->right;\n               while(root != NULL) {\n                   st.push(root);\n                   root = root->left;\n               }\n           }\n       }\n       return ans;\n    }\n};"
		],
		[
			6.1261191996041395,
			5.387164533762808,
			5,
			17.6842,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode* root) {\n        if(!root) return {};\n        vector<int> result;\n        stack<TreeNode*> st;\n        TreeNode* curr = root;\n        while(curr || !st.empty()) {\n            while(curr) {\n                 st.push(curr);\n                 curr = curr->left;\n            }\n            curr = st.top();\n            result.push_back(curr->val);\n            st.pop();\n            curr = curr->right;\n        }\n        return result;\n    }\n};\n"
		],
		[
			6.108222249512765,
			5.356421326434603,
			4,
			15.925,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ret;\n        stack<TreeNode *> s;\n        TreeNode *temp = root;\n        \n        while (!s.empty() || temp != NULL)\n        {\n            while (temp != NULL)\n            {\n                s.push(temp);\n                temp = temp->left;\n            }\n            \n            temp = s.top();\n            ret.push_back(temp->val);\n            s.pop();\n            temp = temp->right;\n        }\n        \n        return ret;\n    }\n};"
		],
		[
			6.089957626147142,
			5.341428604745002,
			4,
			16.0789,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n  vector<int> inorderTraversal(TreeNode* root) {\n    vector<int> ret;\n    stack<TreeNode *> s;\n    for (TreeNode *n = root; n || !s.empty(); n = n->right) {\n      for (; n; n = n->left) s.push(n);\n      n = s.top(); s.pop();\n      ret.push_back(n->val);\n    }\n    return ret;\n  }\n};"
		],
		[
			6.167519049842541,
			5.3882767436362675,
			7,
			26.0606,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        initialize(root);\n        while(hasNext())\n        {\n            result.push_back(next());\n        }\n        return result;\n    }\n    private:\n    TreeNode* node;\n    vector<TreeNode*> leftMostNodes;\n    \n    void initialize(TreeNode* root)\n    {\n        node = root;\n    }\n    \n    bool hasNext()\n    {\n        while(node)\n        {\n            leftMostNodes.push_back(node);\n            node = node->left;\n        }\n        if(leftMostNodes.size() == 0)\n            return false;\n        else\n            return true;\n    }\n    \n    int next()\n    {\n        int value;\n        node = leftMostNodes.back();\n        leftMostNodes.pop_back();\n        value = node->val;\n        node = node->right;\n        return value;\n    }\n    \n};"
		],
		[
			6.129505858983272,
			5.398845359405434,
			5,
			19.7895,
			"class Solution {\npublic: \n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n//     Iterative\n    vector<int> res;\n    vector<int> inorderTraversal(TreeNode* root) {\n        if(!root) return res;\n        stack<TreeNode*> st;\n        while(root || !st.empty()){\n            if(root){\n                st.push(root);\n                root=root->left;\n            }\n            else{\n                root = st.top();\n                st.pop();\n                res.push_back(root->val);\n                root=root->right;\n            }\n        }\n        return res;\n    }\n};"
		],
		[
			6.1396982715824455,
			5.366161317273387,
			4,
			16.1,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        stack<TreeNode*> st;\n        vector<int> v;\n        while(root || st.empty()==0)\n        {\n            while(root!=NULL)\n            {\n                st.push(root);\n                root=root->left;\n            }\n            root=st.top();\n            st.pop();\n            v.push_back(root->val);\n            root=root->right;\n        }\n        return v;\n    }\n};"
		],
		[
			6.143794168573425,
			5.407398984449532,
			4,
			18.3333,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode *root) {\n        stack<TreeNode*> s;\n        pushAllLeft(s, root);\n        vector<int> result;\n        while(!s.empty()) {\n            TreeNode* p = s.top();\n            s.pop();\n            result.push_back(p->val);\n            pushAllLeft(s,p->right);\n        }\n        return result;\n    }\n    \n    void pushAllLeft(stack<TreeNode*>& s, TreeNode* root) {\n        while(root) {\n            s.push(root);\n            root = root->left;\n        }\n    }\n};"
		],
		[
			6.016824127080847,
			5.395215138431937,
			6,
			25.1458,
			"class Solution\n{\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector< int > inorderTraversal( TreeNode *root )\n    {\n        vector< int > out;\n        stack< pair< int, TreeNode * > > toDo;\n        TreeNode * current = root;\n        \n        for ( ;; )\n        {\n            if( current )\n            {\n                if( current->left )\n                {\n                    pair< int, TreeNode * > temp;\n                    temp.first  = current->val;\n                    temp.second = current->right;\n                    toDo.push( temp );\n                    current = current->left;\n                }\n                else\n                {\n                    out.push_back( current->val );\n                    if( current->right )\n                    {\n                        current = current->right;\n                    }\n                    else current = 0;\n                }\n            }\n            else\n            {\n                if( toDo.size() )\n                {\n                    out.push_back( toDo.top().first );\n                    current = toDo.top().second;\n                    toDo.pop();\n                }\n                else break;\n            }\n        }\n        return out;\n    }\n};"
		],
		[
			6.15812244191864,
			5.342507485315188,
			6,
			22.8947,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };    vector<int> inorderTraversal(TreeNode *root) {\n        stack<TreeNode*> tstack;\n        vector<int> vals;\n        if(root==NULL)  return vals;\n        tstack.push(root);\n        while(!tstack.empty()) {\n            while(root) {\n                if(tstack.top()!=root)  tstack.push(root);\n                root=root->left;\n            }\n            root=tstack.top();\n            vals.push_back(root->val);\n            tstack.pop();\n            if(root->right) {\n                tstack.push(root->right);\n            }\n            root=root->right;\n        }\n        return vals;\n    }\n};"
		],
		[
			6.091336055472533,
			5.383584612603944,
			3,
			16.25,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> inorderTraversal(TreeNode *root) {\n        stack<TreeNode*> stack;\n        vector<int> vals;\n        while(!stack.empty() or root) {\n            while(root) {\n                stack.push(root);\n                root=root->left;\n            }\n            root=stack.top();\n            stack.pop();\n            vals.push_back(root->val);\n            root=root->right;\n        }\n        return vals;\n    }\n};"
		],
		[
			6.125740316784852,
			5.379291020437379,
			4,
			17.1111,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        stack<TreeNode*> todo;\n        while (root || !todo.empty()) {\n            while (root) {\n                todo.push(root);\n                root = root -> left;\n            }\n            root = todo.top();\n            todo.pop();\n            nodes.push_back(root -> val);\n            root = root -> right;\n        }\n        return nodes;\n    }\n};\n"
		],
		[
			7.09317071752952,
			16.312275364580053,
			2,
			14.3077,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorder;\n    vector<int> inorderTraversal(TreeNode* root) {\n        if(!root) return inorder;\n        inorderTraversal(root->left);\n        inorder.push_back(root->val);\n        inorderTraversal(root->right);\n        return inorder;\n    }\n};\n"
		],
		[
			5.92242175428952,
			5.36562687341828,
			3,
			17.0625,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        inorder(root, nodes);\n        return nodes;\n    }\nprivate:\n    void inorder(TreeNode* root, vector<int>& nodes) {\n        if (!root) {\n            return;\n        }\n        inorder(root -> left, nodes);\n        nodes.push_back(root -> val);\n        inorder(root -> right, nodes);\n    }\n};\n"
		],
		[
			6.093856341387485,
			5.3598453248880835,
			5,
			18.2143,
			"class Solution {\npublic:\n    \n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        if(root==nullptr)return {};\n        vector<int> ans;\n        stack<TreeNode*> s;\n        TreeNode* curr = root;\n        \n        while(curr!=NULL || !s.empty()){\n            while(curr!=NULL){\n                s.push(curr);\n                curr = curr->left;\n            }\n            curr = s.top();\n            s.pop();\n            \n            ans.push_back(curr->val);\n            curr = curr->right;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			5.9401289694743244,
			5.430816266628372,
			3,
			15.0312,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> result;\n    vector<int> inorderTraversal(TreeNode* root) {\n        inorder(root);\n        return result;\n    }\n    \n    void inorder(TreeNode* root) {\n        if(root == NULL) {\n            return;\n        }\n        inorder(root->left);\n        result.push_back(root->val);\n        inorder(root->right);\n    }\n};\n"
		],
		[
			6.197367041714702,
			5.344922043807519,
			4,
			18.1579,
			"class Solution {\npublic:\n\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        stack<TreeNode*> stk;\n        vector<int> result;\n        \n        TreeNode* curr = root;\n        while(curr || !stk.empty()) {\n            if(curr) {\n                stk.push(curr);\n                curr = curr->left;\n            } else {\n                result.push_back(stk.top()->val);\n                curr = stk.top()->right;\n                stk.pop();\n            }\n        }\n        \n        return result;\n    }\n    \n};\n"
		],
		[
			5.930032205043091,
			5.399097548641375,
			6,
			32.0,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        TreeNode* curr = root;\n\t\t\n        while(curr) {\n            if(curr->left) {\n                TreeNode* prev = curr->left;\n                while(prev->right && prev->right != curr)\n                    prev = prev->right;\n                if(prev->right == curr) {\n                    result.push_back(curr->val);\n                    prev->right = NULL;\n                    curr = curr->right;\n                } else {\n                    prev->right = curr;\n                    curr = curr->left;\n                }\n            } else {\n                result.push_back(curr->val);\n                curr = curr->right;\n            }\n        }\n        \n        return result;\n    }\n    \n};\n"
		]
	],
	"PALIN": [
		"1",
		[
			1.0,
			1.0,
			4,
			17.2308,
			"class Solution {\npublic:\n    bool isPalindrome(int n) {\n        if(n<0) return false;\n        \n        long long rev = 0;\n        int copy = n;\n        while(n)\n        {\n            short d = n%10;\n            n = n/10;\n            rev = rev * 10 + d;\n        }\n        if(rev == copy) return true;\n        return false;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.3333,
			"class Solution {\npublic:\n    bool isPalindrome(int x) \n    {\n        if(x < 0)\n            return false;\n        \n        long lastDigit = 0;\n        long reversedNum = 0;\n        long copyX = x;\n        while(copyX)\n        {\n            lastDigit = copyX % 10;\n            reversedNum = reversedNum * 10  + lastDigit;\n            copyX = copyX / 10;\n        }\n\n        if( x == reversedNum)\n            return true;\n        \n        return false;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			23.0714,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)\n            return false;\n        else\n        {\n            int p=0,y,k;\n            y = x;\n            while(x > 0)\n            {\n                k = x%10;\n                x = x/10;\n                p = p*10 + k;\n                if(p > INT_MAX/10)\n                    break;\n            }\n            if(p == y)\n                return true;\n            else\n                return false;\n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			21.9583,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        long long int ans=0,bal,qus=x;\n        if(x<0){\n            return false;\n        }\n        if(x<10){\n            return true;\n        }\n        while(x){\n            bal = x%10;\n            ans = bal+ans*10;\n            x = x/10;\n        }\n        if(ans == qus){\n            return true;\n        }\n        return false;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			18.4412,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0){\n            return false;\n        }\n        vector<int> v;\n        while(x){\n            v.push_back(x%10);\n            x=x/10;\n        }\n        int i=0,j=v.size()-1;\n        while(i<j){\n            if(v[i++]!=v[j--]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			8.76923,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        \n        string str=to_string(x);\n        string s=str;\n        reverse(str.begin(),str.end());\n        \n        if(str == s)    return true;\n        return false;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			25.7778,
			"class Solution {\npublic:\nbool isPalindrome(int x) {\n\tif (x < 0 || (x % 10 == 0 && x != 0))\n\t\treturn false;\n\tint rx = 0;\n\twhile (x > rx) {\n\t\trx = rx * 10 + x % 10;\n\t\tx /= 10;\n\t}\n\treturn x == rx || x == rx / 10;;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			25.0556,
			"class Solution {\npublic:\nbool isPalindrome(int x) {\nint a = x;\nint b = a;\nint c = b;\nint len = 0;\nlong long int sum = 0;\n\n\twhile (a > 0) {\n\t\ta /= 10;\n\t\tlen++;\n\t}\n\t\n\tfor (int i = 0; i < len; i++) {\n\t\tint power = len - i - 1;\n\n\t\tsum += (b % 10) * pow(10, power);\n\t\tb /= 10;\n\t}\n\n\tif (sum == c) {\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n};"
		],
		[
			1.0,
			1.0,
			1,
			11.44,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        string s = to_string(x); //convert int x to a string\n        string s2 = s; //make a copy of the string representation of int x to reverse\n        reverse(s2.begin(), s2.end()); //use reverse to reverse s2  from its beginning to end\n        return (s == s2); //*see note below\n    }\n};"
		],
		[
			1.0,
			1.0,
			5,
			19.0,
			"class Solution {\npublic:\nbool isPalindrome(int x) {\n\n    if (x < 0) {\n        return false;\n    }\n    \n    if (x == 0) {\n        return true;\n    }\n    \n    int x_0 = x;\n    long y = 0;\n    \n    while (x != 0) {\n        y = y * 10 + x % 10;\n        x /= 10;\n    }\n    \n    if (y == x_0) {\n        return true;\n    }\n    else {\n        return false;\n    }\n    \n    // limitation: y must be in the range of - 2147483648 and y > 2147483647\n}\n};"
		],
		[
			1.0,
			1.0,
			3,
			18.8182,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) return false; // edge case \n        \n        long val = x, rev = 0;\n        while (x) {\n            rev = 10*rev + x%10; \n            x /= 10; \n        }\n        return val == rev; \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			20.0,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) {\n            return false;\n        }\n        \n        return (x == reverse(x));\n    }  \n    \nprivate:\n    long long reverse(int x) {\n        long long reverse = 0;\n\n        while (x) {\n            reverse = reverse*10 + x%10;\n            x /= 10;\n        }\n\n        return reverse;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			18.1087,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        //Negative numbers handled\n        if(x%10<0)\n            return false;\n        \n\t\tint ans=0, rem=0, temp=x;\n        //Reversing the integer\n\t\twhile(temp!=0){\n            rem = temp%10;\n            temp = temp/10;\n            //To prevent overflow\n            if(ans > INT_MAX/10 || (ans == INT_MAX/10 && rem>7))\n                return false;\n            ans = ans*10 + rem;\n        }\n        return (ans==x);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			24.0,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x==0) return true;\n        if(x<0 || x%10 == 0) return false;\n        int rev = 0;\n        while(x>rev) {\n            rev  = rev*10 + x%10;\n            x /= 10;\n        }\n        return x == rev || x== rev/10;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			21.25,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        bool ans = false;\n        if(x<0){\n            return ans;\n        }\n        \n        int ch=x,y=0;\n        while(x){\n            if(INT_MAX/10 < y){return ans;}\n            \n            y = (y*10)+(x%10);\n            x = x/10;\n        }\n        if(ch==y){\n            ans=true;\n            return ans;\n        }else{\n            return ans;\n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.3077,
			"class Solution {\npublic:\n\tbool isPalindrome(int x) {\n\t\tif(x<0) return false;\n\t\tint a=abs(x);\n\t\tlong int num=0;\n\t\twhile(a!=0){\n\t\t\tint cur=a%10;\n\t\t\tnum=num*10+cur;\n\t\t\ta/=10;         \n\t\t}\n\t\tif(num==x) return true;\n\t\telse return false;   \n\t}\n};"
		],
		[
			1.0,
			1.0,
			6,
			22.7143,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x < 0) return false;\n        else if(x < 10) return true;\n        int digits = (int)ceil(log10(x));\n        if(digits == (int)log10(x)) return false;   //For powers of 10\n        for(int i = 1, j = digits; i < j; i++, j--)\n        {\n            int right = (x%(int)pow(10, i))/pow(10, i-1);\n            int left = (x%(int)pow(10, j))/pow(10, j-1);\n            if(left != right) return false;\n        }\n        return true;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			10.2917,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n\n        if(x < 0){\n            return false;\n        }\n        \n        string y = to_string(x);\n        \n        reverse(y.begin(), y.end());\n        \n        return y == to_string(x);\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			29.8571,
			"class Solution\n{\n\tpublic:\n\tbool isPalindrome(int x)\n\t{\n\t\tif(x < 0)  return false;\n\t\tif(x == 0) return true;\n\t\tint digits = 0;\n\t\tint tem = x;\n\t\tdigits = int(log10(x));\n\t\ttem = x;\n\t\twhile((digits > 0) &&\n\t\t\t  (tem % 10) == (tem / int(pow(10, digits))))\n\t\t{\n\t\t\ttem -= tem % 10 + (tem % 10)*int(pow(10, digits));\n\t\t\ttem /= 10;\n\t\t\tdigits -= 2;\n\n\t\t}\n\t\treturn (digits <= 0)?true:false;\n\t}\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			23.0,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x==0)return true;\n        int n=x;\n        int sign=(x>0)?1:-1;\n        if(sign<0)return false;\n        x=abs(x);\n        int r=0;\n        while(x>0)\n        {\n            if(r>INT_MAX/10 || r==INT_MAX/10 && x%10>7)return false;\n            r=r*10+x%10;\n            x/=10;\n        }\n        return r==n;\n    }\n};"
		],
		[
			1.0,
			1.0,
			5,
			19.2,
			"class Solution {\npublic:\nbool isPalindrome(int x) {\nif(x<0) return false;\nlong y=0,z=x;\nwhile(z!=0)\n{\ny=(y*10)+(z%10);\nz/=10;\n}\nif(y>INT_MAX || y<INT_MIN) return false; //checking overflow\nreturn y==x;\n}\n};"
		],
		[
			1.0,
			1.0,
			3,
			11.2667,
			"class Solution\n{\npublic:\n\nbool isPalindrome(int x) \n{\n    if(x < 0) return false;\n    \n    std::string s1 = std::to_string(x);\n    std::string s2 = s1;\n    std::reverse(s2.begin(), s2.end());\n    \n    if(s1 == s2) return true;\n    \n    return false;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			16.5526,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) return false;\n        \n        std::deque<int> qDigits;\n        while(x!=0){\n           qDigits.push_back(x%10);\n            x /= 10;\n        }\n        \n        auto iterBegin = qDigits.begin();\n        auto iterEnd = qDigits.end();\n        iterEnd--;\n        \n        while(iterBegin < iterEnd){\n            if (*iterBegin != *iterEnd){\n                return false;\n            }\n            iterBegin++;\n            iterEnd--;\n        }\n        \n        return true;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			13.7143,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        string str = to_string(x);\n        \n        for(int i = 0; i < str.length() / 2; i++){\n            if(str[i] != str[str.length() - i - 1]) return false;\n        }\n        \n        return true;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.1818,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0)\n            return false;\n        int val = x;\n        long int rem = 0;\n        while(x)\n        {\n            rem = rem*10 + x%10 ;\n                x =x/10;\n        }\n        return(rem == val ? true : false);  \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			20.0909,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x<0) return false;\n        if (x==0) return true;\n        long y = 0;\n        long xo = x;\n        while(x>0) {\n            y = y*10 + x%10;\n            x/=10;\n        }\n        return xo == y;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			11,
			27.0,
			"\tclass Solution {\n\tpublic:\n\t\tbool isPalindrome(int x) {\n\t\t\tint revNo=0;\n\t\t\tint n=x;\n\t\t\tint rem;\n\t\t\tif(x<0) return false;\n\t\t\tif(x%10==x) return true;\n\t\t\twhile(n!=0)\n\t\t\t{\n\t\t\t\trem=n%10;\n\t\t\t\tn/=10;\n\t\t\t\tif (revNo > INT_MAX/10 || (revNo == INT_MAX / 10 && rem > 7)) return 0;\n\t\t\t\tif (revNo < INT_MIN/10 || (revNo == INT_MIN / 10 && rem < -8)) return 0;\n\n\t\t\t\trevNo=revNo*10 + rem;\n\t\t\t}\n\t\t\treturn (revNo==x) ? true : false;\n\t\t}\n\t};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.3077,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        long rev=0;\n        int temp=x;\n        if(x>=0){\n        while(x!=0){\n            int rem = abs(x%10);\n            rev=(rev*10)+rem;\n            x/=10;\n            }\n            \n            if(temp == rev)\n                return true;\n            else\n                return false;\n        }\n        else\n            return false;\n        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			14.7027,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x < 0)\n            return false;\n        \n        if(x == 0)//As log(0) is undefined\n            return true;\n        \n        int n = (int)log10(x) + 1;//Number of digits to represent x\n        int d = pow(10, n-1);//divisor to get MSB\n        \n        while(d != 0)\n        {\n            if(x/d != x%10)//Compare MSB and LSB\n                return false;\n            \n            x = (x % d)/10;//Remove LSB and MSB from the number\n            d /= 100;//As two digits got remved from the number\n        }\n        return true;\n    }\n};"
		],
		[
			1.0,
			1.0,
			3,
			19.3182,
			"class Solution {\npublic:\n    bool isPalindrome(int x) {\n        \n        if(x<0) return false;\n        \n        int a=abs(x);\n        long int p=0;\n        while(a>0)\n        {\n            p=(p*10) + (a%10);\n            a=a/10;\n        }\n       return p==x;\n    }\n};"
		]
	],
	"UGLY_NUM": [
		"1",
		[
			1.0,
			1.0,
			5,
			12.6,
			"class Solution {\npublic:\nbool isUgly(int n)\n{\n\tif(!n) return false;\n\tfor( ; !(n%2); n/=2);    \n\tfor( ; !(n%3); n/=3);\n\tfor( ; !(n%5); n/=5);\n\treturn n==1;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			15.0,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        \n        if(num<1)\n            return false;\n        else if(num==1)\n            return true;\n        else if(num%2==0)\n            return isUgly(num/2);\n        else if(num%3==0)\n            return isUgly(num/3);\n        else if(num%5==0)\n            return isUgly(num/5);\n        else\n            return false;\n        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			13.6364,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        if(num==0) return false;\n        while(num%2==0){\n            num/=2;\n        }\n        while(num%3==0){\n            num/=3;\n        }\n        while(num%5==0){\n            num/=5;\n        }\n        return num==1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			14.5,
			"class Solution {\npublic:\n    bool isUgly(int n) {\n    if(n!=0){\n        while(n%2==0){n=n/2;}\n        while(n%3==0){n=n/3;} \n        while(n%5==0){n=n/5;}} \n        if(n==1){return true;}      \n        return false;\n    }\n};"
		],
		[
			1.0,
			1.0,
			5,
			10.8,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        return num ? !(num%2) ? isUgly(num/2) : !(num%3) ? isUgly(num/3) : !(num%5) ? isUgly(num/5) : num == 1 : false;\n    }\n};"
		],
		[
			1.0,
			1.0,
			9,
			20.4167,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        if (num <= 0) return false;\n        if (num < 7) return true;\n        if ((num%2) && (num%3) && (num%5)) return false;\n        while (num%2 == 0) num/=2;\n        while (num%3 == 0) num/=3;\n        while (num%5 == 0) num/=5;\n        return isUgly(num);\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			13.75,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        if (num == 1) return true;\n        if (num == 0) return false;\n        else if (num % 2 == 0) return isUgly(num / 2);\n        else if (num % 3 == 0) return isUgly(num / 3);\n        else if (num % 5 == 0) return isUgly(num / 5);\n        else return false; \n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			16.875,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        if(num < 1) return false;\n        while(num != 1) {\n            if(num%2 == 0) {\n                num /= 2;\n                continue;\n            } else if(num%3 == 0) {\n                num /= 3;\n                continue;\n            } else if(num%5 == 0) {\n                num /= 5;\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			15.1667,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        if (num == 1) return true;\n        if (num <= 0) return false;\n        while (num % 2 == 0) num /= 2;\n        while (num % 3 == 0) num /= 3;\n        while (num % 5 == 0) num /= 5;\n        return num == 1;\n    }\n};"
		],
		[
			1.0,
			1.0,
			5,
			14.7727,
			"class Solution {\npublic:\nbool isUgly(int num) {\n    if(num <= 0) return false;\n    while(num % 3 == 0) num /= 3;\n    while(num % 2 == 0) num /= 2;\n    while(num % 5 == 0) num /= 5;\n    return num == 1;        \n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			14.7727,
			"class Solution {\npublic:\n    bool isUgly(int num) {\n        if (num < 1) return false;\n        while (num % 2 ==0) num /= 2;\n        while (num % 3 ==0) num /= 3;\n        while (num % 5 ==0) num /= 5;\n        return num == 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			9,
			16.5,
			"class Solution {\npublic:\n\tbool isUgly(int num) {\n\t\tif(num == 0)\n\t\t\treturn false;\n\t\twhile(num % 2 == 0)\n\t\t\tnum /= 2;\n\t\twhile(num % 3 == 0)\n\t\t\tnum /= 3;\n\t\twhile(num % 5 == 0)\n\t\t\tnum /= 5;\n\t\tif(num == 1 || num == 2 || num == 3 || num == 5)\n\t\t\treturn true;\n\t\treturn false;\n\n\t}\n};"
		],
		[
			1.0,
			1.0,
			5,
			23.4333,
			"class Solution {\npublic:\n    bool isUgly(int num) \n    {\n        if(num<=0) return false;\n        vector<int> div(3);\n        div[0]=2, div[1]=3, div[2]=5;\n        for(int i=0; i<3; i++) while(num%div[i]==0) num = num/div[i];\n        if(num==1) return true;\n        return false;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			16.9,
			"class Solution {\npublic:\nbool isUgly(int n) {\n\n    if(!n) return 0;\n    while(n%2==0)\n        n/=2;\n    while(n%3==0)\n        n/=3;\n    while(n%5==0)\n        n/=5;\n    \n    if(n==1) return 1;\n    else return 0;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			14.7727,
			"class Solution {\npublic:\nbool isUgly(int num) {\n    if(num <= 0) return false;\n    while(num%2 == 0) num/=2;\n    while(num%3 == 0) num/=3;\n    while(num%5 == 0) num/=5;\n    return num == 1;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			13.75,
			"class Solution {\npublic:\nbool isUgly(int num) {\n    if(num <= 0) return false;\n    if(num == 1) return true;\n    if(num%2 == 0) return isUgly(num/2);\n    if(num%3 == 0) return isUgly(num/3);\n    if(num%5 == 0) return isUgly(num/5);\n    return false;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			12.5714,
			"class Solution {\npublic:\n    vector<int> primes = {2, 3, 5};\n    bool isUgly(int n) {\n        if (n < 1) return false;\n        for (int p: primes) while (n % p == 0) n /=p;\n        return n == 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			15.0,
			"class Solution {\npublic:\nbool isUgly(int num) {\n\tif (num <= 0)\n\t\treturn false;\n\n\tif (num % 5 == 0)\n\t   return isUgly(num / 5);\n\telse if (num % 3 == 0)\n\t   return isUgly(num / 3);\n\telse if (num % 2 == 0)\n\t   return isUgly(num / 2);\n\n\tif (num == 1)\n\t\treturn true;\n\treturn false;\n}\n};"
		]
	],
	"VALID_BST": [
		"n",
		[
			5.735413154264398,
			5.183377074635478,
			7,
			27.625,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool helper(TreeNode* root , long long minV = -10000000000,long long maxV = 10000000000)\n    {\n        if(root == NULL) return true;\n        bool left = helper(root->left,minV,root->val);\n        bool right = helper(root->right,root->val,maxV);\n        \n        if(left && right && root->val < maxV && root->val >minV)\n        {\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n    bool isValidBST(TreeNode* root) {\n        return helper(root);\n        \n    }\n};\n"
		],
		[
			5.655800467226358,
			5.183377074635478,
			8,
			18.8,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        return isValid(root, NULL, NULL);\n    }\n    \n    bool isValid(TreeNode* root, int* lower, int* upper){\n        if(!root)\n            return true;\n\n        if(upper && root -> val >= *upper)\n            return false;\n        if(lower && root -> val <= *lower)\n            return false;\n        \n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\n    }\n};\n"
		],
		[
			5.869892482298808,
			5.370552472711159,
			6,
			36.8,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void inorder(vector<int> &v, TreeNode* root){\n        if(root!=NULL){\n            inorder(v,root->left);\n            v.push_back(root->val);\n            inorder(v,root->right);\n        }\n    }\n    bool isValidBST(TreeNode* root) {\n        if(root==NULL)\n            return true;\n        vector<int> v;\n        inorder(v,root);\n        for(int i=0;i<v.size()-1;i++)\n            if(v[i]>=v[i+1])\n                return false;\n        return true;\n    }\n};\n"
		],
		[
			5.831462800961704,
			5.341365432401972,
			6,
			23.75,
			"class Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        if(!root)\n            return true;\n        vector<int> inorder;\n        checkBST(root,inorder);\n        int prev=inorder[0];\n        for(int i=1;i<inorder.size();i++){\n            if(prev>=inorder[i]){\n                return false;\n            }\n            prev=inorder[i];\n        }\n        return true;\n    }\n    void checkBST(TreeNode* root,vector<int>& inorder){\n        if(root==NULL)\n            return ;\n        checkBST(root->left,inorder);\n        inorder.push_back(root->val);\n        checkBST(root->right,inorder);\n    }\n};\n"
		],
		[
			5.669034537969645,
			5.183377074635478,
			6,
			21.3571,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        TreeNode* prev=NULL;\n        return checkBST(root,prev);\n    }       \n    bool checkBST(TreeNode* root,TreeNode*& prev){\n        if(root==NULL){\n            return true;\n        }\n        if(!checkBST(root->left,prev)){\n            return false;\n        }\n        if(prev!=NULL && root->val<=prev->val){\n            return false;\n        }\n        prev=root;\n        return checkBST(root->right,prev);\n        \n    }\n};\n"
		],
		[
			5.875807881934128,
			5.369710079420596,
			5,
			16.0,
			"class Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) \n    {\n        if( root == nullptr )\n        {\n            return true;\n        }\n        inorderTraversal(root);\n        return isValid();\n    }\nprivate:\n    vector<int> values;\n    void inorderTraversal(TreeNode* root)\n    {\n        if( root )\n        {\n            inorderTraversal(root->left);\n            values.push_back(root->val);\n            inorderTraversal(root->right);\n        }\n    }\n    bool isValid()\n    {\n\t\treturn is_sorted(values.begin(), values.end(), [](const int& a, const int& b) {return a <= b; });\n    }\n};\n"
		],
		[
			5.716398275253068,
			5.183377074635478,
			6,
			17.0,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tbool isValidBST(TreeNode* root)\n\t{\n\t\treturn inorder_evaluation(root);\n\t}\nprivate:\n\tbool inorder_evaluation(TreeNode* current)\n\t{\n\t\tstack<TreeNode*> traversalStack;\n        //long to accomodate lowest integer value\n\t\tlong nodeValue = LONG_MIN;\n\n\t\twhile (current != nullptr || !traversalStack.empty()) {\n\t\t\tif (current != nullptr) {\n\t\t\t\ttraversalStack.push(current);\n\t\t\t\tcurrent = current->left;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrent = traversalStack.top();\n\t\t\t\ttraversalStack.pop();\n\t\t\t\t//process the current node value\n                if (nodeValue < current->val){\n                    nodeValue = current->val;\n                }\n                else{\n                    return false;\n                }\n\t\t\t\tcurrent = current->right;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n};\n"
		],
		[
			6.077048585633043,
			5.183377074635478,
			7,
			21.0,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool inorder(TreeNode* node,long& min)\n    {\n        bool l_find,r_find;\n        if(node==NULL)\n            return true;\n        l_find=inorder(node->left,min);\n        if(l_find==false)\n            return false;\n        if(node->val<=min)\n            return false;\n        min=node->val;\n        r_find=inorder(node->right,min);\n        if(r_find==false)\n            return false;\n        return true;\n        \n    }\n    bool isValidBST(TreeNode* root) {\n        if(root==NULL)\n            return true;\n        long x=LONG_MIN;\n        return inorder(root,x);\n    }\n};\n"
		],
		[
			5.738366317222718,
			5.183377074635478,
			8,
			24.2667,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValid(TreeNode* root,TreeNode* min,TreeNode* max)\n    {\n        if(root == NULL) return true;\n        \n        if(min!=NULL && min->val >= root->val)\n            return false;\n        \n        if(max!=NULL && max->val <= root->val)\n            return false;\n        \n        return isValid(root->left,min,root)&&isValid(root->right,root,max);\n        \n    }\n    bool isValidBST(TreeNode* root) {        \n         \n        return isValid(root,NULL,NULL);     \n    }\n};\n"
		],
		[
			5.964047526755617,
			5.183377074635478,
			6,
			19.4783,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nint isValid(TreeNode* node, int min, int max)  \n{  \n    \n    if (node==NULL)  \n        return 1;  \n             \n    if (node->val < min || node->val > max)  \n        return 0;  \n      \n    return\n        isValid(node->left, min, node->val-1) && // Allow only distinct values  \n        isValid(node->right, node->val+1, max); // Allow only distinct values  \n}  \n bool isValidBST(TreeNode* root) {        \n         \n        return isValid(root,INT_MIN,INT_MAX);     \n    }\n};"
		],
		[
			6.057602636913568,
			5.183377074635478,
			4,
			16.0714,
			"class Solution {\n\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        \n        inorder(root);\n        \n        return flag;\n        \n    }\n    \n    bool flag = true;\n    stack<int> s;\n    \n    void inorder(TreeNode* node){\n        if(node){\n            inorder(node->left);\n            \n            if(!s.empty() and s.top() >= node->val){\n                flag = false;\n                return;\n            }\n            s.push(node->val);\n            \n            \n            inorder(node->right);\n        }\n        else{\n            return;\n        }\n    }\n    \n};\n"
		],
		[
			5.962753419502132,
			5.183377074635478,
			6,
			19.875,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nbool isValidBSTHelper(TreeNode* root, long min, long max){\n    if(root == NULL){\n        return true;\n    }\n    if(root -> val > min && root -> val < max){\n        bool temp1 = isValidBSTHelper(root->left, min, root->val);\n        bool temp2 = isValidBSTHelper(root->right, root->val, max);\n        return temp1 && temp2;\n    }\n    return false;\n}\nbool isValidBST(TreeNode* root) {\n    return isValidBSTHelper(root, LONG_MIN, LONG_MAX);\n}\n};"
		],
		[
			6.217121209122863,
			5.361353027694082,
			5,
			15.68,
			"class Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    static bool cmp(int a,int b){return a <= b;}\n    void in(TreeNode* root, vector<int>& t) {\n        if(!root) return;\n        in(root->left, t);\n        t.push_back(root->val);\n        in(root->right, t);\n    }\n    bool isValidBST(TreeNode* root) {\n        if (!root) return true;\n        vector<int> t;\n        in(root, t);\n        return is_sorted(t.begin(), t.end(),cmp);\n    }\n};\n"
		],
		[
			7.424733797488825,
			6.034738531222861,
			7,
			33.4286,
			"class Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool flag = true;\n    vector<int> dfs(TreeNode * root)\n    {\n       if(!root) return {}; \n       vector<int> left = dfs(root -> left); \n       vector<int> right = dfs(root -> right);\n       vector<int> merge;\n       for(int i = 0 ; i < left.size();i++)\n       {\n           if(left[i] >= root-> val) flag = false; \n           merge.push_back(left[i]);\n           \n        }\n       for(int i = 0 ; i < right.size();i++)\n       {\n           if(right[i] <= root -> val) flag = false;\n           merge.push_back(right[i]); \n        }\n       merge.push_back(root -> val); \n       return merge; \n    }\n    bool isValidBST(TreeNode* root) {\n       dfs(root); \n       return flag; \n    }\n};\n"
		],
		[
			5.944978524605151,
			5.257391739261227,
			6,
			23.7273,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        if(root == NULL) return true;\n        \n        queue<int> inorder;\n        \n        dfs(root, inorder);\n        \n        int former = inorder.front(); inorder.pop();\n        while(!inorder.empty()){\n            if(former >= inorder.front()) return false;\n            \n            former = inorder.front();\n            inorder.pop();\n        }\n        \n        return true;\n    }\n    \n    void dfs(TreeNode* root, queue<int>& que){\n        if(root == NULL) return;\n        \n        dfs(root->left, que);\n        que.push(root->val);   \n        dfs(root->right, que);\n    }\n};\n"
		],
		[
			6.14130178846439,
			5.352165853465325,
			6,
			21.375,
			"class Solution {\npublic:\n\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<int> order;\n    bool isValidBST(TreeNode* root) {\n        if (!root) return true;\n        inOrder(root);\n        for (size_t i = 0; i < order.size() - 1; i++) {\n            if (order[i] >= order[i + 1]) return false;\n        }\n        return true;\n    }\n    \n    void inOrder(TreeNode* root) {\n        if (!root) return ;\n        inOrder(root->left);\n        this->order.push_back(root->val);\n        inOrder(root->right);\n    }\n};\n"
		],
		[
			5.7698144529047255,
			5.183377074635478,
			5,
			17.5,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nbool isValidBST(TreeNode* root, long min = LONG_MIN, long max = LONG_MAX) {\n\tif(!root) return true;\n\tif(root->val <= min || root->val >= max) return false;\n\treturn isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\n}\n};"
		],
		[
			5.792665961942279,
			5.183377074635478,
			6,
			50.92,
			"#define inf 1e12\nclass Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    pair<bool,pair<long long,long long>> recursion(TreeNode* root){\n        pair<bool,pair<long long,long long>> p,q;\n        if(!root){\n            p.first = true;\n            p.second.first = -1 * inf;\n            p.second.second = inf;\n            return p;\n        }\n        \n        if(root->left and root->left->val>=root->val){\n            p.first = false;\n            return p;\n        }\n        if(root->right and root->right->val<=root->val){\n            p.first = false;\n            return p;\n        }\n        p = recursion(root->left);\n        q = recursion(root->right);\n        if(p.first==false or q.first==false or root->val<=p.second.first or root->val>=q.second.second){\n            p.first = false;\n            return p;\n        }\n        p.first = true;\n        p.second.first = max(max((long long)root->val,p.second.first),q.second.first);\n        p.second.second = min(min((long long)root->val,p.second.second),q.second.second);\n        return p;\n    }\n    bool isValidBST(TreeNode* root) {\n        pair<bool,pair<int,int>> p = recursion(root);\n        return p.first;\n    }\n};\n"
		],
		[
			5.549948581470685,
			5.183377074635478,
			4,
			14.5714,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    //as long as this is smaller than the lowest minimum of integer then is fine.\n    long int previousValue = -2147483650;\n    \n    bool isValidBST(TreeNode* root) {\n        if (root == NULL) return true;\n        bool isLeftBST = isValidBST(root->left);\n        if (root->val <= previousValue) return false;\n        previousValue = root->val;\n        bool isRightBST = isValidBST(root->right);\n        return isLeftBST && isRightBST;\n    }\n};\n"
		],
		[
			5.8346538656284865,
			5.183377074635478,
			10,
			23.7037,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void recur(TreeNode* root, bool& res, int& prev, bool& firstElem) {\n        if (!root) return;\n        if (root->left) recur(root->left, res, prev, firstElem);\n        if (!firstElem) { // first element, so don't do anything\n            firstElem = true;\n        } else { // henceforth check for small or not\n            if (root->val > prev) {\n                res = res && true;\n            } else {\n                res = res && false;\n            }    \n        }\n        prev = root->val;\n        if (root->right) recur(root->right, res, prev, firstElem);\n    }\n    bool isValidBST(TreeNode* root) {\n        if (!root) return true;\n        bool res = true;\n        bool firstElem = false;\n        int prev;\n        recur(root, res, prev, firstElem);\n        return res;\n    }\n};"
		],
		[
			5.629023311883324,
			5.183377074635478,
			5,
			28.0769,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    struct QNode{\n    TreeNode *node;\n    long long lower, upper;\n};\n    bool isValidBST(TreeNode* root){\n        if(!root) return true;\n        queue<QNode> q;\n        q.emplace(QNode{root, LONG_MIN, LONG_MAX});\n        while(!q.empty()){\n            QNode curr = q.front(); q.pop();\n            TreeNode* node = curr.node;\n            if(!node) continue;\n            if(node->val<=curr.lower or node->val>=curr.upper) return false;\n            q.emplace(QNode{node->left, curr.lower, node->val});\n            q.emplace(QNode{node->right, node->val, curr.upper});\n        }\n        return true;\n    }\n};"
		],
		[
			6.011839408830001,
			5.183377074635478,
			5,
			15.2019,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        // base case\n        if (root == nullptr) {\n            return true;\n        }\n        \n        // visit the left sub-tree\n        if (!isValidBST(root->left)) {\n            return false;\n        }\n        \n        // an in-order traversal of a valid binary search tree\n        // will always process nodes in-order. if the pervious\n        // node is larger than current value, this condition\n        // fails and we can assume that the tree isn't a valid BST\n        if (previous && previous->val >= root->val) {\n            return false;\n        }\n        \n        // set the previous node to the current node\n        previous = root;\n        \n        // visit the right sub-tree\n        return isValidBST(root->right);\n    }\nprivate:\n    TreeNode* previous = nullptr;\n};\n"
		],
		[
			5.94731546980477,
			5.183377074635478,
			5,
			17.875,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    TreeNode* prev = NULL;\n    int isBst = true;\n    \n    void inorder(TreeNode* root){\n        if(!root){\n            return;\n        }\n        \n        inorder(root->left);\n        \n        if(prev == NULL){\n            prev = root;\n        }\n        \n        else{\n            if(prev->val >= root->val){\n                isBst = false;\n                return;\n            }\n            else{\n                prev = root;\n            }\n        }\n        \n        inorder(root->right);\n        \n    }\n    \n    bool isValidBST(TreeNode* root) {\n        inorder(root);\n        return isBst;\n    }\n};\n"
		],
		[
			5.886868757274673,
			5.183377074635478,
			5,
			16.75,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root, long int minValue = numeric_limits<long int>::min(), long int maxValue = numeric_limits<long int>::max()) \n    {\n        return !root ? true : minValue < root->val && maxValue > root->val ? \n\t\t\tisValidBST(root->left, minValue, root->val) && isValidBST(root->right, root->val, maxValue) : false;\n    }\n};\n/*\nIf we reach a nullptr, return true since we haven't been invalidated yet. \nOn the way down make sure that the current root's value is within our bounds. \nIf it isn't return false. If it is, make sure that its left and \nright children are within the bounds. The left child's lower bound is the smallest long number. \nIts upper bound is the current node's value, as left child must be within lower bound but less\nthan the current root.\nThe same logic applies for the right node but in reverse.\n*/\n"
		],
		[
			5.684118304003495,
			5.183377074635478,
			6,
			21.7222,
			"class Solution {\npublic:\n\tclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n  bool dfs(TreeNode* node, long long& res){\n      if(node == nullptr) return true;\n      if(!dfs(node->left, res)) return false;\n      if(res >= node->val) return false;\n      else res = node->val;\n      if(!dfs(node->right, res)) return false;\n      return true;\n    }\n    \n    bool isValidBST(TreeNode* root) {\n        long long res = numeric_limits<long long>::min();\n        return dfs(root, res);\n    }\n};"
		],
		[
			5.822910290225644,
			5.183377074635478,
			6,
			19.6,
			"class Solution {\npublic:\n\tclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool checkRange(TreeNode* node, long long l, long long h){\n        if(node == nullptr) return true;\n        if(node->val <= l || node->val >= h) return false;\n        return checkRange(node->left, l, node->val) && checkRange(node->right, node->val, h);\n    }\n    \n    bool isValidBST(TreeNode* root) {\n        return checkRange(root, numeric_limits<long long>::min(), numeric_limits<long long>::max());\n    }\n};"
		],
		[
			5.94655171539118,
			5.18337882569065,
			6,
			33.75,
			"class Solution {\npublic:\tclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    struct Tuple{\n        TreeNode* node;\n        long long l, h;\n        Tuple(TreeNode* node, long long l, long long h): node(node), l(l), h(h){}\n    };\n    \n    bool isValidBST(TreeNode* root) {\n        queue<Tuple*> q;\n        q.push(new Tuple(root, numeric_limits<long long>::min(), numeric_limits<long long>::max()));\n        while(!q.empty()){\n            Tuple* curr = q.front();\n            q.pop();\n            if(curr->node == nullptr) continue;\n            if(curr->node->val <= curr->l || curr->node->val >= curr->h) return false;\n            q.push(new Tuple(curr->node->left, curr->l, curr->node->val));\n            q.push(new Tuple(curr->node->right, curr->node->val, curr->h));\n        }\n        return true;\n    }\n};"
		],
		[
			5.882160071149272,
			5.397723270954351,
			4,
			16.9565,
			"class Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void inorder(TreeNode* root, vector<int>& tree) {\n        if(!root) return;\n        inorder(root->left, tree);\n        tree.push_back(root->val);\n        inorder(root->right, tree);\n    }\n    bool isValidBST(TreeNode* root) {\n        if (!root) return true;\n        vector<int> tree;\n        inorder(root, tree);\n        return is_sorted(tree.begin(), tree.end(), [&](int a, int b){return a <= b;});\n    }\n};\n"
		],
		[
			5.901732439418191,
			5.183377074635478,
			7,
			19.9643,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\n        if(!root) \n            return true;\n        if(nmin && root->val <= nmin->val)\n            return false;\n        if(nmax && root->val >= nmax->val)\n            return false;\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\n    }\n};\n"
		],
		[
			6.040731945243573,
			5.183377074635478,
			5,
			17.6429,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tbool isValidBST(TreeNode* n, long lo = LONG_MIN, long hi = LONG_MAX) {\n\treturn !n || (n->val > lo && n->val < hi && isValidBST(n->left, lo, n->val) && isValidBST(n->right, n->val, hi));\n}\n};"
		],
		[
			5.749925040356472,
			5.183377074635478,
			8,
			23.5625,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };bool checkValid(TreeNode* root, TreeNode* lower_bound, TreeNode* upper_bound){\n        if (root == NULL) {\n            return true;\n        }\n        \n        if (lower_bound) {\n            if (root->val >= lower_bound->val) {\n                return false;\n            }\n        }\n        \n        if (upper_bound) {\n            if (root->val <= upper_bound->val) {\n                return false;\n            }\n        }\n        \n        return checkValid(root->left, root, upper_bound) && checkValid(root->right, lower_bound, root);\n        \n    }\n    \n    bool isValidBST(TreeNode* root) {\n        return checkValid(root, NULL, NULL);\n    }\n};"
		],
		[
			5.697327499875447,
			5.183377074635478,
			7,
			22.95,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };bool isValidBST(TreeNode* root) {\n\tif (root == 0)\n\t\treturn true;\n\tbool flag = true;\n\tint pre;\n\tstack<TreeNode *>s;\n\twhile (!s.empty() || root != 0) {\n\t\tif (root != 0) {\n\t\t\ts.push(root);\n\t\t\troot = root->left;\n\t\t}\n\t\telse {\n\t\t\troot = s.top();\n\t\t\ts.pop();\n\t\t\tif (flag) {\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\telse if (root->val <= pre)\n\t\t\t\treturn false;\n\t\t\tpre = root->val;\n\t\t\troot = root->right;\n\t\t}\n\t}\n\treturn true;\n}\n};"
		],
		[
			5.872351414702584,
			5.183377074635478,
			6,
			15.6765,
			"class Solution {\n\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\t\tbool isValidBST(TreeNode* root) {\n        return DFS(root);\n    }\nprivate:\n    long preVal {LONG_MIN};\n    \n    bool DFS(TreeNode *u) {\n        if (!u) return true;\n        \n        if (!DFS(u->left)) return false;\n        if (u->val <= preVal) return false;\n        else preVal = u->val;\n        if (!DFS(u->right)) return false;\n        return true;\n    }\n};\n"
		],
		[
			5.946438475941052,
			5.183377074635478,
			9,
			50.2857,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\npair<bool, pair<int,int>> dfs(TreeNode* root){\n    \n    pair<bool, pair<int,int>> my_pair = {true, {root->val, root->val}};\n    \n    if(root->left){\n        \n        auto l = dfs(root->left);\n        \n        my_pair.first = my_pair.first && l.first;\n        \n        if(l.second.second >= root->val)                \n            my_pair.first = false;\n        \n        my_pair.second.first = min(my_pair.second.first, l.second.first);\n        my_pair.second.second = max(my_pair.second.second, l.second.second);\n    }\n    \n    if(root->right){\n        \n        auto r = dfs(root->right);\n        \n        my_pair.first = my_pair.first && r.first;\n        \n        if(r.second.first <= root->val)                \n            my_pair.first = false;\n        \n        my_pair.second.first = min(my_pair.second.first, r.second.first);\n        my_pair.second.second = max(my_pair.second.second, r.second.second);\n    }\n    \n    return my_pair;        \n}\n\nbool isValidBST(TreeNode* root) {\n    \n    if(!root)\n        return true;\n\n    return dfs(root).first;\n}\n};"
		],
		[
			6.068175546532032,
			5.183377074635478,
			8,
			20.0,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool bInit = true;\n    bool Validate(TreeNode* node, int& nValue) {        \n        if(node == nullptr) return true;\n        \n        if(!Validate(node->left, nValue))\n            return false;\n        \n        if(bInit) {\n            // Key! The only way to set minimum value.\n            nValue = node->val;\n            bInit = false;\n        }\n        else if(nValue >= node->val)\n            return false;\n        nValue = node->val;\n        if(!Validate(node->right, nValue))\n            return false;\n        return true;\n    }\n    \n    bool isValidBST(TreeNode* root) {\n        if(root == nullptr) return true;\n        \n        int nValue = INT_MIN;\n        return Validate(root, nValue);\n    }\n};\n"
		],
		[
			6.121179874490948,
			5.3799237147664245,
			8,
			25.4167,
			"class Solution {\npublic:\n#include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void GetInorderTree(TreeNode* node, vector<int>& nVector) {\n        if(node == nullptr) return;\n        if(node->left)  GetInorderTree(node->left, nVector);\n        nVector.push_back(node->val);\n        if(node->right)  GetInorderTree(node->right, nVector);\n    }\n    \n    bool isValidBST(TreeNode* root) {\n        if(root == nullptr) return true;\n        \n        vector<int> vecTree;\n        GetInorderTree(root, vecTree);\n        \n        for(int i = 1; i < vecTree.size(); i++) {\n            if(vecTree[i-1] >= vecTree[i])\n                return false;\n        }\n        return true;\n    }\n};\n"
		],
		[
			6.046876098794005,
			5.183377074635478,
			10,
			25.2857,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        if(!root) return true;\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\n        return isValidBST(root->left) && isValidBST(root->right);\n    }\n    \n    bool isValid(TreeNode* root, int bound, bool isLeft){\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\n    }\n};\n"
		],
		[
			5.944438049526831,
			5.183377074635478,
			6,
			18.8571,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        TreeNode* pre = NULL;\n        return isValid(root, pre);\n    }\n    \n    bool isValid(TreeNode* root, TreeNode* &pre){\n        if(!root) return true;\n        if(!isValid(root->left, pre)) return false;\n        if(pre && root->val <= pre->val) return false;\n        pre = root;\n        return isValid(root->right, pre);\n    }\n};\n"
		],
		[
			5.6709257899062395,
			5.183377074635478,
			6,
			18.1579,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        stack<TreeNode*>s;\n        TreeNode* pre = NULL;\n        while(root || !s.empty()){\n            while(root){\n                s.push(root);\n                root = root->left;\n            }\n            root = s.top();\n            s.pop();\n            if(pre && root->val <= pre->val) return false;\n            pre = root;\n            root = root->right;\n        }\n        return true;\n    }\n};\n"
		],
		[
			5.853765429820166,
			5.183377074635478,
			7,
			23.5714,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nint flag = 1;\nvoid valid(TreeNode *cur,long long int min,long long int max) {\n\tif (!flag)\n\t\treturn;\n\tif (cur == NULL)\n\t\treturn;\n\n\tif (cur->val > min && cur->val < max)\n\t{\n\t\tvalid(cur->left, min, cur->val);\n\t\tvalid(cur->right, cur->val, max);\n\t}\n\telse\n\t\tflag = 0;\n}\nbool isValidBST(TreeNode* root) {\t\t\n\tvalid(root,(long long int) INT_MIN-1,(long long int) INT_MAX+1);\n\tif (!flag)\n\t\treturn 0;\n\treturn 1;\n\t\n}\n };"
		],
		[
			5.871124404707519,
			5.183377074635478,
			10,
			31.7333,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        TreeNode* pre = NULL, *cur = root, *tmp = NULL;\n        while( cur ){\n            if( cur->left){\n                tmp = cur->left;\n                while(tmp->right && tmp->right!=cur) tmp = tmp->right;\n                if( !tmp->right ){\n                    tmp->right = cur;\n                    cur = cur->left;\n                }\n                else{\n                    tmp->right = NULL;\n                    if( pre && pre->val >= cur->val ) return false;\n                    pre = cur;\n                    cur = cur->right;\n                }\n            }\n            else{\n                if( pre && pre->val >= cur->val ) return false;\n                pre = cur;\n                cur = cur->right;\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			5.742999802853359,
			5.183377074635478,
			12,
			31.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };    bool isValidBST(TreeNode* root) {\n        if(root == NULL){\n            return true;\n        }\n        if(isValidBST(root->left) && isValidBST(root->right)){\n            TreeNode* leftLargest = root->left;\n            while(leftLargest != NULL && leftLargest->right !=NULL){\n                leftLargest = leftLargest->right;\n            }\n            if(leftLargest != NULL && leftLargest->val >= root->val){\n                return false;\n            }\n            TreeNode* rightSmallest = root->right;\n            while(rightSmallest != NULL && rightSmallest->left != NULL){\n                rightSmallest = rightSmallest->left;\n            }\n            if(rightSmallest != NULL && rightSmallest->val <= root->val){\n                return  false;\n            }\n            return true;\n        }\n        return false;\n    }\n};"
		],
		[
			6.036866539064334,
			5.371783561945043,
			6,
			28.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        bool result = true;\n        vector<int> v;\n        this->inOrderTraverse(root, v);\n        for (size_t i = 0; i < v.size(); ++i) {\n            if (i + 1 < v.size()) {\n                if (v[i + 1] <= v[i]) {\n                    result = false;\n                    break;\n                }\n            }\n        }\n        return result;\n    }\nprivate:\n    void inOrderTraverse(TreeNode* root, vector<int>& v) {\n        if (root) {\n            inOrderTraverse(root->left, v);\n            v.push_back(root->val);\n            inOrderTraverse(root->right, v);\n        }\n    }\n};"
		],
		[
			5.737474039357986,
			5.183377074635478,
			8,
			30.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };inline void f75(TreeNode* root,double left,double right,bool& flag){\n\tif(flag==false) return;\n\tif(root->val<right && root->val>left){\n\t\tif(root->left) f75(root->left,left,root->val,flag);\n\t\tif(root->right) f75(root->right,root->val,right,flag);\n\t}else\n\t\tflag=false;\n\treturn;\n}\nbool isValidBST(TreeNode* root){\n\tif(root==NULL) return true;\n\tbool flag=true;\n\tdouble min=INT_MIN;\n\tmin--;\n\tdouble max=INT_MAX;\n\tmax++;\n\tf75(root,min,max,flag);\n\treturn flag;\n}\n};"
		],
		[
			5.992946436363948,
			5.183377074635478,
			8,
			23.1562,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root, long minVal = LONG_MIN, long maxVal = LONG_MAX) {\n        return (!root->left || root->left->val > minVal && root->left->val < root->val && isValidBST(root->left, minVal, min(maxVal, (long)root->val))) && (!root->right || root->right->val > root->val && root->right->val < maxVal && isValidBST(root->right, max(minVal, (long)root->val), maxVal));\n    }\n};"
		],
		[
			5.756603949429745,
			5.183377074635478,
			6,
			16.45,
			"class Solution {\n\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        return validate(root, LONG_MIN, LONG_MAX);\n    }\n    private:\n    inline bool validate(TreeNode* node, long min, long max) {\n        if (!node) return true;\n        long val = node->val;\n        if (val >= max || val <= min) {\n            return false;\n        }\n        return validate(node->left, min, val) && validate(node->right, val, max);\n    }\n};"
		],
		[
			5.948849355231007,
			5.183377074635478,
			4,
			13.2,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };bool isValidBST(TreeNode* root) {\n  if (!root) return true;\n\n  if (!isValidBST(root->left)) return false;\n  static long pre=LONG_MIN;\n  if (pre>=(long)root->val) return false;\n  pre = root->val;\n\n  return isValidBST(root->right);\n}\n};"
		],
		[
			5.880650805081312,
			5.183377074635478,
			11,
			36.4737,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n    \tint max, min;\n    \treturn isValidBST_c(root, &max, &min);\n    }\nprivate:\n\tbool isValidBST_c(TreeNode* root, int* max, int* min){\n\t\tif (root == nullptr)\n\t\t\treturn true;\n\n\t\tint l_max, l_min;\n\t\tint r_max, r_min;\n\t\tbool b_left = isValidBST_c(root->left, &l_max, &l_min);\n\t\tbool b_right = isValidBST_c(root->right, &r_max, &r_min);\n\n\t\tif(b_left && b_right) {\n\t\t\t*max = root->right == nullptr ? root->val : r_max;\n\t\t\t*min = root->left == nullptr ? root->val : l_min;\n\n\t\t\tif (root->left != nullptr && root->val <= l_max)\n\t\t\t\treturn false;\n\t\t\tif (root->right != nullptr && root->val >= r_min)\n\t\t\t\treturn false;\n\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};"
		],
		[
			5.752277694015931,
			5.183377074635478,
			6,
			17.2941,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };bool isValidBST(TreeNode* root) {\n    return dfs_valid(root, LONG_MIN, LONG_MAX);\n}\nbool dfs_valid(TreeNode *root, long low, long high) {\n    if (!root) return true;\n    return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\n            && dfs_valid(root->right, root->val, high);\n}\n};"
		],
		[
			6.345472478830448,
			5.319407816814939,
			10,
			33.5676,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        vector<int> array;\n        initialize(root);\n        while(hasNext())\n        {\n            array.push_back(next());\n        }\n        int n = array.size();\n        int i;\n        if(n==0)\n            return true;\n        int tempvalue = array[0];\n        for(i=1; i<n; i++)\n        {\n            if(array[i] <= tempvalue)\n                return false;\n            tempvalue = array[i];\n        }\n        return true;\n    }\n    private:\n    TreeNode *node;\n    vector<TreeNode*> leftMostNodes;\n    \n    void initialize(TreeNode* root)\n    {\n        node = root;\n    }\n    \n    bool hasNext()\n    {\n        while(node)\n        {\n            leftMostNodes.push_back(node);\n            node = node->left;\n        }\n        if(leftMostNodes.size() == 0)\n            return false;\n        else\n            return true;\n    }\n    \n    int next()\n    {\n        int value;\n        node = leftMostNodes.back();\n        leftMostNodes.pop_back();\n        value = node->val;\n        node = node->right;\n        return value;\n    }\n};"
		],
		[
			5.906306802905495,
			5.183377074635478,
			9,
			25.5,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        if(!root) return true;\n        \n        if(root->left) {\n            TreeNode* l = root->left;\n            while(l){\n                if(l->val >= root->val) return false;\n                l = l->right;\n            }\n        }\n        \n        if(root->right){\n            TreeNode* r = root->right;\n            while(r) {\n                if(r->val <= root->val) return false;\n                r = r->left;\n            }\n        }\n        \n        return isValidBST(root->left)&&isValidBST(root->right);\n    }\n};"
		],
		[
			5.732895959067946,
			5.183377074635478,
			8,
			26.2083,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int ok = true, first = true;\n    bool isValidBST(TreeNode* root) {\n        int prev;\n        travel(root, prev);\n        return ok;\n    }\n    \n    void travel(TreeNode *root, int &prev) {\n        if (!(ok && root)) return;\n        if (root->left) travel(root->left, prev);\n        int mid = root->val;\n        if (!first) {\n            if (mid <= prev) ok = false;\n            prev = mid;\n        } else { \n            first = false; \n            prev = mid; \n        }\n        if (root->right) travel(root->right, prev);\n    }\n};"
		],
		[
			5.636089669717016,
			5.183377074635478,
			4,
			22.8947,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };void isValidHelper(TreeNode* root, bool& is_valid, long& low){\n        \n        if(root == NULL){\n            return;\n        }\n        \n        isValidHelper(root->left,is_valid,low);\n        \n        if(low < root->val){\n            low = root->val;\n        }\n        else{\n            is_valid = false;\n            return;\n        }\n        \n        isValidHelper(root->right,is_valid,low);\n        \n    }\n\n    bool isValidBST(TreeNode* root) {\n        \n        bool is_valid = true;\n        long low = LONG_MIN;\n        \n        isValidHelper(root,is_valid,low);\n        \n        return is_valid;\n        \n    }\n};"
		],
		[
			5.92217126411396,
			5.183377074635478,
			12,
			24.0893,
			"//I have past 72/74 testcase, the wrong testcase [3,1,5,0,2,4,6,null,null,null,3],\n//which expected false, \n//he said my codes returning true, but I even test it in my IDE,\n// no problem...so for help!\nclass Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nbool isValidBST(TreeNode* root) {\n      return iVB(root,0,0);\n}\nbool iVB(TreeNode * root, int flag, int fatherVal)//flag 1 left 2 right\n{\n    if (root == NULL)\n        return true;\n    if (root->left != NULL)\n    {\n        if (root->left->val >= root->val)\n            return false;\n        if (flag==2 && root->left->val <= fatherVal)//right subtree's left son \n                                //must greater than the father node's val\n            return false;\n    }\n    if (root->right != NULL)\n    {\n        if (root->right->val <= root->val)\n            return false;\n        if (flag==1 && root->right->val >= fatherVal)//left subtree's right son \n                              //must greater than the father node's val\n            return false;\n    }\n    return iVB(root->left,1,root->val) && iVB(root->right,2,root->val);\n}\n};"
		],
		[
			5.8016664043675314,
			5.183377074635478,
			12,
			34.0,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nbool isValidBST(TreeNode* root){\n\tif(root)\n\t{\n\t\tbool isOk = true;\n\t\t\n\t\tif(root->left)\n\t\t\tisOk = recursiveCheck(root->left, numeric_limits<long int>::min(), root->val);\n\n\t\tif(isOk)\n\t\t{\n\t\t\tif(root->right)\n\t\t\t\treturn recursiveCheck(root->right, root->val, numeric_limits<long int>::max());\n\t\t\t\n\t\t\treturn isOk;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\telse\n\t\treturn true;\n}\n\nbool recursiveCheck(TreeNode * ctnode, long int lowerBound, long int upperBound)\n{\n\tif(!ctnode) return true;\n\telse if(ctnode->val >= upperBound || ctnode->val <= lowerBound)\n\t\treturn false;\n\telse\n\t{\n\t\tbool isOk = true;\n\t\tif(ctnode->left)\n\t\t{\n\t\t\tisOk = recursiveCheck(ctnode->left, lowerBound, ctnode->val);\n\t\t}\n\n\t\tif(isOk)\n\t\t{\n\t\t\tif(ctnode->right)\n\t\t\t\treturn recursiveCheck(ctnode->right, ctnode->val, upperBound);\n\t\t\telse\n\t\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n}\n};"
		],
		[
			5.754964038659045,
			5.183377074635478,
			8,
			23.6667,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root, long minVal = LONG_MIN, long maxVal = LONG_MAX) {\n        // checking the left branch\n        bool isBalancedLeft = !root->left || root->left->val > minVal && root->left->val < root->val && isValidBST(root->left, minVal, min(maxVal, (long)root->val));\n        // checking the right branch\n        bool isBalancedRight = !root->right || root->right->val > root->val && root->right->val < maxVal && isValidBST(root->right, max(minVal, (long)root->val), maxVal);\n        return isBalancedLeft && isBalancedRight;\n    }\n};"
		],
		[
			5.934905054045467,
			5.183377074635478,
			6,
			18.7778,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };//recursive solution with \"&\" trick\nbool isValidBST(TreeNode* root) {\n    if (!root)\n        return true;\n    TreeNode* n = NULL;\n    return isValidBST(root, n);\n}\n\nbool isValidBST(TreeNode* root, TreeNode* &prev) {\n    if (root->left && !isValidBST(root->left, prev))\n        return false;\n    if (prev && root->val <= prev->val)\n        return false;\n    prev = root;\n    return !root->right || isValidBST(root->right, prev);\n}\n};"
		],
		[
			5.91942829702089,
			5.183377074635478,
			7,
			19.5,
			"class Solution {\nprivate:\n    int min = INT_MIN;\n    bool first = true;\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        if( !root )\n            return true;\n        bool tag = true;\n        tag = tag && isValidBST( root->left );\n        if( ( first && root->val == INT_MIN ) || min < root->val )\n        {\n            min = root->val;\n            first = false;\n        }\n        else\n            tag = false;\n        tag = tag && isValidBST( root->right );\n        return tag;\n    }\n};"
		],
		[
			5.8626199644236365,
			5.183377074635478,
			9,
			35.2857,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        if(!root){\n            return true;\n        }\n        int left, right;\n        return BFSvalid(root, left, right);\n    }\n    \n    bool BFSvalid(TreeNode* root, int& left, int& right){\n        int l_left, l_right, r_left, r_right;\n        left = root->val;\n        right = root->val;\n        if(root->left){\n            if(!BFSvalid(root->left, l_left, l_right) || l_right >= root->val)  return false;\n            left = l_left;\n        }\n        if(root->right){\n            if(!BFSvalid(root->right, r_left, r_right) || r_left <= root->val)  return false;\n            right = r_right;\n        }\n        return true;\n    }\n};\n"
		],
		[
			5.7923021792517675,
			5.183377074635478,
			6,
			17.25,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        return helper(root, numeric_limits<long long int>::min(), numeric_limits<long long int>::max());\n    }\n    \n    bool helper(TreeNode* root, long long int lower, long long int upper) {\n        return !root || root->val > lower && root->val < upper && helper(root->left, lower, root->val) && helper(root->right, root->val, upper);\n    }\n};"
		],
		[
			5.922806136949187,
			5.183377074635478,
			8,
			31.3235,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        TreeNode *curNode = root, *preNode;\n        long long last_val = LLONG_MIN;\n        while(curNode)\n        {\n            if(!curNode->left)\n            {\n                if(curNode->val <= last_val)\n                    return false;\n                last_val = curNode->val;\n                curNode = curNode->right;\n            }\n            else\n            {\n                preNode = curNode->left;\n                while(preNode->right && preNode->right != curNode)\n                    preNode = preNode->right;\n                if(!preNode->right)\n                {\n                    preNode->right = curNode;\n                    curNode = curNode->left;\n                }\n                else\n                {\n                    if(curNode->val <= last_val)\n                        return false;\n                    last_val = curNode->val;\n                    preNode->right = nullptr;\n                    curNode = curNode->right;\n                }\n            }\n        }\n        return true;   \n    }\n};"
		],
		[
			5.905796647362092,
			5.183377074635478,
			8,
			26.4643,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n        TreeNode* cur = root;\n        while (cur) {\n            if (cur->right && cur->val >= cur->right->val) {\n                return false;\n            }\n\n            if (!cur->left) {\n                cur = cur->right;\n            }\n            else {\n                TreeNode * prev = cur->left;\n                while (prev->right && prev->right != cur) {\n                    prev = prev->right;\n                }\n                if (prev->right) {\n                    prev->right = nullptr;\n                    cur = cur->right;\n                } else {\n                    prev->right = cur;\n                    cur = cur->left;\n                }\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			5.909628393017115,
			5.366615574042289,
			6,
			22.7174,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };void check(TreeNode* curnode)\n{\n\tif(curnode == NULL)\n\t\treturn ;\n    check(curnode->left);\n        s_arr.push_back(curnode->val);\n    check(curnode->right);\n    return ;\n}\n\nbool isValidBST(TreeNode *root) {\n     if(root == NULL)\n        return true;\n    check(root);\n    for(int i = 1 ; i < s_arr.size() ;i++)\n    {\n        if(s_arr[i] <= s_arr[i-1])\n            return false;\n    }\n    return true;\n}\n\nvector<int> s_arr;\n};"
		],
		[
			5.626782035145082,
			5.183377074635478,
			2,
			30.9474,
			"class Solution {\n    public:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \tbool isValidBST(TreeNode* root, int upper, bool hasupper, int lower, bool haslower) {\n    \t\tif ((root->left != NULL && (root->left->val >= root->val || (haslower &&root->left->val <= lower))) ||\n    \t\t\t(root->right != NULL && (root->right->val <= root->val ||( hasupper && root->right->val >= upper))) ||\n    \t\t\t(root->left != NULL && !isValidBST(root->left, root->val, true, lower, haslower)) ||\n    \t\t\t(root->right != NULL && !isValidBST(root->right, upper, hasupper, root->val, true))\n    \t\t\t)\n    \t\t{\n    \t\t\treturn false;\n    \t\t}\n    \t\treturn true;\n    \t}\n    \tbool isValidBST(TreeNode* root) {\n    \t    if (root == NULL) return true;\n    \t\treturn isValidBST(root, INT_MAX, false, INT_MIN, false);\n    \t}\n    };"
		],
		[
			5.851826092167873,
			5.183377074635478,
			6,
			22.0833,
			"class Solution {\n    public:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n        bool isValidBST(TreeNode *root) {\n            long long min = LLONG_MIN, max = LLONG_MAX;\n            return isValidBST(root, min, max);\n        }\n        bool isValidBST(TreeNode *node, long long min, long long max){\n            if(node == NULL)\n                return true;\n            if(node->val <= min || node->val >= max)\n                return false;\n            if(!isValidBST(node->left, min, node->val) || !isValidBST(node->right, node->val, max))\n                return false;\n            return true;\n        }\n    };"
		],
		[
			5.9658131088926085,
			5.183377074635478,
			6,
			19.52,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };bool isValidBST(TreeNode *root) {\n        // use long min and long max if the value in tree is int\n        return isValidBSTRec(root, LONG_MIN, LONG_MAX);\n    }\n    \n    bool isValidBSTRec(TreeNode* root, long min, long max) {\n        if (root == NULL) {\n            return true;\n        }\n        \n        if (root->val <= min || root->val >= max) {\n            return false;\n        }\n        \n        bool left = isValidBSTRec(root->left, min, root->val);\n        if (left == true) {\n            return isValidBSTRec(root->right, root->val, max);\n        }\n        return false;\n    }\n};"
		],
		[
			6.213843943399632,
			5.183377074635478,
			12,
			23.5278,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root, long minVal = LONG_MIN, long maxVal = LONG_MAX) {\n        // checking the left branch\n        bool isLeftChildValueBalanced = root->left && root->left->val > minVal && root->left->val < root->val;\n        bool isLeftBranchBalanced = root->left && isValidBST(root->left, minVal, min(maxVal, (long)root->val));\n        // a valid left branch: either NULL or both its root and its children are balanced\n        bool isBalancedLeft = !root->left || isLeftChildValueBalanced && isLeftBranchBalanced;\n        // checking the right branch\n        bool isRightChildValueBalanced = root->right && root->right->val > root->val && root->right->val < maxVal;\n        bool isRightBranchBalanced = root->right && isValidBST(root->right, max(minVal, (long)root->val), maxVal);\n        // a valid right branch: either NULL or both its root and its children are balanced\n        bool isBalancedRight = !root->right || isRightChildValueBalanced && isRightBranchBalanced;\n        return isBalancedLeft && isBalancedRight;\n    }\n};"
		],
		[
			6.1230877008291955,
			5.3639788344349615,
			6,
			27.7391,
			"class Solution {\npublic:\n#include<vector>\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvoid inorder(TreeNode* root,vector<int>&v)\n{\n    if(root==NULL)\n    {\n        return;\n    }\n    inorder(root->left,v);\n    v.push_back(root->val);\n    inorder(root->right,v);\n}\n\nbool isValidBST(TreeNode* root) {\n    \n    if(root==NULL)\n    {\n        return true;\n    }\n    vector<int>v;\n    inorder(root,v);\n    for(int i=0;i<v.size()-1;i++)\n    {\n        if(v[i]>=v[i+1])\n        {\n            return false;\n            break;\n        }\n    }\n    return true;\n}\n};"
		],
		[
			5.702621624685684,
			5.183377074635478,
			5,
			15.4286,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    bool isValidBST(TreeNode* root) {\n    \tif (root == nullptr)\n    \t\treturn true;\n\n    \tif(!isValidBST(root->left))\n    \t\treturn false;\n\n    \tif (pre != nullptr && pre->val >= root->val)\n    \t\treturn false;\n\n    \tpre = root;\n    \treturn isValidBST(root->right);\n\n    }\nprivate:\n\tTreeNode* pre = nullptr;\n};"
		]
	],
	"LEVELORDER_TRAVERSAL": [
		"n",
		[
			6.357805507098087,
			5.477479050933819,
			6,
			20.8696,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n        if(!root) {\n            return {};\n        }\n        \n        vector<vector<int>> ans;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while(!q.empty()) {\n            int n = q.size();\n            vector<int> tmp;\n            \n            while(n>0) {\n                TreeNode* t = q.front(); q.pop();\n                \n                tmp.push_back(t->val);\n                \n                if(t->left) {\n                    q.push(t->left);\n                }\n                if(t->right) {\n                    q.push(t->right);\n                }\n                \n                n--;\n            }\n            ans.push_back(tmp);\n        }\n        \n        return ans;\n        \n    }\n};\n"
		],
		[
			6.217534851836169,
			5.483377423393181,
			6,
			21.7857,
			"class Solution\n{\n\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode *root)\n    {\n        vector<vector<int>> result;\n        if (!root)\n            return result;\n\n        queue<TreeNode *> traversalQueue;\n        traversalQueue.push(root);\n\n        while (!traversalQueue.empty())\n        {\n            int toBeTraversed = traversalQueue.size();\n\n            vector<int> currLevel;\n            while (toBeTraversed--)\n            {\n                TreeNode *currNode = traversalQueue.front();\n\n                currLevel.push_back(currNode->val);\n                traversalQueue.pop();\n\n                if (currNode->left)\n                    traversalQueue.push(currNode->left);\n\n                if (currNode->right)\n                    traversalQueue.push(currNode->right);\n            }\n            result.push_back(currLevel);\n        }\n        return result;\n    }\n};\n"
		],
		[
			5.9371294291651475,
			5.3228107354318,
			4,
			22.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    void helper(TreeNode* root,vector<vector<int>>&ans,int level){\n        if(root==NULL)return;\n        if(level>=ans.size()){//this means this level has not been parsed before and is therefore absent in the ans variable\n            ans.push_back(vector<int>{root->val});\n        }\n        else{//as level is already present, simply push to that level's vector\n            ans[level].push_back(root->val);   \n        }\n        helper(root->left,ans,level+1);\n        helper(root->right,ans,level+1);\n        \n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>>ans;\n        helper(root,ans,0);\n        return ans;\n    }\n};"
		],
		[
			5.87072463421341,
			5.378731849082835,
			4,
			33.06,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> ans;\n    \n    void dfs(TreeNode* root, int level) {\n        if (!root) \n            return;\n        \n        if (level == ans.size()) {\n            ans.push_back({});\n        }\n        \n        ans[level].push_back(root->val);\n        \n        dfs(root->left, level+1);\n        dfs(root->right, level+1);\n    }\n    \n    vector<vector<int>> levelOrder(TreeNode* root) {\n        dfs(root, 0);\n        \n        return ans;\n    }\n};\n"
		],
		[
			6.057889559015667,
			5.476286447181304,
			6,
			33.0862,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n\t\tvector<vector<int>> ans;\n\n\t\tif (!root) {\n            return ans;\n        }\n        \n        queue<TreeNode*> q;\n        \n        q.push(root);\n\n        while (!q.empty()) {\n            vector<int> t;\n            int s = q.size();\n            \n            while (s--) {\n                TreeNode* r = q.front();\n                q.pop();\n                \n                t.push_back(r->val);\n                \n                if (r->left != nullptr) \n                    q.push(r->left);\n                \n                if (r->right != nullptr)\n                    q.push(r->right);\n            }\n            \n            ans.push_back(t);\n        }\n        \n        return ans;\n    }\n};\n"
		],
		[
			6.068343594642015,
			5.492687068542817,
			6,
			23.3043,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<vector<int>> levelOrder(TreeNode* root) {\n       vector<vector<int>> res;\n       if(!root) return res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int size = q.size();\n            vector<int> v;\n            for(int i = 0; i < size; i++){\n                TreeNode* temp = q.front();\n                q.pop();\n                v.push_back(temp->val);\n                if(temp->left) q.push(temp->left);\n                if(temp->right) q.push(temp->right);\n            }\n            res.push_back(v);\n        }\n        return res;\n    }\n};"
		],
		[
			6.056863645841048,
			5.484119610474698,
			6,
			26.2391,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root) {\n       queue<TreeNode*> Q;\n        vector<vector<int>> res;\n        if(root == nullptr) return res;\n        Q.push(root);\n        while(Q.size() != 0) {\n            int size = Q.size();\n            vector<int> v;\n            for(int i = 0; i < size; i++) {\n                 TreeNode* t = Q.front();\n                 Q.pop();\n                 v.push_back(t->val);\n                if(t->left != nullptr) \n                    Q.push(t->left);\n                if(t->right != nullptr)\n                    Q.push(t->right);\n            }\n            res.push_back(v);\n        }\n        return res;\n    }\n};"
		],
		[
			6.4292698689941545,
			5.78351503142983,
			6,
			27.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) \n    {\n        \n          \n          vector<vector<int>>ans{};\n          if(!root) return ans;\n        vector<int> row;\n        vector<pair<TreeNode*,int>> vec; // to store the node and its level\n        int level=0;\n        vec.push_back({root,0});\n        int size =1;\n        int i=0;\n        int j=0;\n        while(i<size)// must take indices because iterators may become invalid upon adding to the vector\n        {\n            while(vec[i].second==level)\n            {\n                row.push_back(vec[i].first->val);\n                if(vec[i].first->left)   {vec.push_back({vec[i].first->left, level+1});  size++;  }\n                if(vec[i].first->right) {vec.push_back({vec[i].first->right,level+1});  size++;  }\n                i++;\n            }\n            level++;\n            ans.push_back(row);\n            row.clear();\n        }\n        \n        return ans;\n    }\n};\n"
		],
		[
			6.16728487316912,
			5.416875688853466,
			6,
			20.9118,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (root == NULL) return {};\n        vector<vector<int>>res;\n        queue<TreeNode*>q;\n        q.push(root);\n        vector<int>temparr;\n        while(!q.empty()) {\n            // n is the number of nodes in the current level\n            int n = q.size();\n            for (int i = 0; i<n; i++) {\n                TreeNode* temp = q.front();\n                q.pop();\n                temparr.push_back(temp->val);\n                if (temp->left) {\n                    q.push(temp->left);\n                }\n                if (temp->right) {\n                    q.push(temp->right);\n                }\n            }\n            res.push_back(temparr);\n            temparr.clear();\n        }\n        return res;\n    }\n};"
		],
		[
			6.16204039812263,
			5.476520571428921,
			6,
			22.3333,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> ret;\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return {};\n        deque<TreeNode*> que{root};\n        vector<int> temp;\n        while(!que.empty()){\n            int n = que.size();\n            for(int i=0;i<n;++i){\n                TreeNode* cur = que.front();\n                temp.push_back(cur->val);\n                que.pop_front();\n                if(cur->left) que.push_back(cur->left);\n                if(cur->right) que.push_back(cur->right);\n            }\n            ret.push_back(temp);\n            temp.clear();\n        }\n        return ret;\n    }\n};\n"
		],
		[
			5.945888834935527,
			5.316175254892674,
			4,
			29.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    void helper(TreeNode*root,vector<vector<int>>&result,int level){\n        if(root){\n            if(level==result.size()){result.push_back({root->val});}\n            else{result[level].push_back(root->val);}\n            helper(root->left,result,level+1);\n            helper(root->right,result,level+1);\n        }\n    }\n    vector<vector<int>>levelOrder(TreeNode* root) {\n        vector<vector<int>>result;\n        int level=0;\n        helper(root,result,0);\n        return result;\n    }\n};\n"
		],
		[
			6.12499160853732,
			5.3184495664020215,
			4,
			23.8,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        dfs(root, 0, ans);\n        return ans;\n    }\nprivate:\n    void dfs(TreeNode* node, int level, vector<vector<int>> &ans) {\n        if(!node) {\n            return;\n        }\n        while(level >= ans.size()) {\n            ans.push_back({});\n        }\n        \n        ans[level].push_back(node->val);\n        \n        dfs(node->left, level+1, ans);\n        dfs(node->right, level+1, ans);\n    }\n};\n"
		],
		[
			6.693415486398681,
			5.602047547012519,
			6,
			24.4286,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        queue<pair<TreeNode*,int>>q;\n        map<int,vector<int>>m;\n        vector<vector<int>>res;\n        if(!root)\n            return res;\n        int x;\n        TreeNode* temp;\n        q.push({root,0});\n        \n        while(!q.empty())\n        {\n            temp=q.front().first;\n            x=q.front().second;\n            m[x].push_back(temp->val);\n            q.pop();\n            if(temp->left)\n                q.push({temp->left,x+1});\n            if(temp->right)\n                q.push({temp->right,x+1});\n        }\n        \n        for(auto r:m)\n        {\n            res.push_back(r.second);\n        }\n        \n        return res;\n        \n    }\n};\n"
		],
		[
			6.140036033001703,
			5.328745064422576,
			5,
			24.75,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tint height(TreeNode* root){\n        if(!root) return 0;\n        return 1+max(height(root->left),height(root->right));\n    }\n    \n    void helper(vector<vector<int>> &ans, TreeNode *root,int level){\n        if(!root) return;\n        ans[level].push_back(root->val);\n        helper(ans,root->left,level+1);\n        helper(ans,root->right,level+1);\n    }\n    \n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans(height(root));\n        helper(ans,root,0);\n        return ans;\n    }\n};"
		],
		[
			6.1764200713529185,
			5.48891277645457,
			6,
			34.5161,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(root==nullptr) return {};\n        \n        vector<vector<int>>res;\n        queue<TreeNode*>q;\n        q.push(root);\n        \n        while(q.empty()==false)\n        {\n            vector<int>curr_res;\n            int c=q.size();\n            for(int i=0;i<c;i++)\n            {\n                TreeNode* t=q.front();\n                curr_res.push_back(t->val);\n                q.pop();\n                if(t->left)\n                    q.push(t->left);\n                if(t->right)\n                    q.push(t->right);\n            }\n            res.push_back(curr_res);\n        }\n        return res;\n    }\n};"
		],
		[
			6.304544523468158,
			5.43906256901602,
			11,
			42.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n    if(!root)\n        return {};\n    \n    vector<vector<int>> ans;\n    queue<TreeNode*> q1,q2;\n    int level=0;\n    TreeNode *temp;\n    \n    q1.push(root);\n    \n    while(!(q1.empty() && q2.empty())){\n        if(q1.empty()){\n            ans.push_back({});\n            while(!q2.empty()){\n                temp=q2.front();\n                q2.pop();\n                ans[level].push_back(temp->val);\n                \n                if(temp->left)\n                    q1.push(temp->left);\n                if(temp->right)\n                    q1.push(temp->right);\n            }\n        }\n        else{\n            ans.push_back({});\n            while(!q1.empty()){\n                temp=q1.front();\n                q1.pop();\n                ans[level].push_back(temp->val);\n                \n                if(temp->left)\n                    q2.push(temp->left);\n                if(temp->right)\n                    q2.push(temp->right);\n            }\n        }\n        level++;\n    }\n    \n    return ans;\n}\n};\n"
		],
		[
			6.329029742691418,
			5.529027170847598,
			6,
			26.6667,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> results={};\n        if(root==NULL){\n            return results;\n        }\n        queue<pair<int, TreeNode*>> q;\n        q.push({0, root});\n        while(!q.empty()){\n            auto top = q.front();\n            q.pop();\n            if(results.size()<top.first+1){results.resize(top.first+1, vector<int>{});}\n            (results[top.first]).push_back(top.second->val);\n            if(top.second->left!=NULL){\n                q.push({top.first+1, top.second->left});\n            } \n            if(top.second->right!=NULL){\n                q.push({top.first+1, top.second->right});\n            }\n        }\n        return results;\n    }\n};\n"
		],
		[
			6.420434521755213,
			5.428537891747687,
			9,
			44.4583,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    int size(TreeNode* root){\n        if(root==NULL) return 0;\n        return size(root->left) + size(root->right) + 1;\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>>ans;\n        if(root==NULL) return ans;\n        queue<TreeNode*>q;\n        q.push(root);\n        int i=0;\n        q.push(NULL);\n        vector<int>inside;\n        ans.push_back(inside);\n        int count = size(root);\n        while(!q.empty()){\n            TreeNode* front = q.front();\n            q.pop();\n            if(front==NULL) {\n                if(count<=0) break;\n                q.push(NULL);\n                ++i;\n                vector<int>inside;\n                ans.push_back(inside);\n                continue;\n            }\n            if(front->left!=NULL) q.push(front->left);\n            if(front->right!=NULL) q.push(front->right);\n            ans[i].push_back(front->val);\n            --count;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			6.326504419375512,
			5.476466382166621,
			6,
			21.4286,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> output;\n        queue<TreeNode*> bq;\n        if(root) bq.push(root);\n        while(!bq.empty()){\n            vector<int> level;\n            int s = bq.size();\n            while(s--){\n                TreeNode* tn = bq.front();\n                bq.pop();\n                level.push_back(tn->val);\n                if(tn->left) bq.push(tn->left);\n                if(tn->right) bq.push(tn->right);\n            }\n            output.push_back(level);\n        }\n        return output;\n    }\n};\n"
		],
		[
			6.177341838808004,
			5.642842827993825,
			6,
			30.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res{};\n        vector<TreeNode*> currLevel{};\n        if (root) currLevel.push_back(root);\n        while (currLevel.size()) {\n            vector<TreeNode*> nextLevel{};\n            vector<int> temp{};\n            for (TreeNode* n: currLevel) {\n                temp.push_back(n->val);\n                if (n->left) nextLevel.push_back(n->left);\n                if (n->right) nextLevel.push_back(n->right);\n            }\n            currLevel = nextLevel;\n            res.push_back(temp);\n        }\n        return res;\n    }\n};\n"
		],
		[
			6.317826392357407,
			5.607830091516411,
			8,
			28.3636,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(root){\n           queue<TreeNode*> q1;\n            queue<TreeNode*> q2;\n            q1.push(root);\n            while(!(q1.empty() && q2.empty())){\n                vector<int> current;\n                while(!q1.empty()){\n                    TreeNode* curr = q1.front();\n                    if(curr->left) q2.push(curr->left);\n                    if(curr->right) q2.push(curr->right);\n                    current.push_back(curr->val);\n                    q1.pop();\n                }\n                // printVector(current);\n                solution.push_back(current);\n                swap(q1,q2);   \n            } \n        }\n        return solution;\n    }\n    private:\n    vector<vector<int>> solution;\n    void swap(queue<TreeNode*>&a,queue<TreeNode*>&b){\n        queue<TreeNode*> temp = a;\n        a = b;\n        b = temp;\n    }\n};\n"
		],
		[
			6.316600715588237,
			5.47690585605868,
			6,
			23.2727,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        queue<TreeNode*> nodes;\n        vector<vector<int>> ans;\n        if(root)\n            nodes.push(root);\n        while(!nodes.empty()){\n            int size=nodes.size();\n            vector<int> temp;\n            \n            for(int i=0;i<size;i++){\n               TreeNode* curr=nodes.front(); \n                temp.push_back(curr->val);\n                if(curr->left)\n                    nodes.push(curr->left);\n                if(curr->right)\n                    nodes.push(curr->right);\n                nodes.pop();\n            }\n            ans.push_back(temp);\n            \n        }\n        return ans;\n    }\n};\n"
		],
		[
			6.265409360512873,
			5.422003274364048,
			7,
			26.6667,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> v;\n        if(root ==NULL)\n        {\n            \n            return v;\n        }\n        vector<int> temp;\n        queue<TreeNode*> q;\n        q.push(root);\n        q.push(NULL);\n        \n        while(!q.empty())\n        {\n            TreeNode* f = q.front();\n            q.pop();\n            if(f== NULL)\n            {\n                v.push_back(temp);\n                temp.clear();\n                if(!q.empty())\n                {\n                    q.push(NULL);\n                }\n                \n            }\n            else{\n             \n             temp.push_back(f->val);\n            if(f->left)\n            {\n                q.push(f->left);\n            }\n            if(f->right)\n            {\n                q.push(f->right);\n            }\n                \n            }\n        }\n        return v;\n        \n    }\n};\n"
		],
		[
			6.420902970625861,
			5.42439933223593,
			7,
			26.9388,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(root==NULL)\n            return ans;\n        \n        leveltraversal(root,0); // Function call\n        \n        return ans;   \n    }\nprivate:\n    vector<vector<int>> ans;  // Answer vector, to be retuned\n    void leveltraversal(TreeNode* root, int level)\n    {\n        vector<int> temp(1,0);  //To push first vaue in a certain level in ans as it will only take a vector\n        \n        if(ans.empty() || ans.size()<=level)\n        {\n            temp[0]=root->val;\n            ans.push_back(temp);\n            temp.clear();\n        }\n        else\n        {\n            ans[level].push_back(root->val);\n        }\n        \n        if(root->left!=NULL)    // Traversing Left Child\n           leveltraversal(root->left,level+1);\n        \n        if(root->right!=NULL)   // Traversing Right Child\n            leveltraversal(root->right,level+1);\n    } \n};\n"
		],
		[
			6.167815840364167,
			5.423272617892226,
			6,
			23.2727,
			"\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n        queue<TreeNode*> q;\n        vector<vector<int>> ans;\n        vector<int> temp;\n        \n        if(root == NULL)return ans;\n        \n        q.push(root);\n        \n        while(!q.empty()){\n            int size = q.size();\n            \n            while(size--){\n                TreeNode* curr = q.front();\n                q.pop();\n                temp.push_back(curr->val);\n                if(curr->left) q.push(curr->left);\n                if(curr->right) q.push(curr->right);\n            }\n            \n            ans.push_back(temp);\n            temp.clear();\n            \n        }\n        \n        return ans;\n        \n    }\n};\n\n"
		],
		[
			6.545459200168911,
			5.540728352696074,
			6,
			28.3846,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tvector<vector<int>> levelOrder(TreeNode* root) {\n        if (!root) return {};\n        vector<vector<int>> res;\n        queue<pair<TreeNode*,int>> q;\n        pair<TreeNode*,int> node;\n        q.push(make_pair(root,0));\n        while (!q.empty()) {\n            node = q.front();\n            q.pop();\n            if (res.size() <= node.second) res.push_back({});\n            res[node.second].push_back(node.first->val);\n            \n            if (node.first->left) q.push(make_pair(node.first->left,node.second+1));\n            if (node.first->right) q.push(make_pair(node.first->right, node.second+1));\n        }\n        return res;\n    }\n};"
		],
		[
			6.241842585211217,
			5.475003081651726,
			6,
			19.3846,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (root == NULL)\n            return {};\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            vector<int> tmp;\n            int qSize = q.size(); // Only difference with P104 is that we need to fix the size of queue in each epoch\n            for (int i = 0; i < qSize; i++) {\n                TreeNode* p = q.front();\n                q.pop();\n                tmp.push_back(p->val);\n                if (p->left != NULL) \n                    q.push(p->left);\n                if (p->right != NULL)\n                    q.push(p->right);\n            }\n            res.push_back(tmp);\n        }\n        return res;\n    }\n};\n"
		],
		[
			6.342533928260447,
			5.3187902065225225,
			4,
			22.8,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvoid traverse(TreeNode* node, vector<vector<int>> &result, int level){\n        if(!node) return;\n        if (result.size() < level+1)\n    \t\tresult.push_back(vector<int>());\n        result[level++].push_back(node->val);\n        traverse(node->left, result, level);\n        traverse(node->right, result, level);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        traverse(root, result, 0);\n        return result;\n    }\n};"
		],
		[
			6.284176727964244,
			5.480389553974964,
			6,
			23.7292,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n\tvector<vector<int>> levelOrder(TreeNode* root) {\n\t\tif(root == NULL) return {};\n\n\t\tqueue<TreeNode*> q;\n\t\tvector<vector<int>> a;\n\t\tq.push(root);\n\n\t\tint n;\n\n\t\twhile(!q.empty()){\n\t\t\tTreeNode * t;\n\t\t\tvector<int> temp;\n\t\t\tn = q.size();\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tt = q.front();\n\t\t\t\tq.pop();\n\t\t\t\ttemp.push_back(t->val);\n\t\t\t\tif(t->left) q.push(t->left);\n\t\t\t\tif(t->right) q.push(t->right);\n\t\t\t}\n\t\t\ta.push_back(temp);\n\t\t}\n\n\t\treturn a;\n\t}\n};"
		],
		[
			6.32518589696844,
			5.449169446896675,
			6,
			19.1111,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> rst;\n        if (!root) return rst;\n        \n        queue<TreeNode*> q;\n        queue<TreeNode*> nextq;\n        vector<int> curlevel;\n        \n        q.push(root);\n        while (not q.empty()) {\n            // get the current node\n            TreeNode* cur = q.front();\n            q.pop();\n            // process the node\n            curlevel.push_back(cur->val);\n            if (cur->left) nextq.push(cur->left);\n            if (cur->right) nextq.push(cur->right);\n            // if all nodes in the current level are processed, move to next level\n            if (q.empty()) {\n                rst.push_back(move(curlevel));\n                q.swap(nextq);\n            }\n        }\n        return rst;\n    }\n};\n"
		],
		[
			6.074645408281515,
			5.478674672044354,
			6,
			25.3333,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (!root) return ans;\n        \n        q.push(root);\n        \n        vector<int> curVec;\n        while (!q.empty()) {\n            int sz = q.size();\n            \n            for (auto i = 0; i < sz; ++i) {\n                TreeNode* cur = q.front();\n                q.pop();\n                \n                curVec.push_back(cur->val);\n                \n                if (cur->left) {\n                    q.push(cur->left);\n                }\n                \n                if (cur->right) {\n                    q.push(cur->right);\n                }\n            }\n            \n            ans.push_back(curVec);\n            curVec.clear();\n        }\n        \n        return ans;\n    }\n    \nprivate:\n    queue<TreeNode*> q;\n    vector<vector<int>> ans;\n};\n"
		],
		[
			6.7642966539952445,
			5.375854769838605,
			4,
			16.49,
			"class Solution {\npublic:\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ourRes;\n        insertAtLevel(root, 0);\n        // Go over each level in our map\n        for (const auto& key : ourLevels) {\n        // Push the level into our result vector\n            ourRes.push_back(key.second);\n        }\n     \n        return ourRes;\n    }\nprivate:\n    // Map sorts by key, maintains \n    // our levels in order\n    map<int, vector<int>> ourLevels;\n    \n    void insertAtLevel(TreeNode* root, int level) {\n        if (!root) return;\n        // Visit each node once, add it to our map that\n        // maps nodes to their levels in the tree\n        ourLevels[level].push_back(root->val);\n        insertAtLevel(root->left, level + 1);\n        insertAtLevel(root->right, level + 1);\n        return;\n    }\n    \n\n};"
		],
		[
			6.256971490454013,
			5.4333590560323435,
			7,
			21.9,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root) {\nvector<vector<int>> vec;\nvector<int> temp;\nqueue<TreeNode*> q;\nqueue<TreeNode*> q1;\nif (root != NULL) {\n\tq.push(root);\n\twhile (!q.empty() || !q1.empty()) {\n\t\twhile (!q.empty()) {\n\t\t\tauto n = q.front();\n\t\t\tq.pop();\n\t\t\ttemp.push_back(n->val);\n\t\t\tif (n->left != NULL)\n\t\t\t\tq1.push(n->left);\n\t\t\tif (n->right != NULL)\n\t\t\t\tq1.push(n->right);\n\t\t}\n\t\tvec.push_back(temp);\n\t\ttemp.clear();\n\t\tswap(q1, q);\n\t}\n\n}\nreturn vec;\n}\n};"
		],
		[
			6.318007857080364,
			5.5330126714479775,
			6,
			25.84,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root) {\n\tif (!root)\n\t\treturn {};\n\tvector<vector<int>> res;\n\tqueue< pair<TreeNode*, int> > q; // node, level\n\tq.push( { root, 0 } );\n\twhile (!q.empty()) {\n\t\tauto [node, level] = q.front();\n\t\tq.pop();\n\n\t\tif (res.size() <= level)\n\t\t\tres.push_back({});\n\n\t\tres[level].push_back(node->val);\n\t\tif (node->left)\n\t\t\tq.push( { node->left, level + 1 } );\n\t\tif (node->right)\n\t\t\tq.push( { node->right, level + 1 } );\n\t}\n\treturn res;\n}\n};"
		],
		[
			6.080505317038731,
			5.481525347686969,
			6,
			27.9792,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        if(!root)\n            return res;\n\n        queue<TreeNode* > q;\n        q.push(root);\n        int cnt_prev = 1, cnt_pres = 0;\n        \n        while (!q.empty()){\n            vector<int> level;\n            while(cnt_prev > 0){\n                TreeNode* cur = q.front();\n                level.push_back(cur->val);\n                q.pop();\n                cnt_prev--;\n                \n                if (cur->left){\n                    q.push(cur->left);\n                    cnt_pres++;\n                }\n                if(cur->right){\n                    q.push(cur->right);\n                    cnt_pres++;\n                }\n                \n            }\n            cnt_prev = cnt_pres;\n            cnt_pres = 0;\n            res.push_back(level);\n            \n        }\n        return res;\n            \n    }\n};\n"
		],
		[
			6.324695011847805,
			5.42827680482833,
			6,
			23.375,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (!root) { return {}; }\n        vector<int> row;\n        vector<vector<int> > result;\n        queue<TreeNode*> q;\n        q.push(root);\n        int count = 1;\n\n            while (!q.empty()) {\n            if (q.front()->left) { q.push(q.front()->left); }\n            if (q.front()->right) { q.push(q.front()->right); }\n            row.push_back(q.front()->val), q.pop();\n            if (--count == 0) {\n                result.emplace_back(row), row.clear();\n                count = q.size();\n            }\n        }\n        return result;\n    }\n};"
		],
		[
			6.201279289022329,
			5.483377423393181,
			6,
			23.3043,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if(!root) return vector<vector<int>>();\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        q.push(root);\n        int i;\n        while(!q.empty()) {\n            vector<int> curLevel;\n            int b = q.size();\n            for( i = 0; i < b; i++) {\n                TreeNode* cur = q.front();\n                q.pop();\n                curLevel.push_back(cur->val);\n                if(cur->left) q.push(cur->left);\n                if(cur->right) q.push(cur->right);\n            }\n            res.push_back(curLevel);\n        }\n        return res;\n    }\n};\n"
		],
		[
			6.323752978648704,
			5.479671057916405,
			6,
			22.08,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n\tvector<vector<int>> levelOrder(TreeNode* root) {\n\t\tqueue<TreeNode*> q;\n\t\tvector<vector<int>> output;\n\t\tif(root==NULL) return output;\n\t\tq.push(root);\n\t\twhile(q.empty()==false){\n\t\t\tint nodeCount = q.size();\n\t\t\tvector<int> v;\n\t\t\twhile(nodeCount>0){\n\t\t\t\tTreeNode* temp = q.front();\n\t\t\t\tv.push_back(temp->val);\n\t\t\t\tq.pop();\n\t\t\t\tif(temp->left!=NULL){\n\t\t\t\t\tq.push(temp->left);\n\t\t\t\t}\n\t\t\t\tif(temp->right!=NULL){\n\t\t\t\t\tq.push(temp->right);\n\t\t\t\t}\n\t\t\t\tnodeCount--;\n\t\t\t}\n\t\t\toutput.push_back(v);\n\t\t\tv.clear();\n\t\t}\n\t\treturn output;\n\t}\n};"
		],
		[
			5.979791941202037,
			5.378731849082835,
			4,
			22.2222,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> ans;\n    \n    vector<vector<int>> levelOrder(TreeNode* root) {\n        dfs(root, 0);\n        return ans;\n    }\n\n    void dfs(TreeNode* root, int depth) {\n        if(!root)\n            return;\n        if(ans.size() == depth)\n            ans.emplace_back(vector<int>());\n        ans[depth].emplace_back(root->val);\n        dfs(root->left, depth + 1);\n        dfs(root->right, depth + 1);\n    }\n};\n"
		],
		[
			5.802689119586971,
			5.424261147298025,
			6,
			21.76,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if(!root) return ans;\n        queue<TreeNode*> q;\n        vector<int> v;\n        q.push(root);\n        while(!q.empty()) {\n            int m = q.size();\n            TreeNode* tmp;\n            for(int i = 0; i < m; ++i) {\n                tmp = q.front();\n                q.pop();\n                v.emplace_back(tmp->val);\n                if(tmp->left) q.push(tmp->left);\n                if(tmp->right) q.push(tmp->right);\n            }\n            ans.emplace_back(v);\n            v.clear();\n        }\n        return ans;\n    }\n};\n"
		],
		[
			6.16998254358001,
			5.4283072526856,
			7,
			27.75,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root) {\n    queue<TreeNode*> que;\n    vector<vector<int>> result;\n    vector<int> tmp;\n    if(!root) return result;\n    TreeNode* nullPointer=NULL;\n    que.push(root);\n    que.push(nullPointer);\n    while(!que.empty()){\n        auto ptr=que.front();\n        que.pop();\n        if(ptr==NULL){\n            result.push_back(tmp);\n            tmp.clear();\n            if(!que.empty()){\n               que.push(nullPointer);\n               continue;\n            }\n            else\n                  break;\n        }\n        else\n          tmp.push_back(ptr->val);\n        if(ptr->left)\n           que.push(ptr->left);\n        if(ptr->right)\n           que.push(ptr->right);\n    }\n    return result;\n    \n}\n};"
		],
		[
			6.429140128448907,
			5.436099611809361,
			6,
			24.2045,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n       vector<vector<int>> res;\n\t   if(!root) return res;\n\t   queue<TreeNode*> cur;\n\t   queue<TreeNode*> next;\n\t   cur.push(root);\n\t   vector<int> items;\n\t   while(!cur.empty())\n\t   {\n\t\t   //\u904d\u5386\u4e00\u5c42\n\t\t   items.clear();\n\t\t   queue<TreeNode*>().swap(next);\n\t\t   while(!cur.empty())\n\t\t   {\n\t\t\t   TreeNode *tmp = cur.front();\n\t\t\t   cur.pop();\n\t\t\t   items.push_back(tmp->val);\n\t\t\t   if(tmp->left)  next.push(tmp->left);\n\t\t\t   if(tmp->right) next.push(tmp->right);\n\t\t   }\n\t\t   res.push_back(items);\n\t\t   //\u8fed\u4ee3\n\t\t   cur.swap(next);\n\t   }\n\t  \n\n\t   return res;\n\n    }\n\t\n};\n"
		],
		[
			6.554020719021888,
			5.4330248591449,
			6,
			25.3636,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (!root) {\n            return {};\n        }\n        vector<vector<int>> levels;\n        queue<TreeNode*> todo;\n        todo.push(root);\n        while (!todo.empty()) {\n            levels.push_back({});\n            for (int i = 0, n = todo.size(); i < n; i++) {\n                TreeNode* node = todo.front();\n                todo.pop();\n                levels.back().push_back(node -> val);\n                if (node -> left) {\n                    todo.push(node -> left);\n                }\n                if (node -> right) {\n                    todo.push(node -> right);\n                }\n            }\n        }\n        return levels;\n    }\n};\n"
		],
		[
			6.067178268614716,
			5.319816146540661,
			5,
			27.2,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int>> result;\n    if (!root) return result;\n    Helper(root, result, 0);\n    return result;\n}\nvoid Helper(TreeNode* root, vector<vector<int>> &result, int h){\n    if (!root) return;\n\n    if (result.size()<h+1){\n        vector<int> tmp;\n        tmp.push_back(root->val);\n        result.push_back(tmp);\n    }else{\n        result[h].push_back(root->val);\n    }\n    Helper(root->left, result, h+1);\n    Helper(root->right, result, h+1);\n}\n};"
		],
		[
			6.483517060792954,
			5.526483676897708,
			6,
			22.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n   vector<vector<int>> ans;\n    queue<TreeNode*> q1;\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n        if(!root) return ans;\n         int k;\n         auto p=root;\n         q1.push(p);\n         TreeNode* t;\n        \n        while(q1.size())\n        {   \n            k=q1.size();vector<int> ca;\n            while(k--)\n            {\n                 t=q1.front();q1.pop();\n                 if(t->left)  q1.push(t->left);\n                 if(t->right) q1.push(t->right);\n                 ca.push_back(t->val); \n                           \n            }\n            ans.push_back(ca);\n            }\n            return ans;       \n        }\n};"
		],
		[
			6.474591527543928,
			5.426985327478849,
			6,
			21.44,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int>> ans;\n    if(!root)\n        return ans;\n    queue<TreeNode*> q;\n    q.push(root);\n\n    vector<int> tmp;\n    while(!q.empty()){\n        int len = q.size();\n        for(int i=0;i<len;i++){\n            auto x = q.front();\n            q.pop();\n            tmp.push_back(x->val);\n            if(x->left)\n                q.push(x->left);\n            if(x->right)\n                q.push(x->right);\n        }\n\n        ans.push_back(tmp);\n        tmp.clear();\n    }\n    return ans;\n    }\n};\n"
		],
		[
			5.873654739758155,
			5.480052644925086,
			6,
			23.3043,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        queue<TreeNode*> q;\n        \n        if (!root)\n            return res;\n        \n        q.push(root);\n        \n        while (!q.empty()) {\n            auto size = q.size();\n            vector<int> v;\n            \n            for (auto i = 0; i < size; i++) {\n                TreeNode *t = q.front();\n                \n                q.pop();\n                v.push_back(t->val);\n                \n                if (t->left)\n                    q.push(t->left);\n                if (t->right)\n                    q.push(t->right);\n            }\n            res.push_back(v);\n        }\n        return res;\n    }\n};\n"
		],
		[
			6.271610630633293,
			5.433737006035116,
			6,
			27.36,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root) {\n    vector<vector<int>> ret;\n    deque<TreeNode*> q;\n    \n    if (root)   q.push_front(root);        \n    while (q.size()) {\n        ret.resize(ret.size() + 1);\n        int og_size = q.size(); \n            \n        for (int i = 0, og_size = q.size(); i != og_size; i++)  {\n            auto node = q.front();\n            ret.back().push_back(node->val);\n    \n            if (node->left)     q.push_back(node->left);\n            if (node->right)    q.push_back(node->right);   \n            q.pop_front();\n        }\n    }\n    return ret;\n}\n};"
		],
		[
			6.237478223321883,
			5.434614956569907,
			7,
			29.75,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>>res;\n        if(!root) return res;\n        deque<TreeNode*>cur;\n        deque<TreeNode*>next;\n        cur.push_back(root);\n        int level = 0;\n        res.push_back(vector<int>());\n        while(!cur.empty()){\n            TreeNode* node = cur.front();\n            cur.pop_front();\n            if(node->left) next.push_back(node->left);\n            if(node->right) next.push_back(node->right);\n            res[level].push_back(node->val);\n            if(cur.empty() && !next.empty()){\n                res.push_back(vector<int>());\n                level++;\n                swap(cur, next);\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			6.200338869035981,
			5.32240945953586,
			4,
			24.8889,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>>res;\n        DFS(res, root, 0);\n        return res;\n    }\n    \n    void DFS(vector<vector<int>>& res, TreeNode* root, int level){\n        if(!root) return;\n        if(level == res.size()) res.push_back(vector<int>());\n        res[level].push_back(root->val);\n        DFS(res, root->left, level + 1);\n        DFS(res, root->right, level + 1);\n    }\n};\n"
		],
		[
			6.085636080943646,
			5.316696235134031,
			4,
			25.4167,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\nvector<vector<int>> levelOrder(TreeNode* root)\n{\n\tvector<vector<int>> result;\n\trecur_levelOrder(result, root, 0);\n\treturn result;\n}\n\nvoid recur_levelOrder(vector<vector<int>> &result, TreeNode *root, int level)\n{\n\tif (!root)\n\t{\n    \treturn;\n    }\n    if ((level+1) > result.size())\n    {\n\t    result.push_back(vector<int> {});\n    }\n    result[level].push_back(root->val);\n    recur_levelOrder(result, root->left, level+1);\n    recur_levelOrder(result, root->right, level+1);\n}\n};"
		],
		[
			6.0527335028704305,
			5.3309629809904315,
			5,
			31.8182,
			"class Solution {\n    public:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n        vector<vector<int>> levelOrder(TreeNode* root) {\n            vector<vector <int>> res;\n            if(root==NULL) return res;\n            helper(root, res, 0);\n            return res;\n        }\n        \n    private:\n        int rows = 0;\n        void helper(TreeNode* node, vector<vector<int>> &res, int count){\n            if(node == NULL) return;\n            if(count >= rows){\n                vector<int> newRow;\n                newRow.push_back(node->val);\n                res.push_back(newRow);\n                rows++;\n            }\n            else{\n                res[count].push_back(node->val);\n            }\n            helper(node->left, res, count + 1);\n            helper(node->right, res, count + 1);\n            return; \n        }\n    };"
		],
		[
			6.393627589543439,
			5.475989240593737,
			6,
			20.9375,
			"class Solution {\npublic:\n    #include<vector>\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> levelOrder(TreeNode* root)\n{\n\tvector<vector<int>> ret;\n\tint qsize = 0;\n\tif (!root) return ret;\n\tqueue<TreeNode*> q;\n\tq.push(root);\n\twhile (!q.empty())\n\t{\n\t\tvector<int> subret;\n\t\tqsize = q.size();\n\t\twhile (qsize--)\n\t\t{\n\t\t\tTreeNode* tmp = q.front();\n\t\t\tq.pop();\n\t\t\tsubret.push_back(tmp->val);\n\t\t\tif (tmp->left != NULL) q.push(tmp->left);\n\t\t\tif (tmp->right != NULL) q.push(tmp->right);\n\t\t}\n\t\tret.push_back(subret);\n}\nreturn ret;\n}\n};"
		],
		[
			6.65773468691384,
			5.474631651799727,
			8,
			25.6667,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if(root == NULL){\n            return ans;\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        q.push(NULL);\n        while(!q.empty()){\n            vector<int> vec;\n            bool flag = false;\n            while(true){\n                TreeNode* tmp = q.front();\n                q.pop();\n                if(tmp == NULL){\n                    break;\n                }\n                vec.push_back(tmp->val);\n                if(tmp->left != NULL){\n                    q.push(tmp->left);\n                    flag = true;\n                }\n                if(tmp->right != NULL){\n                    q.push(tmp->right);\n                    flag = true;\n                }\n            }\n            ans.push_back(vec);\n            if(flag){\n                q.push(NULL);\n            }\n        }\n        return ans;\n    }\n};"
		],
		[
			6.320990688254545,
			5.372446928577603,
			6,
			25.7778,
			"class Solution {\npublic:\nclass TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nvector<vector<int>> abc;\nvoid helper(TreeNode* root, int level) {\n    if(abc.size() < level+1) abc.push_back(vector<int>(1,root->val));\n    else abc[level].push_back(root->val);\n    if(root->left) helper(root->left,level+1);\n    if(root->right) helper(root->right,level+1);\n}\nvector<vector<int>> levelOrder(TreeNode* root) {\n    if(root) helper(root,0);\n    return abc;   \n}\n};"
		],
		[
			6.333952272190731,
			5.4196794641472135,
			8,
			31.0435,
			"class Solution {\npublic:\n\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\nvoid bfs(TreeNode*root , vector<int>&v,vector<vector<int>>&qwer){\nqueue<TreeNode*>q;\nif(root==NULL){\nreturn;}\n\nq.push(root);\nq.push(NULL);\n\nwhile(!q.empty()){\nTreeNode*f=q.front();\n\nif(f==NULL){\nqwer.push_back(v);\n    v.clear();\nq.pop();\nif(!q.empty()){\nq.push(NULL);}}\n\nelse{\nv.push_back(f->val);\nq.pop();\n if(f->left){\nq.push(f->left);}\nif(f->right){\nq.push(f->right);}}}\n    return ;}\n\t\n\t\n\tvector<vector<int>> levelOrder(TreeNode* root) {\n     vector<vector<int>>qwer;\n    vector<int>v;\n    bfs(root,v,qwer);\n     return qwer;}\n};\n"
		],
		[
			6.1552945763902045,
			5.4816100005418535,
			6,
			23.6522,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ret;\n        TreeNode *temp = NULL;\n        int curLevelCount = 0;\n        if (root == NULL) return ret;\n        \n        queue<TreeNode *>q;\n        q.push(root);\n        \n        while (!q.empty())\n        {\n            curLevelCount = q.size();\n            vector<int> level;\n            while (curLevelCount--)\n            {\n                temp = q.front();\n                level.push_back(temp->val);\n                if (temp->left != NULL)\n                    q.push(temp->left);\n                if (temp->right != NULL)\n                    q.push(temp->right);\n                q.pop();\n            }\n            ret.push_back(level);\n        }\n        \n        return ret;\n    }\n};"
		],
		[
			6.475824771062555,
			5.318322277460225,
			5,
			24.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        if (!root) {\n            return {};\n        }\n        vector<vector<int>> levels;\n        level(root, 0, levels);\n        return levels;\n    }\nprivate:\n    void level(TreeNode* root, int l, vector<vector<int>>& levels) {\n        if (!root) {\n            return;\n        }\n        if (levels.size() <= l) {\n            levels.push_back({});\n        }\n        levels[l].push_back(root -> val);\n        level(root -> left, l + 1, levels);\n        level(root -> right, l + 1, levels);\n    }\n};\n"
		],
		[
			6.664230569521407,
			5.4253630141527855,
			7,
			25.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int> > levelOrder(TreeNode *root) {\n        vector<vector<int> >  result;\n        if (!root) return result;\n        queue<TreeNode*> q;\n        q.push(root);\n        q.push(NULL);\n        vector<int> cur_vec;\n        while(!q.empty()) {\n            TreeNode* t = q.front();\n            q.pop();\n            if (t==NULL) {\n                result.push_back(cur_vec);\n                cur_vec.resize(0);\n                if (q.size() > 0) {\n                    q.push(NULL);\n                }\n            } else {\n                cur_vec.push_back(t->val);\n                if (t->left) q.push(t->left);\n                if (t->right) q.push(t->right);\n            }\n        }\n        return result;\n    }\n};"
		],
		[
			6.850385959452905,
			5.568704906527016,
			7,
			25.3571,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> v;\n        queue<TreeNode*> q;\n        if(root == NULL)\n            return v;\n        q.push(root);\n        \n        while(!q.empty()) {\n            vector<int> vtemp;\n            queue<TreeNode*> qtemp;\n            while(!q.empty()) {\n                TreeNode* temp = q.front();\n                q.pop();\n                vtemp.push_back(temp->val);\n                if(temp->left) qtemp.push(temp->left);\n                if(temp->right) qtemp.push(temp->right);\n            }\n            v.push_back(vtemp);\n            \n            while(!qtemp.empty()) {\n                q.push(qtemp.front());\n                qtemp.pop();\n            }\n        }\n        \n        return v;\n    }\n};\n"
		],
		[
			6.628293997141838,
			5.425351471133614,
			6,
			25.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> levels;\n        if(root==NULL){\n            return levels;\n        }\n        vector<int> level;\n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while(!q.empty()) {\n            int curr_size= q.size();\n            for(int i=0; i< curr_size; ++i){\n                TreeNode* front = q.front();\n                q.pop();\n                level.push_back(front->val);\n                if(front->left!=NULL) q.push(front->left);\n                if(front->right!=NULL) q.push(front->right);\n            }\n            levels.push_back(level);\n            level.clear();\n        }\n        return levels;\n    }\n};\n"
		],
		[
			6.456180877901928,
			5.475049923942804,
			6,
			22.6087,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if(!root)return ans;\n        queue<TreeNode* > q;\n        q.push(root);\n        while(!q.empty()){\n            vector<int> level;\n            int N = q.size();\n            for(int i=0;i<N;i++){\n                TreeNode* top = q.front();\n                if(top->left){\n                    q.push(top->left);\n                }\n                if(top->right){\n                    q.push(top->right);\n                }\n                level.push_back(top->val);\n                q.pop();\n            }\n            ans.push_back(level);\n        }\n        return ans;\n    }\n};\n"
		]
	],
	"HEIGHT_BT": [
		"n",
		[
			5.750080585331192,
			5.183377074635478,
			2,
			27.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    #include<algorithm>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root==NULL){\n            return 0;\n        }\n        return 1+max(maxDepth(root->left),maxDepth(root->right));\n    }\n};\n"
		],
		[
			5.851138077237507,
			5.183377074635478,
			2,
			23.1429,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        int ldepth = maxDepth(root->left); //finds leftsubtree depth\n        int rdepth = maxDepth(root->right); //finds right subtree depth\n        return 1+max(rdepth,ldepth); // 1 is for root and maximum of left and right depth\n    }\n};\n"
		],
		[
			6.520802247396307,
			5.319780228132397,
			6,
			19.6364,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root == NULL) return 0;\n        int rez=0;\n        queue <TreeNode *> q;\n        q.push(root);\n        \n        while(!q.empty()){\n          int i = q.size();                // put in i  number of nodes  on current row\n        \n          for(int j=0 ; j < i; j++){                //put in queue nodes for next row\n            \n              TreeNode *tmp = q.front();\n              q.pop();\n              if(tmp->left) q.push(tmp->left); \n              if(tmp->right) q.push(tmp->right);     \n            \n          }\n        rez++;   // increase counter of rows\n        }\n    return rez;    \n    }\n};\n"
		],
		[
			5.826655652530043,
			5.183377074635478,
			2,
			11.0,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(!root)return 0;\n        return max(maxDepth(root->left),maxDepth(root->right))+1;\n    }\n};\n"
		],
		[
			6.233225997018664,
			5.183377074635478,
			2,
			14.0,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode *root) {\n    int leftHeight, rightHeight;\n\n    if (!root)\n        return 0;\n\n    leftHeight = maxDepth(root->left);\n    rightHeight = maxDepth(root->right);\n\n    return max(leftHeight, rightHeight) + 1;\n}\n};"
		],
		[
			6.199830652643825,
			5.183377074635478,
			2,
			12.5667,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root==NULL) return 0;\n        int l=maxDepth(root->left);\n        int r=maxDepth(root->right);\n        int h=max(l,r)+1;\n        return h;\n    }\n};\n"
		],
		[
			6.146968349452107,
			5.183377074635478,
			2,
			11.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root==NULL) return 0;\n        return max(maxDepth(root->left),maxDepth(root->right))+1;\n    }\n};\n"
		],
		[
			5.863559380178401,
			5.183377074635478,
			5,
			19.9062,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void solve(TreeNode* root,int ma,int &ans)\n    {\n        if(root==NULL)\n            return;\n        ans=max(ma,ans);\n        if(root->left)\n            solve(root->left,ma+1,ans);\n        if(root->right)\n            solve(root->right,ma+1,ans);\n    }\n    int maxDepth(TreeNode* root) {\n        int ma=1;\n        int ans=0;\n        solve(root,ma,ans);\n        return ans;\n    }\n};\n"
		],
		[
			6.290675461837981,
			5.183377074635478,
			2,
			12.6562,
			"// DFS Recursive\nclass Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nint maxDepth(TreeNode* root) {\n        if(root==NULL)\n            return 0;\n        return 1 + max(maxDepth(root->left),maxDepth(root->right));\n    }\n};"
		],
		[
			6.191135812400539,
			5.183377074635478,
			2,
			12.5,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\nif (root == NULL)\n        return 0;\n    \n return max(maxDepth(root->left), maxDepth(root->right)) + 1;        \n}\n};"
		],
		[
			5.921803918631008,
			5.183377074635478,
			3,
			14.5,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root==NULL)\n            return 0;\n        int l = maxDepth(root->left);\n        int r = maxDepth(root->right);\n        return(l>r?(l+1):(r+1));\n    }\n};"
		],
		[
			5.950157891858168,
			5.183377074635478,
			2,
			11.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    int maxDepth(TreeNode* root) {\n        if(! root) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n"
		],
		[
			6.155498505396949,
			5.183377074635478,
			7,
			21.0,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        // root is null\n        if (root == NULL)\n            return 0;\n        \n        // root is a leaf node\n        if ((root!=NULL) && (root->left==NULL) && (root->right==NULL))\n            return 1;\n        \n        // root has only right subtree\n        if (root->left==NULL)\n            return maxDepth(root->right) + 1;\n        \n        // root has only left subtree\n        if (root->right==NULL)\n            return maxDepth(root->left) + 1;\n        \n        // Return max depth of left and right subtree\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};"
		],
		[
			6.045621309777617,
			5.183377074635478,
			2,
			11.5,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root==NULL) return 0;\n        return 1+max(maxDepth(root->left),maxDepth(root->right));\n    }\n};\n"
		],
		[
			5.942397140257426,
			5.183377074635478,
			2,
			26.4,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root, int d=0) {\n        return root==NULL ? d : max(maxDepth(root->left,d+1), maxDepth(root->right,d+1));\n    }\n};\n"
		],
		[
			6.249912775461929,
			5.183377074635478,
			2,
			11.5,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(1+maxDepth(root->left),1+maxDepth(root->right));\n    }\n};\n"
		],
		[
			6.1853779350188605,
			5.183377074635478,
			6,
			19.5,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void magic(TreeNode* node,int cd,int &md)\n    {\n        if(cd>md)\n            md=cd;\n        if(node->left)\n            magic(node->left,cd+1,md);\n        if(node->right)\n            magic(node->right,cd+1,md);\n    }\n    int maxDepth(TreeNode* root) {\n        if(root==NULL)\n            return 0;\n        int maxdepth=1;\n        int currentdepth=1;\n        magic(root,currentdepth,maxdepth);\n        return maxdepth;\n    }\n};"
		],
		[
			5.973655133950177,
			5.318501781483108,
			6,
			22.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n\t\tif(!root)    // Return depth as '0' if the root is NULL.\n\t\t\treturn 0;\n        queue<TreeNode *> q;    // Queue for BFS\n        int ans = 0, s;\n        TreeNode * temp;\n        q.push(root);\n        while(!q.empty()) {\n            ans++;    // Increment depth at every level.\n            s = q.size();    // 's' is the size of the current level. We will process these many nodes.\n            for(int i = 0; i < s; i++) {\n                temp = q.front();\n                q.pop();\n\t\t\t\t// Only add non-NULL nodes into the queue.\n                if(temp->left)  q.push(temp->left);\n                if(temp->right) q.push(temp->right);\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			5.998285363023883,
			5.183377074635478,
			3,
			14.7692,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tint dfs(TreeNode* root){\n\t\tif(not root) return 0;\n\t\tint left=dfs(root->left);\n\t\tint right=dfs(root->right);\n\t\treturn max(left,right)+1;\n\t}\n\tint maxDepth(TreeNode* root) {\n\t\treturn dfs(root);\n\t}\n};"
		],
		[
			6.30674921953972,
			5.183377074635478,
			2,
			11.5,
			"class Solution\n{\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode *root)\n    {\n        if (root == NULL) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n"
		],
		[
			6.585902703290042,
			5.183377074635478,
			11,
			59.2941,
			"\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        int maxDepth=0;\n        stack<TreeNode *> nodes;\n        TreeNode* ptr;\n        if(root)\n        {\n            root->val=1;\n            nodes.push(root);\n            while(!nodes.empty())\n            {\n                ptr=nodes.top();\n                if(ptr->left && ptr->right)\n                {\n                    if(ptr->val==-1)\n                    {\n                        nodes.pop();\n                        nodes.push(ptr->right);\n                    }\n                    else\n                    {\n                        ptr->left->val=ptr->val+1;\n                        ptr->right->val=ptr->val+1;\n                        ptr->val=-1;\n                        nodes.push(ptr->left);\n                    }\n                }\n                else if(ptr->left)\n                {\n                    if(ptr->val==-1)\n                    {\n                        nodes.pop();\n                    }\n                    else\n                    {\n                        ptr->left->val=ptr->val+1;\n                        nodes.push(ptr->left);\n                        ptr->val=-1;\n                    }\n                }\n                else if(ptr->right)\n                {\n                    if(ptr->val==-1)\n                    {\n                        nodes.pop();\n                    }\n                    else\n                    {\n                        ptr->right->val=ptr->val+1;\n                        nodes.push(ptr->right);\n                        ptr->val=-1;\n                    }\n                }\n                else\n                {\n                    if(ptr->val>maxDepth)\n                    {\n                        maxDepth=ptr->val;\n                    }\n                    nodes.pop();\n                }\n            }\n        }\n        return maxDepth;\n    }\n};\n"
		],
		[
			6.2735271244197515,
			5.183377074635478,
			6,
			19.0909,
			"class Solution {\n\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        maxd = INT_MIN;\n        dfs(root, 1);\n        return maxd;\n    }\n    private:\n    int maxd;\n    void dfs(TreeNode* root, int d) {\n        if (!root->left and !root->right) {\n            // leaf node\n            maxd = max(maxd, d);\n        }\n        else {\n            // non-leaf node\n            if (root->left) {\n                dfs(root->left, d+1);\n            }\n            if (root->right) {\n                dfs(root->right, d+1);\n            }\n        }\n    }\n};\n"
		],
		[
			6.44498436850341,
			5.318289567342622,
			6,
			23.5435,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    \n    // BFS Iterative\n    int maxDepth(TreeNode* root) {\n        if(root==NULL)\n            return 0;\n        int res = 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            ++res;\n            for(int i=0,n=q.size();i<n;i++){\n                TreeNode* p = q.front();\n                q.pop();\n                \n                if(p->left!=NULL)\n                    q.push(p->left);\n                if(p->right!=NULL)\n                    q.push(p->right);\n            }\n        }\n        return res;\n    }\n};\n\n\n\n"
		],
		[
			6.633458930110185,
			5.183377074635478,
			5,
			26.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        \n        TreeNode* cur = root;\n        \n        int curDepth = 0, maxDepth = 0;\n        while (cur || !s.empty()) {\n            if (cur) {\n                s.push(make_pair(cur, ++curDepth));\n                curDepth = s.top().second;\n                \n                cur = cur->left;\n            }\n            else {\n                cur = s.top().first->right;\n                curDepth = s.top().second;\n                \n                s.pop();\n            }\n            \n            maxDepth = max(maxDepth, curDepth);\n        }\n        \n        return maxDepth;\n    }\n\nprivate:\n    stack<pair<TreeNode*, int>> s;\n};\n"
		],
		[
			6.180977144664272,
			5.183377074635478,
			2,
			12.0,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };    \n    int maxDepth(TreeNode* root) {\n        return !root ? 0 : max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n\t// We go as deep as possible, into the call stack. When no root exists we unwind\n\t// keeping track of the max height between the left and right subtrees.\n\t// For every level we unwind we add 1 to signify 1 level.\n};"
		],
		[
			6.045361212115924,
			5.183377074635478,
			4,
			21.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int count = 0, maxi = 0;\n    int dep(TreeNode* root) {\n        count++;\n        if (root==NULL) {\n            maxi = max(maxi, count);\n            return 0;\n        }\n        dep(root->left);\n        count--;\n        dep(root->right);\n        count--;\n        \n        return maxi-1;\n    }\n    \n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        return dep(root);\n    }\n};\n"
		],
		[
			5.90160732993032,
			5.183377074635478,
			4,
			13.8462,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int dep(TreeNode* root) {\n\t\t if (!root) return 0;\n\t\t return max(dep(root->left), dep(root->right))+1;\n    }\n    \n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        return dep(root);\n    }\n};\n"
		],
		[
			6.336984876911682,
			5.183377074635478,
			3,
			23.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        \n        int iL = maxDepth(root->left);\n        int iR = maxDepth(root->right);\n        \n        if (iL > iR){\n            return ++iL;\n        }\n        return ++iR;\n    }\n};\n"
		],
		[
			6.047206492234082,
			5.183377074635478,
			2,
			11.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left) + 1, maxDepth(root->right) + 1);\n    }\n};\n"
		],
		[
			6.369490386105814,
			5.319373228269632,
			6,
			20.8,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        int depth = 0;\n        while(!q.empty()) {\n            int s = q.size();\n            for(int i = 0; i < s; ++i) {\n                TreeNode* t = q.front();\n                q.pop();\n                if(t->left) q.push(t->left);\n                if(t->right) q.push(t->right);\n            }\n            depth++;\n        }\n        return depth;\n    }\n};\n"
		],
		[
			6.155352168657157,
			5.183377074635478,
			2,
			12.0,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};"
		],
		[
			5.952054535271077,
			5.183377074635478,
			2,
			12.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n       if(root==NULL)\n           return 0;\n       return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\n    }\n};"
		],
		[
			6.081303939581992,
			5.183377074635478,
			4,
			15.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int max(int a, int b)\n    {\n        return a>b?a:b;\n    }\n    \n    int maxDepth(TreeNode* root) {\n       // base case\n       if(root == NULL)\n            return 0;\n            \n        return 1+ max(maxDepth(root->left), maxDepth(root->right));    \n    }\n};"
		],
		[
			5.830953519676218,
			5.183377074635478,
			2,
			10.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) \n{    \n\treturn root ? 1+max(maxDepth(root->left), maxDepth(root->right)) : 0;\n}\n\n};\n"
		],
		[
			6.118843838691994,
			5.183377074635478,
			2,
			19.2857,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic: \n#include <algorithm>\n \n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) {\n\t\t    return 0;\n\t    }\n\n\t    return (1 + std::max(maxDepth(root->left), maxDepth(root->right)));\n    }\n};"
		],
		[
			7.841058729862712,
			5.183377074635478,
			3,
			16.5455,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nint maxDepth(TreeNode* root) \n{\n\n     if(root==NULL)\n        return 0;\n    else\n        return maxDepth(root->left)>maxDepth(root->right)? maxDepth(root->left):maxDepth(root->right)+1;\n}\n};"
		],
		[
			6.013932525366604,
			5.183377074635478,
			7,
			22.5333,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(root == NULL)\n        return 0;\n        return dfs(root);\n    }\n    int dfs(TreeNode* root)\n    {\n        if(root->left == NULL && root->right == NULL)\n        return 1;\n        int left = INT_MIN, right = INT_MIN;\n        if(root->left != NULL)\n        left = dfs(root->left) + 1;\n        if(root->right != NULL)\n        right = dfs(root->right) + 1;\n        return max(left, right);\n    }\n};"
		],
		[
			5.652733254487033,
			5.183377074635478,
			3,
			20.4615,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };int maxDepth(TreeNode* root) {\n    int num = 0;\n    if(root){  \n        num = 1; \n        int left = 0;\n        int right = 0;\n        left = maxDepth(root->left);  \n        right = maxDepth(root->right);  \n        if(left > right)\n            num += left;\n        else\n            num += right;\n    }\n    return num;\n}\n};"
		],
		[
			5.891690884036935,
			5.183377074635478,
			2,
			15.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n    \tif(root == NULL)return 0;\n        int len_left = maxDepth(root->left);\n        int len_right = maxDepth(root->right);\n        return max(len_left, len_right) + 1;\n    }\n};\n"
		],
		[
			5.765664200144333,
			5.183377074635478,
			3,
			17.7692,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        int ltree = 0, rtree = 0;\n        \n        if (root == NULL) return 0;\n        ltree = maxDepth(root->left);\n        rtree = maxDepth(root->right);\n        if (ltree < rtree) \n            ltree = rtree;;\n            \n        return ltree + 1;\n    }\n};\n"
		],
		[
			6.313981266542096,
			5.318571161868601,
			7,
			26.55,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        int depth = 0, preLevelNodes = 0;\n        queue<TreeNode *> q;\n        TreeNode *temp = NULL;\n        \n        if (root == NULL) return depth;\n        \n        q.push(root);\n        ++depth, ++preLevelNodes;\n        \n        while (!q.empty())\n        {\n            preLevelNodes = q.size();\n            while (preLevelNodes--)\n            {\n                temp = q.front();\n            \n                if (temp->left != NULL) \n                    q.push(temp->left);\n                if (temp->right != NULL) \n                    q.push(temp->right);\n                q.pop();\n            }\n            if (!q.empty())\n                ++depth;\n        }\n        \n        return depth;\n    }\n};"
		],
		[
			6.36907401364957,
			5.3186576625770146,
			9,
			29.2857,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nint maxDepth(TreeNode* root) {\n    //return solution1(root);   //DFS\n    return solution2(root);     //BFS\n}\nprivate:\nint solution1(TreeNode* root) {\n    if(root == NULL) return 0;\n    return 1 + max(solution1(root->left), solution1(root->right));\n}\nint solution2(TreeNode *root){\n    if(root == NULL) return 0;\n    queue<TreeNode *> que;\n    que.push(root);\n    int depth = 0, count;\n    TreeNode *left, *right;\n    while(que.empty() == false){\n        depth++;\n        count = que.size();\n        for(int i = 0; i < count; i++){\n            left = que.front()->left;\n            if(left) que.push(left);\n            right = que.front()->right;\n            if(right) que.push(right);\n            que.pop();\n        }\n    }\n    return depth;\n}\n};"
		],
		[
			5.840258236539253,
			5.183377074635478,
			2,
			11.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if( !root )\n            return 0;\n\n        return 1 + max( maxDepth( root->left ), maxDepth( root->right ) );\n    }\n};"
		],
		[
			5.939437494655034,
			5.183377074635478,
			2,
			10.0,
			"class Solution { \npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        return root ? 1 + max(maxDepth(root -> left), maxDepth(root -> right)) : 0;\n    }\n};\n"
		],
		[
			5.898628460080463,
			5.183377074635478,
			3,
			12.1,
			"class Solution {\n\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        return q(root, 0);\n    }\nprivate:\n    static int q(TreeNode* node, int depth) {\n        if (!node) return depth;\n        ++depth;\n        return max(q(node->left, depth), q(node->right, depth));\n    }\n};\n"
		],
		[
			6.223575212879342,
			5.319518931374823,
			6,
			20.8,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        int depth = 0;\n        if (!root) return depth;\n        queue<TreeNode*> level;\n        level.push(root);\n        while (!level.empty()) {\n            depth++;\n            int n = level.size();\n            for (int i = 0; i < n; i++) {\n                TreeNode* node = level.front();\n                level.pop();\n                if (node -> left) level.push(node -> left);\n                if (node -> right) level.push(node -> right);\n            }\n        }\n        return depth; \n    } \n};"
		],
		[
			5.894684750850348,
			5.183377074635478,
			2,
			11.5,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if(!root) return 0;\n        return max(maxDepth(root->left) + 1, maxDepth(root->right) + 1);\n    }\n};"
		],
		[
			5.869648682923978,
			5.183377074635478,
			2,
			10.0,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        return root ? 1 + max(maxDepth(root->left), maxDepth(root->right)) : 0;\n    }\n};"
		],
		[
			5.805689998003873,
			5.183377074635478,
			7,
			28.6316,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return false;\n        }\n        int ret = 0;\n        int depth = 0;\n        auto cur = root;\n        while (cur) {\n            if (!cur->left) {\n                cur = cur->right;\n                ++depth;\n            }\n            else {\n                auto prev = cur->left;\n                int dist = 1;\n                while (prev->right && prev->right != cur) {\n                    prev = prev->right;\n                    ++dist;\n                }\n                if (prev->right) {\n                    prev->right = nullptr;\n                    cur = cur->right;\n                    ret = max(ret, depth);\n                    depth -= dist;\n                }\n                else {\n                    prev->right = cur;\n                    cur = cur->left;\n                    ++depth;\n                }\n            }\n        }\n        return max(ret, depth);\n    }\n};"
		],
		[
			5.889935230697462,
			5.183377074635478,
			2,
			10.5417,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n        return root==NULL ? 0 : 1+max(maxDepth(root->left),maxDepth(root->right));\n        \n    }\n};\n"
		],
		[
			6.005887587997235,
			5.183377074635478,
			2,
			10.0,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxDepth(TreeNode* root) {\n       return !root?0:max(maxDepth(root -> right),maxDepth(root -> left))+1; \n    }\n};\n"
		],
		[
			5.963298777531525,
			5.183377074635478,
			2,
			12.5667,
			"class Solution {\npublic:class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\nint maxDepth(TreeNode* root) {\n    if(root == NULL){\n        return 0;\n    }\n    int l = maxDepth(root -> left);\n    int r = maxDepth(root -> right);\n    int ans = max(l, r) + 1;\n    return ans;\n}\n};"
		],
		[
			5.760325399730492,
			5.183377074635478,
			2,
			11.0769,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tint maxDepth(TreeNode* root) {\n\treturn root ? 1 + max(maxDepth(root->left), maxDepth(root->right)) : 0;\n}\n};"
		]
	],
	"MAX_PATH_SUM_BT": [
		"n",
		[
			5.792813610991336,
			5.183377074635478,
			3,
			34.0,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    #include<algorithm>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int ans=INT_MIN;\n    int solve(TreeNode *trav){\n        if(!trav)return 0;\n        int sum=trav->val;\n\n        int l_sum=solve(trav->left);\n        int r_sum=solve(trav->right);\n        \n        l_sum=max(l_sum,0);\n        r_sum=max(r_sum,0);\n        \n        ans =max(ans,l_sum+r_sum+sum);\n        return max(l_sum,r_sum)+sum;\n    }\n    \n    int maxPathSum(TreeNode* root) {\n        solve(root);\n        return ans;\n    }\n};\n"
		],
		[
			6.0265276908899805,
			5.183377074635478,
			5,
			27.0455,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n  int maxPathSum(TreeNode* root) {\n    int maximumPath = INT_MIN;\n    auto updateMax = [&maximumPath](int num){\n      if(maximumPath < num) maximumPath = num;\n    };\n    function<int(TreeNode* node)> recurser;\n    recurser = [&recurser, &updateMax](TreeNode* node){\n      if(!node) return 0;\n      updateMax(node->val);\n      int leftPath = recurser(node->left);\n      int rightPath = recurser(node->right);\n      int longerPath = max(leftPath, rightPath);\n      if(leftPath>0 && rightPath>0) updateMax(node->val + leftPath + rightPath);\n      else updateMax(node->val + longerPath);\n      return max(0, node->val + longerPath);\n    };\n    recurser(root);\n    return maximumPath;\n  }\n};\n"
		],
		[
			5.857198898072296,
			5.183377074635478,
			3,
			18.4091,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int maxdownsum;\n        int h;\n        helper(root, maxdownsum, h);\n        return rst;\n    }\nprivate:\n    int rst = INT_MIN;\n    \n    void helper(TreeNode* root, int& maxdownsum, int& h) {\n        if (!root) {\n            // null\n            maxdownsum = 0;\n            h = 0;\n            return ;\n        }\n        int ldownsum, rdownsum; // max sum for a path that starts from l/r child node and goes downward only\n        int lh, rh; // height for l/r subtree\n        helper(root->left, ldownsum, lh);\n        helper(root->right, rdownsum, rh);\n        // figure out height and maxdownsum for root node\n        h = max(lh, rh) + 1;\n        maxdownsum = max(max(ldownsum, 0), max(rdownsum, 0)) + root->val;\n        // calculate max path that passes root node\n        rst = max(rst, max(ldownsum, 0) + max(rdownsum, 0) + root->val);\n    }\n    \n};"
		],
		[
			5.779091456160124,
			5.183377074635478,
			3,
			20.5368,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int res{numeric_limits<int>::min()};\n        maxHelper(root, res);\n        return res;\n    }\nprivate:  \n    // Partial sum is like a logger, it logs the max we've seen so far.\n    int maxHelper(TreeNode* root, int& partialSum) {\n        if (!root) return 0;\n        int leftMine = maxHelper(root->left, partialSum), rightMine = maxHelper(root->right, partialSum); \n        partialSum = max(partialSum, leftMine + rightMine + root->val); // Log the max we've seen\n        return max(0, root->val + max(leftMine, rightMine)); // Here we are returning paths\n    } // Since we are looking for the longest single path, we make a decision between\n\t// returning our current value plus either the left or the right path.\n\t// If a path sums to negative, we don't want to return it, it won't add to our longest path\n      // If a path is positive, it will have a positive impact on our max path, so we want to \n\t  // return it as opposed to returning 0.\n};"
		],
		[
			5.797280980732945,
			5.183377074635478,
			3,
			22.125,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int f;\nint Function(TreeNode* root){\nif(root==NULL){\nreturn 0;\n}\nint a=Function(root->left);\nint b=Function(root->right);\nint k=max(a,b);\nk=max(k,0);\nk=k+root->val;\nf=max(f,k);\nf=max(f,root->val+a+b);\n\n    return k;\n    \n}\n\nint maxPathSum(TreeNode* root) {\n    f=INT_MIN;\n    Function(root);\n    \n    return f;\n    \n}\n};"
		],
		[
			5.7558174400822,
			5.183377074635478,
			8,
			59.0652,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    void __max(TreeNode*, int&);\n    int maxPathSum(TreeNode* root) {\n        int mx = root -> val;\n        __max(root, mx);\n        return mx;\n    }\n};\n\nvoid Solution::__max(TreeNode* root, int& mx) {\n    if(!root) return;\n    \n    __max(root -> left, mx);\n    __max(root -> right, mx);\n    \n    if(root -> left && root -> right) {\n        auto left = root -> left -> val;\n        auto right = root -> right -> val;\n        \n        mx = std::max(mx, root -> val + left + right);        \n\n        root -> val = std::max(root -> val, std::max(left, right) + root -> val); \n    }\n    \n    else if(root -> left)\n        root -> val = std::max(root -> val, root -> val + root -> left -> val);\n    \n    else if(root -> right)\n        root -> val = std::max(root -> val, root -> val + root -> right -> val);\n    \n    if(root -> val > mx) mx = root -> val;        \n}\n"
		],
		[
			5.795500519251261,
			5.183377074635478,
			3,
			24.375,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int max_sum = root->val;\n        getMaxSumPath(root, &max_sum);\n        return max_sum;\n    }\nprivate:\n    int getMaxSumPath(TreeNode* node, int* max_sum) {\n        if (node == nullptr) return 0;\n        auto l = max(getMaxSumPath(node->left, max_sum), 0);\n        auto r = max(getMaxSumPath(node->right, max_sum), 0);\n        *max_sum = max(*max_sum, node->val + l + r);\n        return node->val + max(l, r);\n    }\n};\n"
		],
		[
			5.642604003368191,
			5.183377074635478,
			8,
			25.5,
			"#pragma GCC optimize (\"Ofast\")\nstatic auto _ = [] { std::ios::sync_with_stdio(0); std::cin.tie(0); std::cout.tie(0); std::cerr.tie(0); return 0; } ();\n\nclass Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int helper(TreeNode* root, int &maxsum) {\n        if(!root) return 0;\n        int l = helper(root->left, maxsum);\n        int r = helper(root->right, maxsum);\n        \n        if(l<0) l=0;\n        if(r<0) r=0;\n        \n        if (l + root->val + r >maxsum) \n            maxsum = l + root->val + r;\n        \n        if (l>r) return root->val + l;\n        else return root->val + r;\n    }\n    int maxPathSum(TreeNode* root) {\n        if(!root) return 0;\n        int maxsum = root->val;\n        helper(root, maxsum);\n        return maxsum;\n    }\n};"
		],
		[
			5.819424950696038,
			5.183377074635478,
			4,
			31.3333,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int currentSum = INT_MIN;\n        int maxSum = INT_MIN;\n        \n        go(root,currentSum,maxSum);\n        \n        return maxSum;\n    }\n    \n    int go(TreeNode* root,int &currentSum,int &maxSum){\n        \n        int l = 0;\n        int r = 0;\n        \n        if (root->left != nullptr){\n            l = go(root->left,currentSum,maxSum);\n        }\n        if (root->right != nullptr){\n            r = go(root->right,currentSum,maxSum);\n        }\n        \n        currentSum = max(l + root->val,r + root->val);\n        currentSum = max(currentSum,root->val);\n        maxSum = max(max(maxSum,currentSum),l + r + root->val);\n       \n        \n        return currentSum;\n    }\n};\n"
		],
		[
			5.76800213529308,
			5.183377074635478,
			3,
			18.7895,
			"class Solution {\npublic:\n    #include<vector>\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tint maxPathSum(TreeNode* root) {\n\tint res = INT_MIN;\n\tdfs(root, res);\n\treturn res;\n}\n\nint dfs(TreeNode *node, int &res) {\n\tif(!node) return 0;\n\tint l = dfs(node->left, res), r = dfs(node->right, res);\n\tres = max(res, node->val + l + r);\n\treturn max(0, node->val + max(l, r));\n}\n};"
		],
		[
			5.811789420610944,
			5.183377074635478,
			5,
			22.3429,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nstatic int speedup=[](){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\treturn 0;\n}();\n\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n\tint maxi=INT_MIN;\n\n\tint maxSum(TreeNode* root) {\n\t\tif(!root) return 0;\n\t\tif(!root->left && !root->right) {\n\t\t\tmaxi = max(maxi,root->val);\n\t\t\treturn root->val;\n\t\t} \n\n\t\tint v1 = maxSum(root->left);\n\t\tint v2 = maxSum(root->right);\n\t\tint tmp = max(root->val, max(v1, v2)+root->val);\n\t\tmaxi = max(maxi, max( (v1+v2+root->val), tmp));\n\t\treturn tmp;\n\t}\n\n\tint maxPathSum(TreeNode* root) {\n\t\tmaxSum(root);\n\t\treturn maxi;\n\t}\n};"
		],
		[
			5.97099525004125,
			5.183377074635478,
			3,
			30.4583,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int ans=INT_MIN;\n    int solve(TreeNode* root)\n    {\n        if(root==NULL) return 0;\n        int ls = max(0,solve(root->left));\n        int rs = max(0,solve(root->right));\n        ans = max(ans,root->val+ls+rs);\n        return root->val+max(ls,rs);\n    }\n    int maxPathSum(TreeNode* root) {\n        solve(root);\n        return ans;\n    }\n};\n"
		],
		[
			6.591398275778503,
			5.183377074635478,
			4,
			26.6538,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPath( TreeNode* root ){\n        if( !root )\n            return 0;\n        return max(root->val ,root->val + max(maxPath(root->left),maxPath(root->right) ));\n    }\n    int maxPathSum(TreeNode* root) {\n            if( !root )\n                return INT_MIN;\n            return max(root->val + maxPath(root->right),max(root->val + maxPath(root->left),max(root->val,max(root->val + maxPath(root->left) + maxPath(root->right),max(maxPathSum(root->left),maxPathSum(root->right))))));\n    }\n};\n"
		],
		[
			5.848909544253667,
			5.183377074635478,
			3,
			21.8571,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int maxSum = INT_MIN;\n        DFS(root, maxSum);\n        return maxSum;\n    }\n    \n    int DFS(TreeNode* root, int& maxSum){\n        if(!root) return 0;\n        int left = max(0, DFS(root->left, maxSum));\n        int right = max(0, DFS(root->right, maxSum));\n        maxSum = max(maxSum, left + right + root->val);\n        return max(left, right) + root->val;\n    }\n};\n"
		],
		[
			5.82082032584324,
			5.183377074635478,
			15,
			37.7596,
			"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution\n{\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root)\n    {\n        if (!root)\n            return 0;\n\n        // The idea is simple:\n        // For each subtree rooted at node \"root\", the maximal path sum can be\n        // calculated by:\n        //\n        // MAX | root->val\n        //     | root->val + PathSum(root->left)\n        //     | root->val + PathSum(root->right)\n        //     | root->val + PathSum(root->left) + PathSum(root->right)\n        //\n        // To pass an optimal path to the ancestors, we just select:\n        //\n        // MAX | root->val\n        //     | root->val + PathSum(root->left)\n        //     | root->val + PathSum(root->right)\n\n        int max = root->val;\n        DivideAndConquer(root, &max);\n        return max;\n    }\n\nprivate:\n    int DivideAndConquer(TreeNode* root, int* p_max)\n    {\n        int curr, ret_curr, local_max;\n        local_max = curr = ret_curr = root->val;\n\n        int ret_left;\n        if (root->left) {\n            ret_left = DivideAndConquer(root->left, p_max);\n            if (ret_left > local_max)\n                local_max = ret_left;\n\n            int sum_left = ret_left + curr;\n            if (sum_left > local_max)\n                local_max = sum_left;\n\n            if (sum_left > ret_curr)\n                ret_curr = sum_left;\n        }\n\n        int ret_right;\n        if (root->right) {\n            ret_right = DivideAndConquer(root->right, p_max);\n            if (ret_right > local_max)\n                local_max = ret_right;\n\n            int sum_right = ret_right + curr;\n            if (sum_right > local_max)\n                local_max = sum_right;\n\n            if (sum_right > ret_curr)\n                ret_curr = sum_right;\n        }\n\n        if (root->left && root->right) {\n            int sum_both = curr + ret_left + ret_right;\n            if (sum_both > local_max)\n                local_max = sum_both;\n        }\n\n        if (local_max > *p_max)\n            *p_max = local_max;\n        return ret_curr;\n    }\n};"
		],
		[
			6.101397939410807,
			5.1833770746354775,
			3,
			18.3529,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int maxsum = INT_MIN;\n        dfs(root,maxsum);\n        return maxsum;\n    }\nprivate:\n    int dfs(TreeNode* root, int& maxsum) {\n        if(!root) return 0;\n        int l = max(0,dfs(root->left,maxsum));\n        int r = max(0,dfs(root->right,maxsum));\n        maxsum = max(l+r+root->val, maxsum);\n        return root->val + max(l,r);\n    }\n};"
		],
		[
			5.829436065957762,
			5.183377074635478,
			10,
			28.9524,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int max = INT_MIN;\n        maxPathSumHelper(root, &max);\n        return max;\n    }\nprivate:\n    int maxPathSumHelper(TreeNode* root, int* max)\n    {   \n        // DFS: depth first search\n        if(root == NULL)\n            return 0;\n        int left = maxPathSumHelper(root->left, max);\n        int right = maxPathSumHelper(root->right, max);\n        int three = root->val;\n        if(left > 0)\n            three = three + left;\n        if(right > 0)\n            three = three + right;\n        if(three > *max)\n            *max = three;\n            \n        int two = root->val;\n        if(left > right && left > 0)\n            two = two + left;\n        else if(right > left && right > 0)\n            two = two + right;\n        return two;\n    }\n};"
		],
		[
			5.893891687993901,
			5.183377074635478,
			3,
			28.0312,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int solve(TreeNode* root,int &res){\n        if(NULL == root)\n            return 0;\n        int left_val=solve(root->left,res);\n        int right_val=solve(root->right,res);\n        int curr_max=max(max(left_val,right_val)+root->val,root->val);\n        res=max(res,curr_max);\n        res=max(res,max(curr_max,left_val+right_val+root->val));\n        return curr_max;\n    }\n    int maxPathSum(TreeNode* root) {\n        int res=INT_MIN;\n        solve(root,res);\n        return res;\n    }\n};\n"
		],
		[
			6.019722973044212,
			5.183377074635478,
			14,
			35.7333,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int helper(TreeNode* root, int &rez){\n      int leftval,rightval;\n      bool l=false,r=false;\n      if(!root->left && !root->right) {if(root->val > rez)rez=root->val;return root->val;}            // a)\n      if(root->left) {                      //try to give result for left branch\n        leftval = helper(root->left,rez);\n        l = true;\n      }\n      if(root->right) {                    //try to give result for right branch\n        rightval = helper(root->right,rez);\n        r = true;\n      }\n      if(l && r){                             // d)\n        int tmp = max(root->val,max(root->val + leftval,max(root->val + leftval + rightval,root->val  + rightval)));\n        if(tmp > rez) rez = tmp;\n        return max(root->val,max(root->val + leftval,root->val  + rightval));\n      }else{\n        if(l){                       // b)\n          int tmp = max(root->val,root->val + leftval);\n          if(tmp > rez) rez = tmp;\n          return tmp;\n        }                      // c)\n        int tmp = max(root->val,root->val + rightval);\n          if(tmp > rez) rez = tmp;\n          return tmp;\n      }\n    }\n  \n    int maxPathSum(TreeNode* root) {\n    int rez = INT_MIN;  \n    if(root) helper(root, rez);  \n    return rez;    \n    }\n};\n"
		],
		[
			6.0641682907040995,
			5.183377074635478,
			3,
			16.1029,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int ans=INT_MIN;\n        findMaxPath(root,ans);\n        return ans;\n    }\n    int findMaxPath(TreeNode* root,int& ans){\n        if(!root){\n            return 0;\n        }\n        //JUST TO REMEMBER : to neutralise the -ve value returned from findMaxPath() bcz if we do not do that the ans value will be affected\n        int fromLeft=max(0,findMaxPath(root->left,ans));\n        int fromRight=max(0,findMaxPath(root->right,ans));\n\t\t //IMPORTANT\n        ans=max(ans,fromLeft+fromRight+root->val);\n        return max(fromLeft,fromRight)+root->val;\n        \n    }\n};\n"
		],
		[
			5.889002128911344,
			5.183377074635478,
			3,
			19.125,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int ans=INT_MIN;\n        dfs(root,ans);\n        return ans;\n    }\n    int dfs(TreeNode* root, int &ans)\n    {\n        if(!root) return 0;\n        int l=max(0,dfs(root->left,ans));\n        int r=max(0,dfs(root->right,ans));      \n        ans=max(ans, root->val+l+r);\n        return root->val + max(l,r);\n    }\n};\n"
		],
		[
			1.0,
			5.183377074635478,
			3,
			19.8824,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum(TreeNode* root) {\n        int sum=INT_MIN;\n        helper(root,sum);\n        return sum;\n    }\n    int helper(TreeNode* root, int &sum)\n    {\n        if(root==NULL)\n            return 0;\n        int l=max(0,helper(root->left,sum));\n        int r=max(0,helper(root->right,sum));\n        \n        sum=max(sum, root->val+l+r);\n        return (root->val +max(l,r));\n    }\n};\n"
		],
		[
			5.890817569105025,
			5.183377074635478,
			3,
			21.7941,
			"class Solution {\npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int dfs(TreeNode* root, int &globalmax)\n    {\n        if(root==NULL) return 0;\n        \n        int left = dfs(root->left, globalmax);\n        int right = dfs(root->right, globalmax);\n        \n        int straightPath = max(max(left, right) + root->val, root->val);\n        \n        int trianglePath = max(straightPath, left + right + root->val);\n        \n        globalmax = max(globalmax, trianglePath);\n        \n        return straightPath;\n    }\n    int maxPathSum(TreeNode* root) \n\t{\n        int globalmax = INT_MIN;\n        dfs(root, globalmax);\n        return globalmax;\n    }\n};\n"
		],
		[
			5.966411696761355,
			5.183377074635478,
			5,
			26.975,
			"class Solution {    \npublic:\n    class TreeNode{\n        public:\n        TreeNode* left;\n        TreeNode* right;\n        int val;\n    };\n    int maxPathSum( TreeNode* root ) {\n        int maxSum = INT_MIN;\n        helper( root, maxSum );\n        return maxSum;\n    }\n    int helper( TreeNode* node, int &maxSum ) {\n        if( !node ) return 0;\n        int left = 0, right = 0;\n        if( node->left )  left = helper( node->left, maxSum );\n        if( node->right ) right = helper( node->right, maxSum );\n        \n        // node+left or node+right or node\n        int leftOrRightOrNode = max( node->val, node->val + max( left, right ) );\n        // set maxSum to max of maxSum, node+left+right, node+left, node+right, node\n        maxSum = max( maxSum, max( node->val + left + right, leftOrRightOrNode ) );        \n        return leftOrRightOrNode;\n    }\n};\n"
		]
	],
	"SUDOKU": [
		"1",
		[
			1.0,
			1.0,
			15,
			42.6364,
			"class Solution {\npublic:\n\t#include<vector>\n\tbool rakhSakteHai(vector<vector<char>>& mat, int i,int j,int n,char num){\n\n\t\tfor(int x = 0 ; x < n ; x++){\n\t\t\tif(mat[x][j]==num || mat[i][x]==num) return false; //check col and row\n\t\t}\n\n\t\tint rn = sqrt(n);\n\t\tint sx = (i/rn)*rn;\n\t\tint sy = (j/rn)*rn;\n\t\t//check grid \n\t\tfor(int x = sx ; x < sx+rn ; x++){\n\t\t\tfor(int y = sy ; y < sy+rn ; y++){\n\n\t\t\t\tif(mat[x][y]==num) return false;\n\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool solve(vector<vector<char>>& board, int i,int j,int n){\n\n\t\tif(i == n) return true;\n\n\t\tif(j == n) return solve(board,i+1,0,n);\n\n\t\tif(board[i][j] != '.') return solve(board,i,j+1,n);\n\n\n\t\tfor(char num = '1' ; num <= '9' ; num++){\n\n\t\t\tif(rakhSakteHai(board,i,j,n,num)){\n\t\t\t\tboard[i][j] = num;\n\n\t\t\t\tif(solve(board,i,j+1,n))return true;\n\n\t\t\t\tboard[i][j] = '.';\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid solveSudoku(vector<vector<char>>& board) {\n\n\t\tint n = board.size();\n\t\tsolve(board,0,0,n);\n\t\treturn;\n\n\t}\n};"
		],
		[
			1.0,
			1.0,
			23,
			58.8462,
			"class Solution {\npublic:\n    bool row[9][9] = {{false}};\n    bool col[9][9] = {{false}};\n    bool box[9][9] = {{false}};\n    \n    void solveSudoku(vector<vector<char>>& board) {\n        int I,J;\n        bool flag = false;\n        for (int i = 0; i < 9; i++){\n            for (int j = 0; j < 9; j++){\n                if (board[i][j] != '.'){\n                    row[i][board[i][j]-48-1] = true;\n                    col[j][board[i][j]-48-1] = true;\n                    box[i/3*3+j/3][board[i][j]-48-1] = true;\n                }\n                else if (board[i][j] == '.' && !flag){\n                    I = i, J = j;       // store the first empty position\n                    flag = true;\n                }\n            }\n        }\n        backtrack(board, I, J);\n    }\n    \n    bool backtrack(vector<vector<char>>& board, int i, int j){\n        if (board[i][j] != '.'){\n            bool valid = true;\n            if (i == 8 && j == 8)\n                return true;\n            else if (i < 8 && j == 8)\n                valid = backtrack(board, i+1, 0);\n            else if (j < 8)\n                valid = backtrack(board, i, j+1);\n            return valid;\n        }\n            \n        for (int val = 1; val <= 9; val++){\n            if (row[i][val-1] == true || col[j][val-1] == true || box[i/3*3+j/3][val-1] == true)\n                continue;\n            board[i][j] = val+48;\n            row[i][val-1] = true;\n            col[j][val-1] = true;\n            box[i/3*3+j/3][val-1] = true;\n            \n            bool valid = true;\n            if (i == 8 && j == 8)\n                return true;        // very last position\n            else if (i < 8 && j == 8)\n                valid = backtrack(board, i+1, 0);        // new row\n            else if (j < 8)\n                valid = backtrack(board, i, j+1);        // add one to column\n            \n            if(!valid){        // it's invalid with this \"val\" in [i][j], backtrack\n                board[i][j] = '.';\n                row[i][val-1] = false;\n                col[j][val-1] = false;\n                box[i/3*3+j/3][val-1] = false;\n            }\n            else\n                return valid;        // return true\n        }\n        return false;        // current position is a dead end, go to previous position\n    }\n};\n"
		],
		[
			4348220136.992216,
			1.0,
			18,
			50.8276,
			"class Solution {\npublic:\n    bool findunassignedindex(int &row,int &col,vector<vector<char>>& board)\n    {\n        for(row=0;row<9;row++)\n        {\n            for(col=0;col<9;col++)\n            {\n                if(board[row][col]=='.') return true;\n            }\n        }\n        return false;\n    }\n    bool issafe(int row,int col,int num,vector<vector<char>>& board)\n    {\n        for(int i=0;i<9;i++) if(board[row][i]==num+48) return false;  // check safe row\n        for(int i=0;i<9;i++) if(board[i][col]==num+48) return false;  // check safe col\n        int boxrow = row - row%3;\n        int boxcol = col - col%3;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(board[i+boxrow][j+boxcol]==num+48) return false;  // checks box\n            }\n        }\n        return true;\n    }\n    bool valid(vector<vector<char>>& board)\n    {\n        int row,col;\n        if(!findunassignedindex(row,col,board)) return true;\n        \n        for(int num=1;num<=9;num++)\n        {\n            if(issafe(row,col,num,board))\n            {\n                board[row][col] = num+48;\n                if(valid(board)) return true;\n                board[row][col] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        valid(board);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			25,
			62.0303,
			"class Solution {\npublic:\n\tvector<vector<char>> B;\n\tbool isValid(int x, int y, char c){\n\t\tfor(int i=0;i<9;i++){\n\t\t\tif(B[x][i]==c) return false;\n\t\t}\n\n\t\tfor(int i=0;i<9;i++){\n\t\t\tif(B[i][y]==c) return false;\n\t\t}\n\n\t\tint a=(x/3)*3;\n\t\tint b=(y/3)*3;\n\t\tfor(int i=a;i<a+3;i++){\n\t\t\tfor(int j=b;j<b+3;j++){\n\t\t\t\tif(B[i][j]==c){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn true;\n\t}\n\n\tbool backtrack(int x, int y){\n\t\tint nextR=-1;\n\t\tint nextC=-1;\n\n\t\tbool flag=false;\n\t\tbool flag2=false;\n\t\tfor(int i=y+1;i<9;i++){\n\t\t\tif(B[x][i]=='.'){\n\t\t\t\tnextR=x;\n\t\t\t\tnextC=i;\n\t\t\t\tflag=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tfor(int i=x+1;i<9;i++){\n\t\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\t\tif(B[i][j]=='.'){\n\t\t\t\t\t\tnextR=i;\n\t\t\t\t\t\tnextC=j;\n\t\t\t\t\t\tflag2=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag2){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tchar temp='0'+i;\n\t\t\tif(isValid(x,y,temp)){\n\t\t\t\tB[x][y]=temp;\n\t\t\t\tif(nextR==-1) return true;\n\t\t\t\tbool res=backtrack(nextR,nextC);\n\t\t\t\tif(res) return true;\n\t\t\t\tB[x][y]='.'; \n\n\n\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\tvoid solveSudoku(vector<vector<char>>& board) {\n\t\tB=board;\n\t\tint startX;\n\t\tint startY;\n\t\tbool stop=false;\n\t\tfor(int i=0;i<9;i++){\n\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\tif(B[i][j]=='.'){\n\t\t\t\t\tstartX=i;\n\t\t\t\t\tstartY=j;\n\t\t\t\t\tstop=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(stop){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbacktrack(startX,startY);\n\t\tboard=B;\n\t}\n};"
		],
		[
			3978953401.1631374,
			1.0,
			8,
			48.6316,
			"#include <bitset>\n\nstatic auto x = []() {ios_base::sync_with_stdio(false); cin.tie(NULL); return NULL; }();\n\nclass Solution\n{\npublic:\n    bitset<9> rowcheck[9], colcheck[9], matcheck[3][3];\n\n    bool isValid(vector<vector<char>> &board, int row, int col, char val)\n    {\n        if (rowcheck[row].test(val)){ return false; }\n        if (colcheck[col].test(val)){ return false; }\n        if (matcheck[row / 3][col / 3].test(val)){ return false; }\n        return true;\n    }\n\n    bool solveSudoku(vector<vector<char>> &board, int row, int col)\n    {\n        while (row < 9 && board[row][col] != '.')\n        {\n            col++;\n            if (col == 9){ col = 0, ++row; }\n        }\n        if (row == 9){ return true; }\n\n        for (int v = 0; v < 9; v++)\n        {\n            if (isValid(board, row, col, v))\n            {\n                board[row][col] = v + 1 + '0';\n                rowcheck[row].set(v);\n                colcheck[col].set(v);\n                matcheck[row / 3][col / 3].set(v);\n                if (solveSudoku(board, row, col)){ return true; }\n\n                board[row][col] = '.';\n                rowcheck[row].reset(v);\n                colcheck[col].reset(v);\n                matcheck[row / 3][col / 3].reset(v);\n            }\n        }\n        return false;\n    }\n\n    void solveSudoku(vector<vector<char>> &board)\n    {\n\n        for (int row = 0; row < 9; row++)\n            for (int col = 0; col < 9; col++)\n                if (board[row][col] != '.')\n                {\n                    int v = board[row][col] - '0' - 1;\n                    rowcheck[row].set(v);\n                    colcheck[col].set(v);\n                    matcheck[row / 3][col / 3].set(v);\n                }\n\n        solveSudoku(board, 0, 0);\n    }\n};\n"
		],
		[
			4454050926.190193,
			1.0,
			26,
			55.0,
			"class Solution {\n    private:\n    vector<int> nextDot(vector<vector<char>>& board){\n        vector<int> a(2,-1);\n        for(int i=0;i<board.size();i++){\n            for(int j=0;j<board[0].size();j++)\n                if(board[i][j]=='.')\n                {\n                    a[0]=i;\n                    a[1]=j;\n                }\n        }\nreturn a;\n        \n    }\n    \n    bool isValid(vector<vector<char>>& board,int num,int row,int col){\n        for(int i=0;i<board[0].size();i++)\n            if(board[row][i]==num)\n                return false;\n        for(int j=0;j<board.size();j++)\n            if(board[j][col]==num)\n                return false;\n        int boxRow=3*(row/3);\n        int boxCol=3*(col/3);\n        for(int i=boxRow;i<boxRow+3;i++)\n            for(int j=boxCol;j<boxCol+3;j++)\n                if(board[i][j]==num)\n                    return false;\n        return true;\n    }\npublic:\n    bool solveSudoku(vector<vector<char>>& board) {\n             vector<int> newDot=nextDot(board);\n        if(newDot[0]==-1 && newDot[1]==-1)\n            return true;\n   \n        int row=newDot[0];\n        int col=newDot[1];\n        char c;\n      for(int num=1;num<10;num++)\n            {\n                 if(num==1)\n                   c='1';\n                 else if(num==2)\n                   c='2';\n                 else if(num==3)\n                   c='3';\n                 else if(num==4)\n                   c='4';\n                 else if(num==5)\n                   c='5';\n                 else if(num==6)\n                    c='6';\n                 else if(num==7)\n                    c='7';\n                 else if(num==8)\n                    c='8';\n                 else\n                    c='9';\n                \n                if(isValid(board,c,row,col)){\n                              \n                 board[row][col]=c;\n                   \n                    if(solveSudoku(board))\n                        return true;\n                    //backtracking\n                        board[row][col]='.';\n                }\n        \n            }\n        return false;\n    }\n};\n"
		],
		[
			4313969449.837151,
			1.0,
			13,
			83.0968,
			"class Solution {\nprivate:\n\tvector<vector<bool>>row;//row[i][j]\u8868\u793a\u7b2ci\u884c\u5df2\u7ecf\u6709\u4e86j+1\u8fd9\u4e2a\u6570\u5b57\n\tvector<vector<bool>>col;//col[i][j]\u8868\u793a\u7b2ci\u5217\u5df2\u7ecf\u6709\u4e86j+1\u8fd9\u4e2a\u6570\u5b57\n\tvector<vector<vector<bool>>>cube;//\u628a9X9\u5206\u62103x3x9\u4e2a\n\t//cube[i][j][k]\u8868\u793a\u7b2ci\u884c\u7b2cj\u5217\u76843*3\u5df2\u7ecf\u6709\u4e86j+1\u8fd9\u4e2a\u6570\u5b57\npublic:\n\tvoid solveSudoku(vector<vector<char>>& board) {\n\t\trow = vector<vector<bool>>(9, vector<bool>(9, false));\n\t\tcol = vector<vector<bool>>(9, vector<bool>(9, false));\n\t\tcube = vector<vector<vector<bool>>>(3, vector<vector<bool>>(3, vector<bool>(9, false)));\n\t\tint n = 0;\n\t\tfor (int i = 0; i < 9; i++) {\n\t\t\tfor (int j = 0; j < 9; j++) {\n\t\t\t\tif (board[i][j] != '.') {\n\t\t\t\t\trow[i][board[i][j] - '1'] = true;\n\t\t\t\t\tcol[j][board[i][j] - '1'] = true;\n\t\t\t\t\tcube[i / 3][j / 3][board[i][j] - '1'] = true;\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn = 81 - n;//\u9700\u8981\u586b\u5199\u6570\u5b57\u7684\u4e2a\u6570\n\t\tDFS(0, n, board);\n\t\treturn;\n\t}\n\tbool DFS(int index, int n, vector<vector<char>>& board) {\n\t\tif (n == 0) {\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = index; i < 81; i++) {\n\t\t\tint x = i / 9;\n\t\t\tint y = i % 9;\n\t\t\tif (board[x][y] == '.') {\n\t\t\t\tfor (int j = 1; j < 10; j++) {\n\t\t\t\t\tif (!row[x][j - 1] && !col[y][j - 1] &&\n\t\t\t\t\t\t!cube[x / 3][y / 3][j - 1]) {\n\t\t\t\t\t\tboard[x][y] = j + 48;\n\t\t\t\t\t\trow[x][j - 1] = true;\n\t\t\t\t\t\tcol[y][j - 1] = true;\n\t\t\t\t\t\tcube[x / 3][y / 3][j - 1] = true;\n\t\t\t\t\t\tn--;\n\n\t\t\t\t\t\tif (DFS(i + 1, n, board))\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\tboard[x][y] = '.';\n\t\t\t\t\t\trow[x][j - 1] = false;\n\t\t\t\t\t\tcol[y][j - 1] = false;\n\t\t\t\t\t\tcube[x / 3][y / 3][j - 1] = false;\n\t\t\t\t\t\tn++;\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			71.1765,
			"class Solution {\npublic:\nbool solveSudoku(int *sequence, int begin, short *rows, short *cols, short *subs,\n                 const int *row_index, const int *col_index, const int *sub_index)\n{\n    for (int s = begin; s < 81; ++s)\n    {\n        int i = row_index[s], j = col_index[s], k = sub_index[s];\n        if (!sequence[s])\n        {\n            short candidates = ~rows[i] & ~cols[j] & ~subs[k];\n            while (candidates & 0x1ff)\n            {\n                short val = candidates & (-candidates);\n                sequence[s] = val;\n                rows[i] |= val; cols[j] |= val; subs[k] |= val;\n                if (solveSudoku(sequence, s + 1, rows, cols, subs, row_index, col_index, sub_index))\n                    return true;\n                sequence[s] = 0;\n                rows[i] &= ~val; cols[j] &= ~val; subs[k] &= ~val;\n                candidates &= ~val;\n            }\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>> &board)\n{\n    short rows[9]{ 0 }, cols[9]{ 0 }, subs[9]{ 0 };\n    int sequence[81]{ 0 }, row_index[81], col_index[81], sub_index[81];\n    for (int i = 0; i < 9; ++i)\n    {\n        for (int j = 0; j < 9; ++j)\n        {\n            int s = 9 * i + j;\n            row_index[s] = i; col_index[s] = j; sub_index[s] = (i / 3) * 3 + j / 3;\n            if (board[i][j] != '.')\n            {\n                sequence[s] = 1 << (board[i][j] - '1');\n                rows[i] |= sequence[s]; cols[j] |= sequence[s]; subs[sub_index[s]] |= sequence[s];\n            }\n        }\n    }\n    solveSudoku(sequence, 0, rows, cols, subs, row_index, col_index, sub_index);\n    for (int i = 0; i < 9; ++i)\n    {\n        for (int j = 0; j < 9; ++j)\n        {\n            if (board[i][j] == '.')\n            {\n                int s = 9 * i + j, n;\n                for (n = 0; sequence[s] != (1 << n); ++n)\n                    ;\n                board[i][j] = n + '1';\n            }\n        }\n    }\n}\n};"
		],
		[
			4385905536.211118,
			4552304539.408505,
			15,
			63.1148,
			"class Solution {\npublic:\ntypedef struct\n{\n    short x;\n    short y;\n}POS;\n    void solveSudoku(vector<vector<char> >& board) {\n        solve(board);\n    }\nprivate:\n    int solve(vector<vector<char> >& board) {\n        vector<POS> todo;//cells not filled\n        short r[9]={0,0,0,0,0,0,0,0,0};//row\n        short c[9]={0,0,0,0,0,0,0,0,0};//col\n        short b[9]={0,0,0,0,0,0,0,0,0};//block\n        //short n[9]={0,0,0,0,0,0,0,0,0};\n        short i,j;\n        for(i=0;i<9;i++)\n        {\n            for(j=0;j<9;j++)\n            {\n                if(board[i][j]!='.')\n                {\n                    short temp=(1<<(board[i][j]-'1'));\n                    r[i]=r[i]|temp;\n                    c[j]=c[j]|temp;\n                    int pos=i/3+j/3*3;\n                    b[pos]=b[pos]|temp;\n                    //n[board[i][j]-'1']++;\n                }\n                else\n                {\n                    POS t;\n                    t.x=i;\n                    t.y=j;\n                    todo.push_back(t);\n                }\n            }\n        }\n        j=0;//debug\n        while(todo.size()!=0)\n        {\n            int flag=0;\n            for(auto it=todo.begin();it!=todo.end();it++)\n            {\n                int x=(*it).x,y=(*it).y;\n                int pos=x/3+y/3*3;\n                short temp=~(b[pos]|r[x]|c[y]|0xfe00);\n                if(temp==0)\n                {\n                    return -1;\n                }\n                else if(((temp-1)&temp)==0)//the cell has only one valid number \n                {\n                    i=0;\n                    r[x]=r[x]|temp;\n                    c[y]=c[y]|temp;\n                    b[pos]=b[pos]|temp;\n                    while(temp!=1)\n                    {\n                        temp=temp>>1;\n                        i++;\n                    }\n                    j++;//debug\n                    //n[i]++;\n                    board[x][y]=i+'1';\n                    todo.erase(it);\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)//no cell has only one number\n            {\n                auto it=todo.begin();\n                int x=(*it).x,y=(*it).y;\n                int pos=x/3+y/3*3;\n                short temp=~(b[pos]|r[x]|c[y]|0xfe00);\n                i=0;\n                while(temp>0)\n                {\n                    if((temp&1)==1)\n                    {\n                        board[x][y]=i+'1';//guess one in the valid number\n                        if(solve(board)==0)//succeed\n                        {\n                            return 0;\n                        }\n                        //if failed clear the error num\n                        for(auto it2=todo.begin();it2!=todo.end();it2++)\n                            board[(*it2).x][(*it2).y]='.';\n                    }\n                    temp=temp>>1;\n                    i++;\n                }\n                return 1;\n            }\n        }\n        return 0;\n    }\n};"
		],
		[
			1.0,
			1.0,
			13,
			66.7,
			"class Solution {\npublic:\nint b, row[9][9] = {}, col[9][9] = {}, block[9][9] = {};\nvoid solveSudoku(vector<vector<char>>& board) {\n    for(int i = 0; i < 9; i++)\n        for(int j = 0; j < 9; j++){\n            b = board[i][j] - '1';\n            if(b >= 0){\n                row[i][b] = 1;\n                col[j][b] = 1;\n                block[i/3*3+j/3][b] = 1;\n            }\n        }\n    fill(board,0,0);\n}    \nbool fill(vector<vector<char>>& board, int r, int c){\n    if(c == 9){\n        c = 0;\n        ++r;\n    }\n    if(r == 9)\n        return true;        \n    if(board[r][c] == '.'){ // fill\n        for(int k = 0; k < 9; k++)\n            if(row[r][k] == 0 && col[c][k] == 0 && block[r/3*3+c/3][k] == 0){\n                row[r][k] =  col[c][k] = block[r/3*3+c/3][k] = 1;\n                board[r][c] = k + '1';\n                if( !fill(board,r,c+1) ){\n                    row[r][k] =  col[c][k] = block[r/3*3+c/3][k] = 0;\n                    board[r][c] = '.';\n                }\n                else return true;\n            }                \n            return false;\n    }\n    else{ // next\n        return fill(board,r,c+1);\n    }\n}\n};"
		],
		[
			1.0,
			1.0,
			16,
			42.0,
			"class Solution \n{\npublic:\n\t// determine the board is valid or not.\n\tbool isValid(vector<vector<char>>& board, int row , int column, char c) \n\t{\n\t\tfor (int i = 0; i < 9; ++i)\n\t\t\tif (board[row][i] == c) return false;\n\t\tfor (int j = 0; j < 9; ++j)\n\t\t\tif (board[j][column] == c) return false;\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tif (board[row / 3 * 3 + i][column / 3 * 3 + j] == c)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tbool solve(vector<vector<char>>& board) \n\t{\n\t\tfor (int i = 0; i < 9; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 9; ++j)\n\t\t\t{\n\t\t\t\tif ('.' == board[i][j]) \n\t\t\t\t{\n\t\t\t\t\tfor (int k = 0; k < 9; ++k)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isValid(board, i, j, '1' + k)) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tboard[i][j] = '1' + k;\n\t\t\t\t\t\t\tif (solve(board)) return true;\n\t\t\t\t\t\t\telse board[i][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid solveSudoku(vector<vector<char>>& board) \n\t{\n\t\tsolve(board);\n\t}\n};"
		],
		[
			1.0,
			1.0,
			16,
			57.75,
			"class Solution {\npublic:\n    bool ok(vector<vector<char>>& board, int a, int i, int j){\n        // row\n        for(int c=0;c<9;++c)\n            if(board[i][c]-'0' == a)\n                return 0;\n        // col\n        for(int r=0;r<9;++r)\n            if(board[r][j]-'0' == a)\n                return 0;\n        // cell\n        int br = i/3, bc = j/3;\n        for(int r=br*3; r<br*3+3;++r)\n            for(int c=bc*3; c<bc*3+3;++c)\n                if(board[r][c]-'0' == a)\n                    return 0;\n        return 1;\n    }\n    \n    bool dfs(vector<vector<char>>& board, int i, int j){\n        if(i == 9) return 1;\n        if(j == 9) return dfs(board,i+1,0);\n        if(board[i][j] != '.') return dfs(board,i,j+1);\n        for(int a=1;a<=9;++a){\n            if(ok(board,a,i,j)){\n                board[i][j] = a+'0';\n                if(dfs(board,i,j+1)) \n                    return 1;\n                board[i][j] = '.';\n            }      \n        }\n        return 0;\n    }\n    void solveSudoku(vector<vector<char>>& board) {\n        dfs(board,0,0);\n    }\n};\n            \n"
		],
		[
			1.0,
			1.0,
			16,
			73.6607,
			"class Solution {\npublic:\n    bool col[10][10],row[10][10],f[10][10];\n    bool flag = false;\n    void solveSudoku(vector<vector<char>>& board) {\n         memset(col,false,sizeof(col));\n         memset(row,false,sizeof(row));\n         memset(f,false,sizeof(f));\n         for(int i = 0; i < 9;i++){\n             for(int j = 0; j < 9;j++){\n                 if(board[i][j] == '.')   continue;\n                 int temp = 3*(i/3)+j/3;\n                 int num = board[i][j]-'0';\n                 col[j][num] = row[i][num] = f[temp][num] = true;\n             }\n         }\n         dfs(board,0,0);\n    }\n    void dfs(vector<vector<char>>& board,int i,int j){\n        if(flag == true)  return ;\n        if(i >= 9){\n            flag = true;\n            return ;\n        }\n        if(board[i][j] != '.'){\n             if(j < 8)  dfs(board,i,j+1);\n             else dfs(board,i+1,0);\n             if(flag)  return;\n        }\n        \n        else{\n            int temp = 3*(i/3)+j/3;\n            for(int n = 1; n <= 9; n++){\n                if(!col[j][n] && !row[i][n] && !f[temp][n]){\n                    board[i][j] = n + '0';\n                    col[j][n] = row[i][n] = f[temp][n] = true;\n                    if(j < 8)  dfs(board,i,j+1);\n                    else dfs(board,i+1,0);\n                    col[j][n] = row[i][n] = f[temp][n] = false;\n                    if(flag)  return;\n                }\n            }\n            board[i][j] = '.';\n        }\n    }\n};"
		],
		[
			4584270377.965968,
			4552084983.01155,
			37,
			39.7104,
			"class Solution {\n    // Table which allows compute the value of the cell\n    // from the unambiguous bit mask as maskToValue[(mask%11)-1] \n    // uses the fact that (1<<i)%11 is unique for i = [0..8] and never produces 0\n    const char maskToValue[10] = {'1','2','9','3','5','6','8','4','7','6'};\n    struct SudokuSolver {\n        // Using mask for each cell which constraints values which can be in the cell\n        // Yeap, it is more storage, comparing to rows/cols/sqrs approach\n        // but it allows to do super-fast reactive constraint propagation\n        array<array<uint16_t,9>,9> board;\n        SudokuSolver()\n        {\n            // Initializing the board with mask, which permits all numbers\n            for (int i=0; i<9; i++)\n                for (int j=0; j<9; j++)\n                    board[i][j] = 0x1ff;\n        }\n        \n        // adds value v [1..9] to the board, return false if it violates constraints\n        bool add(int i, int j, int v)\n        {\n            return set(i, j, 1<<(v-1));\n        }\n\n        // set a value mask to the cell (i,j) and reactively updates constraints\n        bool set(int i, int j, uint16_t mask)\n        {\n            int16_t prev = board[i][j];\n            if (prev == mask) return true;\n            if (!(prev&mask)) return false;\n            board[i][j] = mask;\n            return propagate(i,j,mask);\n        }\n        \n        // propagates constraints as a result of setting i,j to mask\n        bool propagate(int i, int j, uint16_t mask)\n        {\n            for (int k=0; k<9; k++) {\n                if (k!=j && !addConstraint(i, k, mask)) return false;\n                if (k!=i && !addConstraint(k, j, mask)) return false;\n                int ii = (i/3)*3 + (k/3);\n                int jj = (j/3)*3 + (k%3);\n                if ((i != ii || j != jj) && !addConstraint(ii, jj, mask)) return false;\n            }\n            return true;\n        }\n        \n        // prohibits putting value in mask to the cell (i,j)\n        bool addConstraint(int i, int j, uint16_t mask)\n        {\n            int16_t newMask = board[i][j] &~ mask;\n            if (newMask != board[i][j]) {\n                if (newMask == 0) return false;\n                board[i][j] = newMask;\n                if (((newMask-1)&newMask)==0) {\n                    // good news - we have only one possibility for the cell (i,j)\n                    return propagate(i, j, newMask);\n                }\n            }\n            return true;\n        }\n        \n        // list of cell coordinates with >1 possibilities for values\n        vector<pair<int,int>> v;\n        void solve()\n        {\n            // finding all ambiguous cells\n            for (int i=0; i<9; i++) {\n                for (int j=0; j<9; j++) {\n                    uint16_t mask = board[i][j];\n                    if (mask&(mask-1)) v.push_back(make_pair(i,j));\n                }\n            }\n            // note: it is also a good idea to sort v by the hamming weight, but\n            // without sorting it is still super-fast\n            // running backtracking as is\n            backtrack(0);\n        }\n\n        // backtracking        \n        bool backtrack(int k) {\n            if (k == v.size()) return true;\n            int i = v[k].first;\n            int j = v[k].second;\n            uint16_t mask = board[i][j];\n            if (mask&(mask-1)) {\n                // the board state is so compact and backtracking depth is so shallow, so\n                // it is cheaper to make a snapshot of the state vs. doing classical\n                // undo at each move\n                auto snapshot = board;\n                for (uint16_t cand = 1; cand<=0x1ff; cand = cand <<1) {\n                    if (set(i, j, cand) && backtrack(k+1)) return true;\n                    board = snapshot;\n                }\n                return false;\n            }\n            else {\n                return backtrack(k + 1);\n            }\n        }\n        \n    };\n    \npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n        SudokuSolver solver;\n        for (int i=0; i<9; i++) {\n            for (int j=0; j<9; j++) {\n                char c = board[i][j];\n                if (c != '.' && !solver.add(i,j,c-'0')) return;\n            }\n        }\n        // At this point 9 of 10 sudokus published in magazines will be solved by constraint propagation\n        // only 'hard' sudokus will require some (limited) backtracking \n        solver.solve();\n        for (int i=0; i<9; i++)\n            for (int j=0; j<9; j++)\n                board[i][j] = maskToValue[(solver.board[i][j]%11)-1];\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			13,
			52.5,
			"class Solution {\npublic:\n    bool backtrack(vector<vector<char>>& board, vector<vector<bool>>& used1, vector<vector<bool>>& used2, vector<vector<bool>>& used3){\n        for(int i = 0; i < 9; i++){\n            for(int j = 0; j < 9; j++){\n                if(board[i][j] != '.') continue;\n                for(int k = 0; k < 9; k++){\n                    int box = i / 3 * 3 + j / 3;\n                    if(!used1[i][k] && !used2[j][k] && !used3[box][k]){\n                        board[i][j] = k + '1';\n                        used1[i][k] = used2[j][k] = used3[box][k] = true;\n                        if(backtrack(board, used1, used2, used3)) return true;\n                    }\n                    board[i][j] = '.';\n                    used1[i][k] = used2[j][k] = used3[box][k] = false;\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n        \n    void solveSudoku(vector<vector<char>>& board) {\n        vector<vector<bool>> used1(9, vector<bool>(9, false)); // for rows\n        vector<vector<bool>> used2(9, vector<bool>(9, false)); // for columns\n        vector<vector<bool>> used3(9, vector<bool>(9, false)); // for 3x3 sub-boxes\n        // initialize used arrays according to initial board\n        for(int i = 0; i < 9; i++){\n            for(int j = 0; j < 9; j++){\n                if(board[i][j] != '.'){\n                    int k = board[i][j] - '1', box = i / 3 * 3 + j / 3;\n                    used1[i][k] = used2[j][k] = used3[box][k] = true;\n                }\n            }\n        }   \n        // solve Sudoku\n        backtrack(board, used1, used2, used3);\n    }\n};"
		],
		[
			4296141722.479395,
			1.0,
			12,
			64.1538,
			"class Solution {\npublic:\nbool row[9][9]={}, col[9][9]={}, block[9][9]={};\nvoid solveSudoku(vector<vector<char>>& board) {\n    int num, k;\n    for (int i=0; i<9; i++) {\n        for (int j=0; j<9; j++) {\n            if(board[i][j]!='.') {\n                num = board[i][j]-'1'; \n                k = i/3*3 + j/3;\n                row[i][num] = col[j][num] = block[k][num] = 1;\n            }\n        }\n    }\n    Helper(board, 0);\n}\nbool Helper(vector<vector<char>>& b, int ind){\n    if(ind==81) return true; \n    int i=ind/9, j=ind%9, num, k;\n    if(b[i][j]!='.') return Helper(b, ind+1);\n    else{\n        for(char f='1'; f<='9'; f++){\n            num = f-'1'; \n            k= i/3*3 + j/3;\n            if(!row[i][num] && !col[j][num] && !block[k][num]){\n                b[i][j]= f;\n                row[i][num] = col[j][num] = block[k][num] = 1;\n                if(Helper(b, ind+1)) return true;                \n                b[i][j]='.';\n                row[i][num] = col[j][num] = block[k][num] = 0;\n            }\n        }\n        return false;\n    }\n}\n};"
		],
		[
			1.0,
			1.0,
			20,
			61.8095,
			"class Solution {\npublic:\n    bool isValid(vector<vector<char>>& board, int i, int j){\n        char k = board[i][j];\n        for(int c = 0; c < 9; c++)\n            if(c != j && board[i][c] == k) return false;\n        for(int r = 0; r < 9; r++)\n            if(r != i && board[r][j] == k) return false;\n        for(int r = i / 3 * 3; r < (i / 3 + 1) * 3; r++)\n            for(int c = j / 3 * 3; c < (j / 3 + 1) * 3; c++)\n                if(r != i && c != j && board[r][c] == k) return false;\n        return true;\n        \n    }\n    \n    bool backtrack(vector<vector<char>>& board){\n        for(int i = 0; i < 9; i++){\n            for(int j = 0; j < 9; j++){\n                if(board[i][j] != '.') continue;\n                for(char k = '1'; k <= '9'; k++){\n                    board[i][j] = k;\n                    if(isValid(board, i, j))\n                        if(backtrack(board)) return true;\n                    board[i][j] = '.';\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n        \n    void solveSudoku(vector<vector<char>>& board) {\n        backtrack(board);\n    }\n};"
		],
		[
			4228871780.5873384,
			1.0,
			12,
			40.0645,
			"class Solution {\npublic:\nvoid solveSudoku(vector<vector<char>>& board) {\n    helper(board, 0);\n}\nbool helper(vector<vector<char>>& b, int ind){\n    if(ind==81) return true; \n    int i=ind/9, j=ind%9;\n    if(b[i][j]!='.') return helper(b, ind+1);\n    else{\n        for(char f = '1'; f <= '9'; f++){\n            if(isValidFill(b, i, j, f)){\n                b[i][j]= f;\n                if(helper(b, ind+1)) return true;                \n                b[i][j]='.';\n            }\n        }\n        return false;\n    }\n}\nbool isValidFill(vector<vector<char>>& b, int i, int j, char fill) {\n    for(int k=0; k<9; k++){\n        int r= i/3*3+j/3;   //select the block\n        if(b[i][k]==fill || b[k][j]==fill || b[r/3*3+k/3][r%3*3+k%3]==fill) \n            return false; //check row, column, block\n    }            \n    return true;\n}\n};"
		],
		[
			1.0,
			1.0,
			18,
			44.4324,
			"class Solution {\npublic:\n    int N = 9;\n    bool isSafe(int i, int j, int num, vector<vector<char>>& board){\n        //rows, colm\n        char nn = num + '0';\n        for(int x = 0; x < N; x++){\n            if(board[x][j] == nn || board[i][x] == nn) return false; \n        }   \n        //small box\n        int ss = sqrt(N);\n        int sr = i - i%ss;\n        int sc = j - j%ss; \n        //small box-> i, j\n        for (int y = 0; y < ss; y++){\n            for(int z = 0; z < ss; z++){\n                if(board[y + sr][z + sc] == nn) return false; \n            }\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>>& board){\n        //find first blank space\n        int i, j, flag = 0;\n        for(i = 0; i < N; i++){\n            for(j = 0; j < N; j++){\n                if(board[i][j] == '.'){\n                    flag = 1;\n                    break;}\n            }\n            if(flag) break;\n        }   \n        if(i == N || j == N) return true;    \n        //black space -> [1-9]\n        for(int num = 1; num <= 9; num++){\n            if(isSafe(i, j, num, board)){\n                board[i][j] = '0' + num;\n                if(solve(board)) return true;\n            }\n            board[i][j] = '.';\n        }\n        return false;\n    }\n    \n    void solveSudoku(vector<vector<char>>& board) {\n        solve(board);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			10,
			53.125,
			"class Solution {\npublic:\n    vector<bitset<9>> rm, cm, bm; //bitmasks, row, col, block\n    void solveSudoku(vector<vector<char>>& board) {\n        rm=cm=bm=vector<bitset<9>>(9,bitset<9>(0));\n        vector<pair<pair<int,int>,bitset<9>>> blank; //a list of unfilled slots<<row, col>, bitmask of numbers have been guessed for this slot>\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                if(board[i][j]!='.'){ //update bitmasks by given numbers\n                    int t = board[i][j]-'1';\n                    rm[i].set(t);\n                    cm[j].set(t);\n                    bm[int(i/3)*3+int(j/3)].set(t);\n                }\n                else blank.push_back(make_pair(make_pair(i,j),bitset<9>(0))); //unfilled slots list\n            }\n        }\n        sort(blank.begin(),blank.end(),[this](pair<pair<int,int>, bitset<9>> &a, pair<pair<int,int>,bitset<9>> &b){return (rm[a.first.first]|cm[a.first.second]|bm[a.first.first/3*3+a.first.second/3]).count()>(rm[b.first.first]|cm[b.first.second]|bm[b.first.first/3*3+b.first.second/3]).count();}); //sort the unfilled slots based on the current bitmasks\n        int curr=0, n=blank.size();\n        vector<int> prevind; //backtracking previous guesses and bitmasks \n        vector<vector<bitset<9>>> prevrm;\n        vector<vector<bitset<9>>> prevcm;\n        vector<vector<bitset<9>>> prevbm;\n        while(curr<n){\n            int row=blank[curr].first.first;\n            int col=blank[curr].first.second;\n            int blk=blank[curr].first.first/3*3+blank[curr].first.second/3;\n            bitset<9> currm=rm[row]|cm[col]|bm[blk]|blank[curr].second; //generate the bitmask for candidates\n            //if no candidate left, assume the problem is solvable, there must be a wrong guess happened before and backtrace\n            if(currm.count()==9){\n                while(curr!=prevind.back()){\n                    blank[curr].second.reset();\n                    curr--;\n                }\n                prevind.pop_back();\n                rm=prevrm.back();\n                prevrm.pop_back();\n                cm=prevcm.back();\n                prevcm.pop_back();\n                bm=prevbm.back();\n                prevbm.pop_back();\n            }\n            //otherwise, we make a guess as the first candidate\n            else{\n                int t=0;\n                while(currm.test(t)) t++;\n                currm.set(t);\n                board[row][col]='1'+t;\n                blank[curr].second.set(t);\n                //if there are more candidates, save the current bitmasks and slot index\n                if(currm.count()!=9){\n                    prevind.push_back(curr);\n                    prevrm.push_back(rm);\n                    prevcm.push_back(cm);\n                    prevbm.push_back(bm);\n                }\n                //update bitmasks\n                rm[row].set(t);\n                cm[col].set(t);\n                bm[blk].set(t);\n                //if there are more candidates, we resort the remaining unfilled slots\n                if(currm.count()!=9)\n                sort(blank.begin()+curr+1,blank.end(),[this](pair<pair<int,int>, bitset<9>> &a, pair<pair<int,int>,bitset<9>> &b){return (rm[a.first.first]|cm[a.first.second]|bm[a.first.first/3*3+a.first.second/3]).count()>(rm[b.first.first]|cm[b.first.second]|bm[b.first.first/3*3+b.first.second/3]).count();});\n                curr++;\n            }\n        }\n        return;\n    }\n};"
		],
		[
			1.0,
			1.0,
			17,
			66.7,
			"class Solution {\npublic:\n    void solveSudoku(vector<vector<char>>& board) {\n         helper(board,0,0);\n    }\n    int helper(vector<vector<char>>& board, int row, int col)\n    {\n        if(row==9)\n            return 1;\n        if(board[row][col]!='.')\n        {\n            if(col+1==9)\n            {\n                return helper(board,row+1,0);\n            }\n            else\n            {\n                return helper(board,row,col+1);\n            }\n        }\n        else\n        {\n           for(int i=1;i<=9;i++)\n           {\n               char b=i+'0';\n               if(isvalid(board,row,col,b))\n               {\n                   board[row][col]=b;\n                   int a=0;\n                   if(col+1==9)\n                       a=helper(board,row+1,0);\n                   else\n                       a=helper(board,row,col+1);\n                   if(a==1)\n                       return 1;\n                   board[row][col]='.';\n               }\n           }\n        }\n        return -1;\n    }\n    \n    bool isvalid(vector<vector<char>>& board, int row, int col,char b)\n    {\n        for(int i=0;i<9;i++)\n        {\n            if(board[row][i]==b || board[i][col]==b)\n                return false;\n        }\n        return isvalidgrid(board,row,col,b);\n    }\n    bool isvalidgrid(vector<vector<char>>& board, int row, int col, char b)\n    {\n        int startR=(row/3)*3;\n        int startC=(col/3)*3;\n        \n        for(int i=startR;i<startR+3;i++)\n        {\n            for(int j=startC;j<startC+3;j++)\n            {\n                if(board[i][j]==b)\n                    return false;\n            }\n        }\n        return true;\n    }\n    \n};\n"
		],
		[
			1.0,
			1.0,
			16,
			28.95,
			"class Solution \n{\npublic:\n\tbool isValid(vector<vector<char>>& board, int row , int column, char c) \n\t{\n        //checking all columns in a given ROW\n\t\tfor (int i = 0; i < 9; ++i)\n\t\t\tif (board[row][i] == c) return false;\n        //checking all rows in a given COLUMN\n\t\tfor (int j = 0; j < 9; ++j)\n\t\t\tif (board[j][column] == c) return false;\n        //checking the 3*3 matrix starting from given ROW and COLUMN\n\t\tfor (int i = 0; i < 3; ++i)\n\t\t\tfor (int j = 0; j < 3; ++j)\n\t\t\t\tif (board[row / 3 * 3 + i][column / 3 * 3 + j] == c)\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tbool solve(vector<vector<char>>& board) \n\t{\n        //traversing the given board\n\t\tfor (int i = 0; i < 9; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 9; ++j)\n\t\t\t{\n                //if location is unassigned\n\t\t\t\tif ('.' == board[i][j]) \n\t\t\t\t{\n                    //we can put 1 to 9 at unassigned locatiom\n\t\t\t\t\tfor (int k = 0; k < 9; ++k)\n\t\t\t\t\t{\n                        //checking we can put k or not [ means already present or not]\n\t\t\t\t\t\tif (isValid(board, i, j, '1' + k)) \n\t\t\t\t\t\t{\n                            //adding in a hope to get done\n\t\t\t\t\t\t\tboard[i][j] = '1' + k;\n                            //if solvable. yipieee return 1\n\t\t\t\t\t\t\tif (solve(board)) return true;\n                            //else cry over your choice and trty other option\n\t\t\t\t\t\t\telse board[i][j] = '.';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                    //if we cant assign any number from 1 to 9 at that specified i and j\n                    //location return 0;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\tvoid solveSudoku(vector<vector<char>>& board) \n\t{\n\t\tsolve(board);\n\t}\n};\n"
		],
		[
			1.0,
			1.0,
			19,
			55.2,
			"class Solution {\npublic:\n    bool isSafe(vector<vector<char>>& board, int row, int col, int count)\n    {\n        char c=count+48;\n        //cout<<c<<endl;\n        for(int i=0; i<9; i++)\n        {\n            if(board[i][col]==c) return false;\n        }\n        for(int j=0; j<9; j++)\n        {\n            if(board[row][j]==c) return false;\n        }\n        int br=row/3, bc=col/3;\n        br = br*3;\n        bc = bc*3;\n        int rl=br+3, cl=bc+3;\n        for(int i=br; i<rl; i++)\n        {\n            for(int j=bc; j<cl; j++)\n            {\n                if(board[i][j]==c) return false;\n            }\n        }\n        return true;\n    }\n    bool solve(vector<vector<char>>& board)\n    {\n        int row, col;\n        int k=0, i, j;\n        for(i=0; i<9 && k==0; i++)\n        {\n            for(j=0; j<9; j++)\n            {\n                if(board[i][j]!='.') continue;\n                row=i, col=j;\n                k = 1;\n                break;\n            }\n        }\n        if(i==9 && j==9) return true;\n        for(int count=1; count<=9; count++)\n        {\n            if(isSafe(board, row, col, count))\n            {\n                //cout<<row<<\" \"<<col<<endl;\n                board[row][col] = count+48;\n                if(solve(board)) return true;\n                board[row][col] = '.';\n            }\n        }\n        return false;\n    }\n    void solveSudoku(vector<vector<char>>& board) \n    {\n        solve(board);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			26,
			75.8108,
			"class Solution {\npublic:\nvector<vector<pair<int, int>>> start_pair{ {{0,0},{0,3},{0,6}},\n\t{{3,0},{3,3},{3,6}},\n\t{{6,0},{6,3},{6,6}}};\nvector<vector<pair<int, int>>> end_pair{ {{2,2},{2,5},{2,8}},\n\t{{5,2},{5,5},{5,8} },\n\t{{ 8,2 }, { 8,5 }, {8,8 }} };\n\n\n\nbool checkboard(vector<vector<char>>& board)\n{\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tfor (int j = 0; j < 9; j++)\n\t\t{\n\t\t\tif (board[i][j] == '.')\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nbool CheckHorizontal(vector<vector<char>>& board,int row, int col, char num)\n{\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tif (i != col)\n\t\t{\n\t\t\tif (board[row][i] == num)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool CheckVertical(vector<vector<char>>& board, int row, int col, char num)\n{\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tif (i != row)\n\t\t{\n\t\t\tif (board[i][col] == num)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nbool CheckBox(vector<vector<char>>& board, int row, int  col, char num)\n{\n\tint box_row = row / 3;\n\tint box_col = col / 3;\n\tfor (int i = start_pair[box_row][box_col].first; i <= end_pair[box_row][box_col].first; i++)\n\t{\n\t\tfor (int j = start_pair[box_row][box_col].second; j <= end_pair[box_row][box_col].second; j++)\n\t\t{\n\t\t\tif (board[i][j] == num)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool CheckNum(vector<vector<char>>& board,int row, int col, char num)\n{\n\treturn CheckHorizontal(board, row, col, num) || CheckVertical(board, row, col, num) || CheckBox(board, row, col, num);\n}\n\n\nbool solveSudokuUtil(vector<vector<char>>& board, int idx)\n{\n\tif (idx >= 81)\n\t\treturn true;\n\n\tint row = idx / 9;\n\tint col = idx % 9;\n\tif (board[row][col] != '.')\n\t\treturn solveSudokuUtil(board, idx + 1);\n\n\tchar num;\n\tfor (num = '1'; num <= '9'; num++)\n\t{\n\t\tif (!CheckNum(board,row,col,num))\n\t\t{\n\t\t\tboard[row][col] = num;\n\t\t\tif (solveSudokuUtil(board, idx + 1))\n\t\t\t\treturn true;\n\t\t\tboard[row][col] = '.';\n\t\t}\n\t}\n\n\treturn false;\n}\nvoid solveSudoku(vector<vector<char>>& board) {\n\tsolveSudokuUtil(board, 0);\n}\n};"
		],
		[
			1.0,
			1.0,
			18,
			97.9355,
			"class Solution {\npublic:\nbool row_wise[9][9] = { {false} };\nbool col_wise[9][9] = { {false} };\nbool box_wise[9][9] = { {false} };\n\nbool CheckHorizontal(vector<vector<char>>& board,int row, int col, char num)\n{\n\treturn row_wise[row][num - '0' - 1];\n}\n\nbool CheckVertical(vector<vector<char>>& board, int row, int col, char num)\n{\n\treturn col_wise[col][num - '0' - 1];\n}\nbool CheckBox(vector<vector<char>>& board, int row, int  col, char num)\n{\n\treturn box_wise[(row / 3) * 3 + (col / 3)][num - '0' - 1];\n}\n\nbool CheckNum(vector<vector<char>>& board,int row, int col, char num)\n{\n\treturn CheckHorizontal(board, row, col, num) || CheckVertical(board, row, col, num) || CheckBox(board, row, col, num);\n}\n\nvoid SetBoard(vector<vector<char>>& board, char num,bool b_val,int row,int col)\n{\n\tif (b_val)\n\t\tboard[row][col] = num;\n\telse\n\t\tboard[row][col] = '.';\n\trow_wise[row][num - '0' - 1] = b_val;\n\tcol_wise[col][num - '0' - 1] = b_val;\n\tbox_wise[(row / 3) * 3 + (col / 3)][num - '0' - 1] = b_val;\n}\nbool solveSudokuUtil(vector<vector<char>>& board, int idx)\n{\n\tif (idx >= 81)\n\t\treturn true;\n\n\tint row = idx / 9;\n\tint col = idx % 9;\n\tif (board[row][col] != '.')\n\t\treturn solveSudokuUtil(board, idx + 1);\n\n\tchar num;\n\tfor (num = '1'; num <= '9'; num++)\n\t{\n\t\tif (!CheckNum(board,row,col,num))\n\t\t{\n\t\t\tSetBoard(board, num, true, row, col);\n\t\t\tif (solveSudokuUtil(board, idx + 1))\n\t\t\t\treturn true;\n\t\t\tSetBoard(board, num, false, row, col);\n\t\t}\n\t}\n\n\treturn false;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n\tfor (int i = 0; i < 9; i++)\n\t{\n\t\tfor (int j = 0; j < 9; j++)\n\t\t{\n\t\t\tif (board[i][j] != '.')\n\t\t\t{\n\t\t\t\trow_wise[i][board[i][j] - '0' - 1] = true;\n\t\t\t\tcol_wise[j][board[i][j] - '0' - 1] = true;\n\t\t\t\tbox_wise[(i / 3) * 3 + (j / 3)][board[i][j] - '0' - 1] = true;\n\t\t\t}\n\t\t}\n\t}\n\tsolveSudokuUtil(board, 0);\n}\n};"
		]
	],
	"ROTATE_ARRAY": [
		"n",
		[
			5.2792735327151314,
			4.266807006446483,
			1,
			15.8889,
			"class Solution {\npublic:\n    #include<vector>\n    void rotate(vector<int>& nums, int k) {\n        reverse(nums.begin(),nums.end());                   // reverse the array\n        reverse(nums.begin(),nums.begin()+k%nums.size());  // reverse the first k ele\n        reverse(nums.begin()+k%nums.size(),nums.end());   // reverse the last n-k ele\n    }\n};\n"
		],
		[
			5.506798633152596,
			4.266807006446484,
			1,
			20.1765,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        k=k%n;\n        reverse(nums.end()-k,nums.end()); //reverse nums[n-k] to nums[n-1]\n        reverse(nums.begin(),nums.end()-k); //reverse nums[0] to nums[n-k-1]\n        reverse(nums.begin(),nums.end());  //reverse complete array\n    }\n};\n"
		],
		[
			5.44473897324606,
			4.266807006446484,
			1,
			14.7273,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin()+k);\n        reverse(nums.begin()+k, nums.end());\n    }\n};\n"
		],
		[
			5.283584474377448,
			4.266807006446483,
			4,
			30.7308,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int l = nums.size(), s = 0;\n        while (l-s > 1 && k) {\n            k %= (l-s);\n            for (int i=0; i<k; ++i) {\n                nums[s+i] ^= nums[l-k+i];\n                nums[l-k+i] ^= nums[s+i];\n                nums[s+i] ^= nums[l-k+i];\n            }\n            s += k;\n        }\n    }\n};\n"
		],
		[
			5.163177353301814,
			4.266807006446484,
			4,
			31.2143,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k, int s=0) {\n        int l = nums.size(), tmp;\n        if (l-s <= 1) return;\n        k %= (l-s);\n        for (int i=0; i<k; ++i) {\n            tmp = nums[s+i];\n            nums[s+i] = nums[l-k+i];\n            nums[l-k+i] = tmp;\n        }\n        if (k) rotate(nums, k, s+k);\n    }\n};\n"
		],
		[
			5.149837436953994,
			4.266807006446484,
			2,
			23.275,
			"class Solution {\npublic:\nvoid rotate(vector<int>& nums, int k) {\n        int size;\n        size = nums.size();\n      \n        if(k>size)\n            k = abs(size-k)%size;\n        \n      /*  for(i=0; i<k; i++)\n            nums.emplace(nums.begin(), nums[size-1]);       //emplace is expensive, run time very high\n        nums.resize(size); */\n        \n     /*   for(i=0; i<size-k; i++)\n            nums.push_back(nums[i]);\n        nums.erase(nums.begin(), nums.begin()+size-k); */\n        \n        reverse(nums.begin(), nums.end());      //reverse the whole array\n        reverse(nums.begin(), nums.begin()+k);      //reverse the numbers from beginning to kth position\n        reverse(nums.begin()+k, nums.end());        //reverse the rest of the array to make it original\n    }\n};"
		],
		[
			5.645584574988586,
			13.210180148672098,
			7,
			27.5294,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        vector<int> v;\n        int n = nums.size();\n        \n    \n        if(k==0 || n == 1 ) {\n            return;\n        }\n        \n        if(k >= n) {\n            k = k-n;\n        }\n        \n        for(int j = n-k; j < n; j++) {\n               v.push_back(nums[j]);\n           }\n        \n         for(int z = 0; z < n-k; z++) {\n               v.push_back(nums[z]);\n           }\n        \n      \n        for(int i = 0; i < n; i++) {\n            nums[i] = v[i];\n        }\n    }\n};\n"
		],
		[
			5.4908347403079025,
			4.266807006446484,
			1,
			18.9091,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        k=nums.size()-k;\n        reverse((nums.begin()),(nums.begin()+k));\n        reverse((nums.begin()+k),nums.end());\n        reverse(nums.begin(),nums.end());\n    }\n};\n"
		],
		[
			5.194230157816946,
			4.762282179025152,
			4,
			19.125,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        if(k%nums.size() && nums.size()>1 ){\n            int t = nums.size()-k%nums.size();\n            for(int i= 0;i<t;i++){\n                nums.push_back(nums[i]);\n            }\n            nums.erase(nums.begin(),nums.begin() + t);\n        }\n    }\n};\n"
		],
		[
			15.500666447281912,
			14.175794646214465,
			5,
			19.5,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        if(k>n) k-=n;\n        if(n==k||!k) return;\n        reverse(nums.begin(),nums.end());\n        int i=0;\n        while(i!=k)\n            nums.push_back(nums[i++]);\n        reverse(nums.begin(),nums.end());\n        nums.resize(n);\n    }\n};\n"
		],
		[
			4.968256676700657,
			4.266807006446483,
			3,
			24.3243,
			"class Solution {\npublic:\n    //function to reverse the array\n    void reversearray(vector<int>& nums,int start,int end){\n        while(start<end){\n            swap(nums[start], nums[end]);  //using c++ stl swap function\n            start++;end--;\n        }\n    }\n    \n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        k=k%n;  //for excessive repetition of rotations\n\t\t\n\t\t/*the order of the function called below is for right rotation of array,in case of left rotation use like:\n\t\t reversearray(nums,0,k-1);\n        reversearray(nums,k,n-1);\n        reversearray(nums,0,n-1);\n\t\t*/\n        reversearray(nums,0,n-1);\n        reversearray(nums,0,k-1);\n        reversearray(nums,k,n-1);\n    } \n};\n"
		],
		[
			5.174619755885948,
			4.266807006446483,
			1,
			15.2727,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k = k % nums.size();\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};"
		],
		[
			4.9787046782481355,
			4.266807006446484,
			3,
			22.4,
			"class Solution {\npublic:\n    void rev(vector<int> &nums,int st,int en){\n        while(st<en){\n            swap(nums[st],nums[en]);\n            st++;\n            en--;\n        }\n    }\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        k%=n;\n        rev(nums,0,n-1);\n        rev(nums,0,k-1);\n        rev(nums,k,n-1);\n    }\n};\n"
		],
		[
			5.129403335041062,
			4.266807006446483,
			1,
			17.5,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k=k%nums.size();\n        int l=nums.size()-k;\n        //cout<<l<<endl;\n        reverse(nums.begin(),nums.begin()+l);\n        reverse(nums.begin()+l,nums.end());\n        reverse(nums.begin(),nums.end());\n    }\n};\n\n"
		],
		[
			5.976579875048925,
			4.266807006446484,
			3,
			18.2143,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int temp;\n        int n=nums.size();\n        for(int i=0;i<k;i++)\n        {\n            temp=nums[n-1];\n            for(int j=n-1;j>0;j--)\n            {\n                nums[j]=nums[j-1];\n            }\n            nums[0]=temp;\n        }\n    }\n};\n"
		],
		[
			4.716231865308725,
			4.573060828157954,
			1,
			14.0,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        vector<int> result(nums.end()-k,nums.end());\n        result.insert(result.end(),nums.begin(),nums.end()-k);\n        nums = result;\n    }\n};\n"
		],
		[
			5.743715759612233,
			4.266807006446484,
			3,
			21.4615,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        while(k--){\n            int temp = nums[nums.size()-1];\n            for(int i = nums.size()-2; i>= 0 ;i--){\n                nums[i+1] = nums[i];\n            }\n            nums[0] = temp;\n        }   \n    }\n};\n"
		],
		[
			4.8555441806087325,
			4.762293364564699,
			3,
			27.5625,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int orig_size = nums.size();\n        k %= orig_size;\n        nums.insert(nums.end(),nums.end()-k,nums.end());\n        int i=orig_size - k - 1, j = orig_size - 1;\n        while(j >= 0){\n            nums[j--] = nums[i--];\n            if(i == -1){\n                i = nums.size()-1;\n            }\n        }\n        nums.resize(orig_size, 0);\n    }\n};\n"
		],
		[
			4.946372914268111,
			4.573050519273264,
			2,
			16.875,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int sz = nums.size();\n        vector<int> result(sz,0);\n        for(int i=0;i<sz;i++){\n            result[(i + k)%sz] = nums[i];\n        }\n        nums = result;\n    }\n};\n"
		],
		[
			5.128648936205109,
			4.266807006446484,
			1,
			14.7273,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        reverse(nums.begin(),nums.end());\n        reverse(nums.begin(),nums.begin()+k);\n        reverse(nums.begin()+k,nums.end());\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			23.5,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k %= n;\n        for(int i=0;i<gcd(n,k);i++){\n            int prev = i, next = (prev+k)%n;\n            int temp = nums[i];\n            while(next != i){\n                int temp2 = nums[next];\n                nums[next] = temp;\n                temp = temp2;\n                prev = next;\n                next = (prev+k)%n;\n            }\n            nums[next] = temp;\n        }\n    }\n};\n"
		],
		[
			4.69535183611816,
			4.2668200077420035,
			4,
			29.1429,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k = k%nums.size();\n        vector<int>temp;\n        for(int i=nums.size()-k;i<nums.size();i++){\n            temp.push_back(nums[i]);\n        }\n        for(int i=nums.size()-1;i-k>=0;i--){\n            nums[i]=nums[i-k];\n        }\n        for(int i=0;i<k;i++){\n            nums[i]=temp[i];\n        }\n    }\n};\n"
		],
		[
			5.119440763041656,
			4.266807006446483,
			1,
			14.0,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        \n        int m = k%nums.size();\n        \n        reverse(nums.begin(), nums.end());\n        \n        reverse(nums.begin()+m, nums.end());\n        \n        reverse(nums.begin(), nums.begin()+m);\n    }\n};\n"
		],
		[
			5.116078490519712,
			4.266807006446484,
			2,
			20.1923,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        k=k%n;\n        k=n-k;\n        if(k<0) return;\n        reverse(nums.begin(),nums.begin()+k);\n        reverse(nums.begin()+k,nums.end());\n        reverse(nums.begin(),nums.end());\n    }\n};\n"
		],
		[
			4.74506354102742,
			4.266807006446484,
			5,
			25.4545,
			"// ====================================================\n// https://jasonchiucc.com/leetcode-189-rotate-array/ \n// ====================================================\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        if (nums.empty() || (k %= nums.size()) == 0) return;\n        int start = 0, idx = 0, pre = 0, cur = nums[0], n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            pre = cur;\n            idx = (idx + k) % n;\n            cur = nums[idx];\n            nums[idx] = pre;\n            if (idx == start) {\n                idx = ++start;\n                cur = nums[idx];\n            }\n        }\n    }\n};\n"
		],
		[
			5.48291044760449,
			4.266807006446484,
			5,
			21.0476,
			"class Solution {\npublic:\n    void rotate(vector<int>& a, int k) {\n        if(a.size()<k) k=k-a.size(); // In case If K is much bigger than a.size() .\n\t\t\n\t\t\n        if(a.size()==0 || a.size()==1 || a.size()==-1) return;\n        std::reverse(a.begin(),a.end());\n        std::reverse(a.begin(),a.begin()+k);\n        std::reverse(a.begin()+k,a.end());\n      \n    \n    }\n};\n"
		],
		[
			4.98681125947085,
			4.266807006446483,
			6,
			39.0476,
			"class Solution {\npublic:\n    void rev(vector<int>& nums, int l, int r) {\n        while(l <= r) {\n            swap(nums[l], nums[r]);\n            l++; r--;\n        } \n    }\n    \n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k = k%n;\n        \n        int idx = 0, flag = 0;\n        \n\t\t// by symmetry\n        if(k > n/2) {\n            rev(nums, 0, n-1);\n            k = n-k;\n            flag = 1;\n        }\n        \n        for(int i=n-k;i<n;i++) {\n            swap(nums[i], nums[idx]);\n            idx++;\n        }\n\n        rev(nums, k, n-k-1);\n        rev(nums, n-k, n-1);\n        rev(nums, k, n-1);\n\n        if(flag) rev(nums, 0, n-1);\n        \n    }\n};\n"
		],
		[
			4.959377822681386,
			4.266807006446484,
			3,
			25.5,
			"class Solution {\npublic:\n    void rev(vector<int>& nums, int l, int r) {\n        while(l <= r) {\n            swap(nums[l], nums[r]);\n            l++; r--;\n        } \n    }\n    \n    void rotate(vector<int>& nums, int k) {\n        int n = nums.size();\n        k = k%n;\n        \n        rev(nums, 0, n-k-1);\n        rev(nums, n-k, n-1);\n        rev(nums, 0, n-1);   \n    }\n};\n"
		],
		[
			4.704474610324024,
			4.762282179025152,
			2,
			14.5,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        while(k > nums.size()) k -= nums.size();\n        nums.insert(nums.begin(), nums.end() - k, nums.end());\n        nums.erase(nums.end() - k, nums.end());\n    }\n};\n"
		],
		[
			5.3233366160356725,
			4.266807006446484,
			3,
			23.375,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        int baseIndex = 0;\n        while (k)\n        {\n            for (int j = 0; j < k; j++)\n                swap(nums[baseIndex + j], nums[nums.size() - k + j]);\n            baseIndex += k;            \n            k %= nums.size() - baseIndex;\n        }\n    }\n};\n"
		],
		[
			4.860618412210035,
			4.266807006446483,
			5,
			32.9333,
			"class Solution {\npublic:\n    void reverse(vector<int>& nums,int start,int end){\n        while(start<end){\n            int temp= nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++; end--;\n        }\n    }\n    \n    void rotate(vector<int>& nums, int k) {\n        int n= nums.size();\n        if(k==0 || k== n)\n            return;    \n        \n        k=k%n;\n        reverse(nums,0,n-1);\n        reverse(nums,0,k-1);\n        reverse(nums,k,n-1);\n    }\n};\n"
		],
		[
			5.120750414992877,
			4.266807006446483,
			1,
			17.3333,
			"class Solution {\npublic:\n    void rotate(vector<int>& a, int k) {\n        int n = a.size();\n        k = k%n;\n        reverse(a.begin(),a.begin()+n-k);\n        reverse(a.begin()+n-k,a.end());\n        reverse(a.begin(),a.end());\n    }\n};\n"
		],
		[
			6.35956560868015,
			4.267002449343615,
			5,
			34.86,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        /*\n        if(nums.size()==1){\n             for(auto vec:nums) cout<<vec<<\" \";\n            cout<<endl;\n            return;\n        }\n        */\n        if(nums.size()<k){\n            while(k){\n                int pos=nums.size()-1;\n                int val=nums[pos];\n                nums.erase(nums.begin()+pos);\n                nums.insert(nums.begin()+0,val);\n                k--;\n            }\n            /*\n            for(auto vec:nums) cout<<vec<<\" \";\n            cout<<endl;\n            */\n            return;\n        }\n        queue<int> pq;\n        while(pq.size()<k){\n            int pos=nums.size()-1;\n            pq.push(nums[pos]);\n            nums.erase(nums.begin()+pos);\n        }\n        while(!pq.empty()){\n            nums.insert(nums.begin()+0,pq.front());\n            pq.pop();\n        }\n        /*\n        for(auto vec:nums) cout<<vec<<\" \";\n        cout<<endl;\n        */\n    }\n};\n"
		],
		[
			4.965085917613816,
			4.266807006446484,
			3,
			21.8667,
			"class Solution {\npublic:\n    void reverse(vector<int>& nums, int i, int j) {while(i<j) swap(nums[i++], nums[j--]);}\n    \n    void rotate(vector<int>& nums, int k) {      \n        int n= nums.size();\n        k= k%n;\n        reverse(nums, 0, n-1);\n        reverse(nums, 0, k-1);\n        reverse(nums, k, n-1);\n    }\n};"
		],
		[
			5.061368546664097,
			4.266807006446484,
			3,
			23.375,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        k %= nums.size();\n        int baseIndex = 0;\n        while (k)\n        {\n            for (int j = 0; j < k; j++)\n                swap(nums[baseIndex + j], nums[nums.size() - k + j]);\n            baseIndex += k;            \n            k %= nums.size() - baseIndex;\n        }\n    }\n};\n"
		],
		[
			5.039747756062059,
			4.266807006446484,
			5,
			40.7143,
			"class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        if(k>n)\n        {\n            k = k%n;\n        }\n        int i=0,j=n-k-1;\n        while(i<j)\n        {\n            swap(nums[i],nums[j]);\n            i++;\n            j--;\n        }\n        i=n-k,j=n-1;\n        while(i<j)\n        {\n            swap(nums[i],nums[j]);\n            i++;\n            j--;\n        }\n        i=0,j=n-1;\n        while(i<j)\n        {\n            swap(nums[i],nums[j]);\n            i++;\n            j--;\n        }\n        // return nums;\n    }\n};\n"
		]
	],
	"POW": [
		"n",
		[
			6.586498539404165,
			1.0,
			1,
			6.0,
			"class Solution {\npublic:\n    double myPow(double x,long long int n) {\n        return pow(x,n);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			32.0,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n>0) return posPow(x,n) ;\n        return negPow(x,-1LL*n);\n    }\n    \n    double posPow(double x, int n){\n        if(!n)return 1.00;  \n        double res = posPow(x,n/2) ;\n        res = res*res ;\n        if(n&1) res*= x ;\n        return res ;\n    }\n    \n    double negPow(double x, long long int n){\n        if(!n) return 1.00 ;        \n        double res = negPow(x,n/2) ;\n        res = res*res ;\n        if(n&1) res/=x ;\n        return res ;\n    }\n};\n"
		],
		[
			5.221983146004064,
			1.0,
			8,
			34.0,
			"class Solution {\npublic:\n    double calPow(double x, int n) {\n        if(n==0) return 1;\n        \n        if(n%2==0){\n            double y = calPow(x,n/2);\n            return y*y;\n        }\n        else{\n            double y = calPow(x,(n-1)/2);\n            return y*y*x;\n        }\n    }\n    \n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        if(x==0) return 0;\n        \n        if(n<0) {\n            if(n==INT_MIN)\n                return 1/x*calPow(1/x,INT_MAX);\n            else\n                return calPow(1/x,abs(n));\n        }\n        else return calPow(x,n);\n    }\n};\n"
		],
		[
			5.768450477494363,
			1.0,
			9,
			25.2561,
			"class Solution\n{\npublic:\n\t   double pow(double x, int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif (n % 2 == 1)\n\t\t{\n\t\t\treturn x * pow(x * x, n / 2);\n\t\t}\n\t\treturn pow(x * x, n / 2); \n\t\t// 2^4 = 2^2 * 2^2 == 4^2 this logic is used here. so using the recursion it the stack will reach upto eight of logn only.\n\t}\n\tdouble pow2(double x, int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t\tif (n % 2 == -1)\n\t\t{\n\t\t\treturn pow2(x * x, n / 2) / x;\n\t\t}\n\t\treturn pow2(x * x, n / 2);\n\t}\n\tdouble myPow(double x, int n)\n\t{\n\t\tif (n == 0)\n\t\t{\n\t\t\treturn 1.00000;\n\t\t}\n\n\t\tios::sync_with_stdio(0);\n\t\tios::sync_with_stdio(0);\n\t\tcin.tie(0);\n\t\tcout.tie(0);\n\t\tcout << fixed;\n\t\tcout << setprecision(5);\n\n\t\tdouble res;\n\n\t\tif (n > 0)\n\t\t{\n\t\t\tres = pow(x, n);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = pow2(x, n);\n\t\t}\n\n\t\treturn res;\n\t}\n};\n"
		],
		[
			192.9982375345787,
			1.0,
			4,
			24.0,
			"class Solution {\npublic:\n    double myPow(double x, int y)\n    {\n        double temp;  \n    if(y == 0)  \n        return 1;  \n    temp = myPow(x, y / 2);  \n    if (y % 2 == 0)  \n        return temp * temp;  \n    else\n    {  \n        if(y > 0)  \n            return x * temp * temp;  \n        else\n            return (temp * temp) / x;  \n    }  \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			26.4444,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n    double temp;\n    if(n==0){\n        return 1;\n    }\n    temp = myPow(x, n/2);\n    if(n%2==0.0){\n        return temp*temp; \n    }\n    else {\n        if(n>0){\n            return x*temp*temp;\n        }\n        else {\n            return temp*temp/x;\n        }\n    }\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.1111,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n   \n        if(n == 0) {return 1;}\n         double temp = myPow(x,n/2);\n        if(n % 2 == 0)\n        {\n            return temp * temp;\n        }\n        else\n        {\n            if(n > 0)\n            {\n                return temp * temp * x;\n            }\n            else\n            {\n                return temp*temp / x;\n            }\n        }\n    }\n};\n"
		],
		[
			6.458041930781177,
			1.0,
			4,
			18.5294,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        unsigned int exp = abs( static_cast<long>( n ) );\n        double retVal = 1.0;\n        \n        double pow = x;\n        while( exp > 0 ) {\n            if( exp & 0x1 ) retVal *= pow;\n            exp = exp >> 1;\n            pow *= pow;\n        }\n        \n        return n > 0 ? retVal : 1.0 / retVal;\n    }   \n};\n\n// Runtime: 0 ms, faster than 100.00% of C++ online submissions for Pow(x, n).\n// Memory Usage: 5.9 MB, less than 66.73% of C++ online submissions for Pow(x, n).\n"
		],
		[
			6.912183351754671,
			1.0,
			6,
			26.6667,
			"class Solution {\npublic:\n    double go(double a, long long b){\n        if(b==1) return a;\n        if(b==0) return 1;\n        if(b<0) return go(1/a, -1*b);\n        if(b&1) return a*go(a,b-1);\n        return go(a*a,b/2);\n    }\n    double myPow(double x, int n) {\n        double ans=1;\n        ans= go(x,n);\n        return ans;\n    }\n};\n"
		],
		[
			5.41547921358156,
			1.0,
			4,
			29.2778,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        long n2 = (long)n;\n        if (n2 < 0) {n2 = -n2; x = 1/x;}\n        if (n2 == 0)\n            return 1;\n        return (n2 % 2 == 0) ? myPow(x*x, n2/2) :  myPow(x*x, n2/2)*x;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			20.4545,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        double res=1;\n        bool f=0;\n        if(n<0)\n            f=1;\n        while(n)\n        {\n            if(n%2)\n                res=res*x;\n            x=x*x;\n            n=n/2;\n        }\n        if(f)\n            return 1/res;\n        return res;\n    }\n};\n"
		],
		[
			5.965261357881221,
			1.0,
			6,
			28.9,
			"class Solution \n{\npublic:\n    double helper(double x,long int n)\n    {\n        if(n==0)\n        {\n            return 1;\n        }\n        if(n==1)\n        {\n            return x;\n        }\n        if(n<0)\n        {\n            return helper(1/x,-n);\n        }\n        double result=helper(x*x,n/2);\n        if(n%2)\n        {\n            result*=x;\n        }\n        return result;\n    }\n    double myPow(double x, int n) \n    {\n        return helper(x,n);\n    }\n};\n"
		],
		[
			5.327962521727577,
			1.0,
			6,
			18.5185,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n       double res = 1.0;\n       \n       // Corner case.\n       if(x == 0)\n           return res;\n       \n       bool isNeg = n < 0 ? true : false;\n       long N = abs(n); // Use long to prevent overflow when n = INT_MIN because we divide n by half.\n       \n       while(N){\n           if(N & 1)\n               res = isNeg ? res / x : res * x;\n           x = x * x;\n           N >>= 1;\n       }\n       \n       return res;\n   }\n};"
		],
		[
			6.671977431389468,
			1.0,
			4,
			24.0,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n==0) return 1;\n        \n        double y = myPow(x,n/2);\n        if(n%2==0){\n            \n            return y*y;\n            \n        }\n        else{\n            return n < 0 ? 1/x*y*y : x*y*y; \n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.4091,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        bool flag = n < 0;\n        double res = 1;\n        while (n != 0)\n        {\n        if (n % 2)\n            res = res * x;\n        x = x * x;\n        n /= 2;\n            \n        }\n        return flag ?1/res:res; \n    }\n    \n};\n"
		],
		[
			5.996096724096273,
			1.0,
			7,
			37.6364,
			"class Solution {\npublic:\ndouble solve(double x,long n) {\n        if(n==0) return 1.0;\n        if(n==1) return x;\n        if(n%2==0) return solve(x*x,n/2);\n        return x*solve(x*x,(n-1)/2);\n    }\n    double myPow(double x, int n) {\n        long nn=n;\n        if(n<0) nn=-nn;\n        double ans=solve(x,nn);\n        if(n<0) return 1.0/ans;\n        return ans;\n    }\n};"
		],
		[
			55.1758351221242,
			1.0,
			5,
			24.0,
			"class Solution {\npublic:\n    double thisPow(double x, int n) {\n       if(n == 0) return 1; \n       double temp = thisPow(x,n/2); \n       temp *= temp;\n       if(n%2) temp *= x; \n       return temp;\n    }\n    double myPow(double x, int n) {\n        return n < 0 ? (1/thisPow(x,n)):thisPow(x,n); \n    }\n    \n};\n"
		],
		[
			5.3742606834636675,
			1.0,
			5,
			24.2778,
			"class Solution {\npublic:\n    double myPow(double x,long long int n) {\n        double ans=1.00;\n        bool n_pos=true;\n        if(n<0)\n        {\n            n_pos=false;\n            n*=-1;\n        }\n        while(n)\n        {\n            if(n&1) ans*=x;         // if n is odd  \n            n>>=1;                    // n=n/2\n            x*=x;\n        }\n\t\tif(n_pos)                        // if n is positive\n            return ans;\n\t\treturn (1.0/ans);           // if n is  negative \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			22.6154,
			"class Solution {\npublic:\n    double myPow(double x, int n) \n    {\n        // .. corner case\n        if(n == 0)\n        {\n            return 1;\n        }\n        // .. just to quickly return\n        if(x == 1)\n        {\n            return 1;\n        }\n        \n        // For all other cases\n        \n        double result = 1;\n        \n        // Administration data to fast forward the calculation by reducing the required number of iterations by half.\n        double inc = x;\n        unsigned int inc_counter = 1;\n        \n        unsigned int n_t = std::abs(n);\n        while(n_t > 0)\n        {\n            if(n_t < inc_counter)\n            {\n                inc = x;\n                inc_counter = 1;\n            }\n            \n            result *= inc;\n            n_t -= inc_counter;\n            \n            inc *= inc;\n            inc_counter+=inc_counter;\n        }\n        \n        // final result based on sign(n)\n        return (n > 0) ? result : 1/result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			24.1111,
			"class Solution\n{\n    public:\n        double myPow(double x, int n)\n        {\n            if (n == 0)  { return 1; }\n            if (n == 1)  { return x; }\n            if (n == -1) { return 1/x; }\n            \n            double res(myPow(x, n/2));\n            return n & 1 ? (n < 0 ? 1/x : x) * res * res : res * res;\n        }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			22.117,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        if (n < 0) x = (double)1.0 / x;\n        long current_power = 1, required_power = abs(n);\n        double val = x;\n\t\t// keep squaring value till the current power is less than n, e.g. if n=28\n\t\t// x^1 -> x^2 -> x^4 -> x^8 -> x^16 (can't square it further, as 32>28)\n\t\t// since val=x^16 now, calculate x^12 in another recursive call & mult with val to get x^28\n\t\t// hence, return val * myPow(x, 28 - 16)\n        while (current_power * 2 <= required_power) {\n            val *= val;\n            current_power *= 2;\n        }\n        return val * myPow(x, required_power - current_power);\n    }\n};"
		],
		[
			6.569971240228749,
			1.0,
			5,
			29.3636,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        double ans=1,k=0;\n        long n1=n;\n        if(n1<0){\n            k=1;\n            n1=-n1;\n        } \n        while(n1>=1){\n            if(n1%2!=0)\n                ans*=x;\n            x*=x;\n            n1=n1/2;\n        }\n        if(k==1)\n            return (1/ans);\n        return ans;\n    }\n};\n"
		],
		[
			6.4788505790228985,
			1.0,
			5,
			28.8,
			"class Solution {\npublic:\n\tdouble myPow(double x, int n) {\n\t\tif ( n == 0 ) return 1;\n\t\tif ( n == INT_MIN ) return myPow( x * x, n / 2);\n\t\tif (n < 0 )\n\t\t{\n\t\t\tx = 1 / x;\n\t\t\tn = -n;\n\t\t}\n\t\treturn n % 2 ? myPow( x * x, n / 2) * x : myPow( x * x, n / 2 );\n\t}\n};"
		],
		[
			8.673415413215253,
			1.0,
			4,
			26.35,
			"class Solution {\npublic:\n    double myPow(double x, long long n) {\n        if (n >= 0) {\n            if (n == 0)\n                return 1;\n            double half_power = myPow(x, n/2);\n            if (n % 2) {\n                return half_power * half_power * x;\n            } else {\n                return half_power * half_power;\n            }\n        } else {\n            return 1 / myPow(x, -n);\n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			5.33333,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\nreturn pow(x,n);\n\n}\n};"
		],
		[
			6.554520469785053,
			1.0,
			7,
			24.5455,
			"/*\n    https://leetcode.com/problems/powx-n/\n    TC: O(log2n)\n*/\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        // base case\n        // +ve power\n        if(n == 0 || n == 1)\n            return n == 0 ? 1 : x;\n        // -ve power\n        if(n == -1)\n            return 1 / x;\n        \n        double power = myPow(x, n/2);\n        // if power n is even\n        if(n % 2 == 0)\n            return power * power;\n        // odd power\n        else {\n            return power * power * (n < 0 ? (1 / x) : x);\n        }\n    }\n};\n"
		],
		[
			6.087125426465262,
			1.0,
			5,
			24.5455,
			"class Solution {\npublic:\n    double myPow(double x, long long n) {\n        if(n == 0) return 1;\n\n        double result = 1;\n        long long tmp = abs(n);\n        while(tmp) {\n            if(tmp % 2 == 1) {\n                result *= x;\n                tmp -= 1;\n            } else {\n                x *= x;\n                tmp /= 2;\n            }\n        }\n        return (n > 0)? result: 1/result;\n    }\n};\n"
		],
		[
			6.791099925805276,
			1.0,
			6,
			25.5,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        long time=2;\n        long nn=n;\n        nn=nn<0?-nn:nn;\n        double res=n<0?1/x:x;\n        double ans=nn&1?res:1;\n        while(time<=nn){\n            res*=res;\n            if(nn&time)ans*=res;\n            time<<=1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			25.5,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        long time=2;\n        long nn=n;\n        nn=nn<0?-nn:nn;\n        double res=n<0?1/x:x;\n        double ans=nn&1?res:1;\n        while(time<=nn){\n            res*=res;\n            if(nn&time)ans*=res;\n            time<<=1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			20.25,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n\treturn n == 0 ? 1 : n == 1 ? x : n == -1 ? 1 / x : (n & 1) ? x * myPow(x, n - 1) : myPow(x * x, n / 2);\n}\n};"
		],
		[
			7.019170954743179,
			1.0,
			6,
			25.2,
			"class Solution {\npublic:\ndouble myPow(double x, int n)\n{\n\tunsigned int m = (n > 0)?n:-n;\n\n\tfor(double res = double(1);; x *= x)\n\t{\n\t\tif((m & 1) != 0)\n\t\t{\n\t\t\tres *= x;\n\t\t}\n\t\tif((m >>= 1) == 0)\n\t\t{\n\t\t\treturn (n < 0?double(1) / res:res);\n\t\t}\n\t}\n\n}\n};"
		],
		[
			5.451336359020158,
			1.0,
			4,
			19.25,
			"class Solution {\npublic:\n\n    void calcPower(double x, int n, double& acm){\n        if(n!=0){\n            acm *= x;\n            return calcPower(x,(n-1), acm);\n        }\n    }\n    double myPow(double x, int n) {\n        \n        double acm = 1;\n        \n        calcPower(x,abs(n),acm);\n        \n        double pow = ((n>=0)?acm: 1/acm);\n        \n        return pow;\n    }\n};"
		],
		[
			7.793450728864129,
			1.0,
			1,
			5.83333,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\nreturn pow(x,n); // I used power fxn library formula\n}\n};"
		],
		[
			3.8538833655060003,
			1.0,
			5,
			30.1875,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n        // T = O(log2(N)) & S = O(1)\n        double ans = 1.00000;\n       long long int a = n;\n        if(n < 0) a = -1*a;\n        while(a > 0) {\n            if(a % 2 == 1) {\n                ans = ans*x;\n                a = a-1;\n            } else {\n                x = x*x;\n                a = a/2;\n            }\n        }\n        if(n < 0) ans = (double)1.00000/(double)ans;\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.2,
			"class Solution {\npublic:\ndouble myPow(double x, int n) \n{\n\tauto out{1.0};\n\tfor( ; n; out *= n&1 ? (n>0 ? x : 1.0/x) : 1.0, x *= x, n/=2);\n    return out;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			26.7188,
			"class Solution {\npublic:\ndouble myPow(double x,long long int n) {\nif(n==0)\n{ return 1;\n}\ndouble ans=1.00;\nbool n_positive=true;\nif(n<0)\n{\nn_positive=false;\nn*=-1;\n}\nwhile(n)\n{\nif(n%2==1) ans*=x;\nn=n/2;\nx*=x;\n}\nif(n_positive) // if n is positive\nreturn ans;\nreturn (1.0/ans); // if n is negative\n}\n};"
		],
		[
			6.637950424489542,
			1.0,
			6,
			25.8333,
			"class Solution {\npublic:\n\ndouble myPow(double x, int n) {\n   \n    if(n == 0) return 1;\n    if(n == 1) return x;\n    if(n == -1) return 1/x;\n    \n    double res = myPow(x , n/2);\n    return (n & 1) ? (n < 0 ? 1/x : x) * res * res : res * res;\n    \n   \n}\n};"
		],
		[
			6.985140299413437,
			1.0,
			4,
			19.1667,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        double res = 1;\n        while (n) {\n            if (n % 2) res = n > 0 ? res * x : res / x;\n            x = x * x;\n            n /= 2;\n        }\n        return res;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			16.6111,
			"class Solution {\npublic:\n    double myPow(double x, int n, double res = 1) {\n        return n ? myPow(x * x, n / 2, n % 2 ? (n > 0 ? res * x : res / x) : res) : res;\n    }\n};"
		],
		[
			1.0,
			1.0,
			8,
			21.4145,
			"class Solution {\npublic:\n\n    double myPow(double x, int n) {\n        // If the power is zero, then no need to proceed.\n\t\tif(n==0){\n            return 1;\n        }\n        double t=1,y=x;\n\t\t\n\t\t//Keep in mind the limit of int data type. If its exceeding the range, return 0;\n        if(n==-2147483648){\n            if(x==1){\n                return 1;\n            }\n            else if(x==-1){\n                return 1;\n            }\n            return 0;\n        }\n\t\t\n\t\t//Keep the absolute power stored in the variable\n        int ti=abs(n);\n        \n\t\t/* Now this step is easy. All you have to do is square the y part, and divide the power by half.\n\t\tDo this while the power is greater than 1. If the power is even, divide by 2. Else reduce it by one and multiply \n\t\tthe remaining integer in any other variable, as Explained above.*/\n        while(ti>1){\n            if(ti%2==0){\n                y*=y;\n                ti/=2;\n            }\n            else{\n                t*=y;\n                ti-=1;\n            }\n        }\n\t\t\n\t\t//Multiply the storing part with the answer.\n        y*=t;\n\t\t//Check if n is positive or negative. If negative, then we need to divide it by 1.\n        if(n < 0){\n            return 1/y;\n        }\n\t\t//Return the Answer\n        return y;\n    }\n};"
		],
		[
			63.610763320533074,
			1.0,
			4,
			18.0,
			"class Solution {\npublic:\ndouble myPow(double x, int n) \n{\n\tauto out{1.0};\n\tfor( ; n; n/=2)\n    {\n\t\tif(n&1) out *= n>0 ? x : 1.0/x;\n        x *= x;\n    }\n\t\n    return out;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			23.8,
			"class Solution {\npublic:\ndouble square(double x)\n{\n    return x*x;\n}\n\ndouble myPow(double x, int n) \n{\n\tif(n<0)\n\t\tif(n!=INT_MIN)\n\t\t{\n\t\t   x = 1.0/x;\n\t\t   n = -n;\n\t\t}\n\t\telse\n\t\t\treturn square(myPow(x, n/2));\n\t\t\n\tauto out{1.0};        \n\tfor(int m{1<<30}; m; m/=2)\n\t{\n\t\tout *= out;                \n\t\tif(m&n) out *= x;\n\t}\n\n\treturn out;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			24.0,
			"class Solution\n{\npublic:\n    double myPow(double x, int n)\n    {\n        double result;\n        if (n == 0)\n        {\n            return 1;\n        }\n        result = myPow(x, n / 2);\n        if (n % 2 == 0)\n        {\n            return result * result;\n        }\n        else {\n            return n > 0 ? x * result * result  : result * result / x;\n        }\n    }\n};\n\n"
		],
		[
			5.936960385920316,
			1.0,
			4,
			29.0,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if(n == 0)  return 1;\n        if(n % 2) {\n            if(n < 0)   return myPow(x, n+1) / x;\n            else    return myPow(x, n-1) * x;\n        }\n        \n        double next = myPow(x, n/2);\n        return next*next;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			24.0,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {\n    double t;\n    if(n == 0){\n        return 1;\n    }\n    t = myPow(x, n/2);\n    if(n % 2 == 0){\n        return t * t; \n    }\n    else{\n        if(n > 0){\n            return x * t * t;\n        }\n        else {\n            return t * t / x;\n        }\n    }        \n}\n};\n"
		],
		[
			6.320145568643188,
			1.0,
			5,
			29.2917,
			"class Solution {\npublic:\n    double myPow(double x, int n) {\n        \n        long long nn=n;\n        if (nn<0){\n            nn=-1*nn;\n        }\n        \n        double ans=1.0;\n        while(nn){\n            \n            //odd\n            if(nn%2){\n                \n                ans*=x;\n                nn=nn-1;\n                \n            }else{\n                //even\n                nn=nn/2;\n                x=x*x;\n            }\n        }\n        \n        if(n<0){\n            return (double)1.0/(double) ans;\n        }\n        return ans;\n        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			25.6,
			"class Solution {\npublic:\ndouble myPow(double x, int n) {        \n\tif(n==0) return 1;\n\tif(n<0 && n != INT_MIN)\n\t{\n\t\tn = -n;\n\t\tx = 1/x;\n\t}\n\n\treturn n%2==0 ? myPow(x*x, n/2) : x * myPow(x*x, n/2);\n }\n};"
		]
	],
	"SQRT": [
		"1",
		[
			1.0,
			1.0,
			6,
			26.9091,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1)\n            return x;\n        int ans;\n        int start =1;\n        int end =x;\n        while(start<=end){\n            int mid = start + (end-start)/2;\n            \n            if(mid == x/mid)\n                return mid;\n            else if( mid < x/mid){\n                ans = mid;\n                start = mid+1;\n            }\n            else\n                end = mid-1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			10.2143,
			"class Solution {\npublic:\n    int mySqrt(int x) {    \n        auto i = 1;\n        while (x / i > i) i++;\n        return x / i;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			30.6111,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long long l = 1, r = x;\n        while(l <= r){\n            long long m = (l + r) / 2;\n            if (m == x / m) return m;\n            else if (m * m > x) r = m - 1;\n            else l = m + 1;\n        }\n        return l - 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			19.3333,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int left = 0, right = x, ans;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (1LL * mid * mid <= x) {\n                ans = mid;\n                left = mid + 1;\n            }\n            else\n                right = mid - 1;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			7,
			25.65,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1)\n            return x;\n        if(x==2)\n            return 1;\n        long l=1, r=x/2+1; // square root of x will always be smaller then (x/2+1)\n        long ans = -1;\n        while(l<=r) {\n            long mid = l+(r-l)/2;\n            if(mid*mid==x) // x is perfect square so we return the mid\n                return (int)mid;\n            else if(mid*mid<x) {\n\t\t\t\tans = mid;    // if x is not perfect square, then answer will be the last number whose\n\t\t\t\t\t\t\t// square is less then x\n                l=mid+1;\n            }\n            else\n                r=mid-1;\n        }\n        return (int)ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			31.5,
			"class Solution {\npublic:\n    unsigned long long mySqrt(unsigned long long x)\n    {\n        unsigned long long l = 0;\n        unsigned long long r = x;\n        unsigned long long m, ans = 0;\n\n        if (x <= 1) {\n            return x;\n        }\n\n        while (l<=r) {\n            m = l + (r - l) / 2;\n\n            if (m * m == x) {\n                return m;\n            }\n            else if (m * m < x) {\n                ans = m;\n                l = m+1;\n            }\n            else {\n                r = m-1;\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			19.9565,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int low = 1, high = x;    \n        while(low <= high)\n        {\n            int mid = low + (high - low)/2;\n            if(pow(mid, 2) == x)\n                return mid;\n            if(pow(mid, 2) < x)\n                low = mid + 1;\n            if(pow(mid, 2) > x)\n                high = mid - 1;\n        }\n\t\treturn low-1; //if the loop terminates, the value before with decimal places would have been the sq root\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			21.25,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if (x == 1)\n            return 1;\n        \n        double result = x / 2, prev = 0;\n        while (abs(result - prev) > 0.1)\n        {\n            prev = result;\n            result = (result + x / result) / 2;\n        }\n        \n        return int(result);\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			22.1739,
			"class Solution {\npublic:\n\tint mySqrt(int x) {\n\t\tif (x < 2) return x;\n\t\t\n\t\tuint64_t mult = 0;\n\t\tint count = 0;\n\t\t\n\t\t//have mult start with half the bits of the other, if that's 0 or odd, then +1 bits\n\t\twhile ((x >> (31 - count) & 1u) == 0) count++;\n\t\tcount = (32 - count)/2 - ((count+1) % 2);\n\t\t\n\t\t//set all mult bits to 1 from count to beginning\n\t\tmult |= (~(0u) >> (31 - count));\n\n\t\t//while mult is greater, set smaller bits to 0\n\t\twhile (mult * mult > x && count > 0) {\n\t\t\tcount--;\n\t\t\tmult ^= (1u << count);\n\t\t\t\n\t\t\t//mult^2 is less than x but has too large of a difference, reset bit back to 1\n\t\t\tif (mult * mult + (mult * 2) < x) mult |= (1u << count);\n\t\t}\n\t\treturn mult;\n\t}\n};"
		],
		[
			1.0,
			1.0,
			5,
			30.6,
			"class Solution {\npublic:\n    int util(int x, int low, int high){\n        \n        while(low < high){\n            int mid = low + (high-low)/2;\n            if((long)mid*mid < x){\n                low = mid+1;\n            }else{\n                high = mid;\n            } \n        }\n        return (long)low*low > x ? low-1 : low;\n        \n    }\n    \n    int mySqrt(int x) {\n     \n        \n        return util(x, 1, x/2);\n    }\n};"
		],
		[
			1.0,
			1.0,
			8,
			39.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==1) return 1;\n        int l=0, r=x/2;\n        while(l<r) {\n            long m=l+(r-l)/2;\n            if(m*m==x||m*m<x&&(m+1)*(m+1)>x)\n                return m;\n            if(m*m>x)\n                r=m-1;\n            if(m*m<x)\n                l=m+1;\n        }\n        return l;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			28.5909,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if (x==0 || x==1)\n            return x;\n        int l=1,r=x;\n        int ans;\n        while(l<=r)\n        {\n            int mid = l + (r-l)/2;\n            \n            if(mid == x/mid)\n                return mid;\n            if(mid < x/mid)\n            {\n                l = mid+1;\n                ans = mid;\n            }\n            else\n                r = mid-1;\n        }\n        \n        return ans;\n    }\n};\n     \n"
		],
		[
			1.0,
			1.0,
			6,
			33.6818,
			"class Solution \n{\npublic:\n    int mySqrt(int x) \n\t{\n        if (x == 0 || x == 1)\n            return x;\n\t\t\t\n        int l = 1, r = (x / 2) + 1;\n        int res = 0;\n\t\t\n        while(l <= r)\n\t\t{\n            long long mid = (l + r) / 2;\n\t\t\t\n            if (mid*mid == x)\n                return mid;\t\t\n            if(mid*mid < x)\n\t\t\t{\n                l = mid + 1;\n                res = mid;\n            }\t\n            else\n                r = mid - 1;\n        }\n\t\t\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			7,
			30.7143,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==1){\n            return 1;\n        }\n        int l=0;\n        int r=x;\n        while(l<=r){\n            //cout<<l<<\" \"<<r<<endl;\n            int mid=(l+r)/2;\n            if(((long long)mid*(long long)mid)>=INT_MAX){\n                r=mid;\n                continue;\n            }\n            if(mid*mid==x){\n                return  mid;\n            }else if(mid*mid>x){\n                r=mid;\n            }else{\n                l=mid;\n            }\n            if(r==l+1){\n                return l;\n            }\n        }\n        \n        return x;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			3.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n     return sqrt(x);   \n    }\n};"
		],
		[
			1.0,
			1.0,
			2,
			7.94444,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if(x<=0) return 0;\n       return pow(2,0.5*log2(x)) ;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.5455,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0)return 0;\n        int strt = 1, end=x, ans;\n        while(strt <= end){\n            int mid = strt + (end-strt)/2;\n            if(mid <= x/mid){\n                ans = mid;\n                strt = mid+1;\n            }\n            else{\n                end = mid-1;\n            }\n        }\n        return ans;\n        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.4688,
			"/*\n    https://leetcode.com/problems/sqrtx/submissions/\n    \n    We use binary search for this. We set the lower limit as 0 and upper limit as n/2.\n    n/2 ensures that the range covers all possible candidates for sq root, since sq root is\n    m * m, so n/2 * n/2 > n and hence covers all.\n    \n    TC: O(logn)\n*/\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x <= 1)\n            return x;\n        int low = 0, high = ceil(x / 2);\n        \n        while(low < high) {\n            // rounded ceil\n            int mid = low + (high - low + 1) / 2;\n            long long sq = (long long)mid * mid;\n            if(sq <= x)\n                low = mid;\n            else\n                high = mid - 1;\n        }\n        \n        return low;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			29.45,
			"class Solution {\npublic:\nint mySqrt(int x) {\n\tlong long start = 1, end = x;\n\twhile (start <= end) {\n\t\tlong long mid = start + (end - start) / 2;\n\t\tlong long res = mid * mid;\n\t\tif (res == x)\n\t\t\treturn mid;\n\t\tif (res > x)\n\t\t\tend = mid - 1;\n\t\telse\n\t\t\tstart = mid + 1;\n\t}\n\treturn start - 1;\n}\n};"
		],
		[
			1.0,
			1.0,
			7,
			27.0375,
			"class Solution {\npublic:\n    int mySqrt(int x)\n    {\n        long long int low = 1, high = x;\n        // 1 and 0 are square roots of itself\n        if(x == 0 || x == 1)\n            return x;\n        \n        // Binary Search\n        while(low < high)\n        {\n            // mid point\n            long long int mid = (low+high+1)/2;\n            // if square of mid is less or equal but sq. of mid+1 is larger then we return smaller one\n            // x= 8; 2*2 <= 8 but 3*3 > 8, hence 2 is the answer\n            if(mid*mid <= x && (mid+1)*(mid+1) > x)\n                return mid;\n            // square of mid is larger so right subarray is removed\n            if(mid*mid > x)\n                high = mid - 1;\n            // square of mid is smaller so left subarray is removed\n            else\n                low = mid + 1;\n        }\n        return low;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			34.8333,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long long mid,left= 1, right= x;\n        if(x<2)\n            return x;\n        while(left<right){\n            mid = left+(right-left)/2;\n            if(mid*mid== x)\n                return mid;\n            if(mid*mid > x){\n                right = mid;\n            }\n            else\n                left = mid+1;\n        }\n        return left-1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			35.15,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0) return 0;\n        if(x<4) return 1;\n        int ans;\n        for(long long int i=2; i<=x/2+1; i++) {\n            if(i*i==x || i+1<=x/2+1 && (i*i<x && (i+1)*(i+1)>x)) {\n                ans= i;\n                break;\n            }\n        }\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			38.5,
			"class Solution {\npublic:\nint mySqrt(int x) {\n\t\tif (x <= 0)\n\t\t\treturn 0;\n\t\tvector<int> num;\n\t\twhile (x) {\n\t\t\tnum.push_back(x%100);\n\t\t\tx /= 100;\n\t\t}\n\n\t\tint result = 0;\n\t\tint rd = 0;\n\t\tfor (int i = num.size() - 1; i >= 0; i--) {    \n\t\t\tint j = 9;\n\t\t\tint temp = ( (rd * 10) + j) * j ;\n\n\t\t\twhile (temp > num[i]) {\n\t\t\t\tj--;\n\t\t\t\ttemp = ( (rd * 10) + j) * j ;\n\t\t\t}\n\n\t\t\tresult = result * 10 + j;\n\t\t\trd = (rd * 10 + j) ;\n\n\t\t\tint reminder = num[i] -  rd * j;\n\n\t\t\tif (i > 0) {\n\t\t\t\tnum[i-1] = reminder * 100 + num[i-1];\n\t\t\t}\n\n\t\t\trd+=j;\n\t\t}\n\t\treturn result;\n\t}\n};"
		],
		[
			1.0,
			1.0,
			9,
			42.875,
			"class Solution {\npublic:\n    long long binarySearch(int x) {\n        long long  s=2, e=x/2+1, mid;        \n        while(s<=e) {\n            mid= s+(e-s)/2;\n            if(mid*mid==x || mid*mid<x && (mid+1)*(mid+1)>x) break;\n            else if(mid*mid>x) e=mid-1;\n            else s=mid+1;\n        }\n        return mid;\n    }\n    \n    int mySqrt(int x) {\n        if(x==0) return 0;\n        if(x<4) return 1;        \n        return binarySearch(x);\n    }\n};"
		],
		[
			1.0,
			1.0,
			1,
			4.57143,
			"class Solution {\npublic:\nint mySqrt(int x) {\nreturn pow(x, 0.5);\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.7273,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x; // edge case \n        int lo = 0, hi = x/2; \n        while (lo < hi) {\n            int mid = (lo + hi + 1) >> 1; \n            if (x/mid < mid) {\n                hi = mid - 1; \n            } else {\n                lo = mid; \n            }\n        }\n        return lo; \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			20.8333,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x; // edge case \n        int x0 = x/2, x1 = x0/2+1; \n        while (x1 < x0) {\n            x0 = x1; \n            x1 = (x0 + x/x0)/2; \n        }\n        return x0; \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			3.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        return sqrt(x);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			31.5,
			"class Solution {\npublic:\n    int findsqrt(int low, int high, int n){\n        if(low<=high){\n            long long int mid=low +(high-low)/2;\n            if((mid*mid)<=n && (mid+1)*(mid+1)>n) return mid;\n            else if((mid*mid)<n) return findsqrt(mid+1,high,n);\n            else return findsqrt(low,mid-1,n);\n        }\n        return low;\n    }\n    int mySqrt(int x) {\n        return findsqrt(0,x,x);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			14.2222,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        __uint128_t i = 0; \n        for ( ; i <= x; ++i) {\n            if ( (i * i) > (long long)x) \n                break;\n        }\n        \n        return i-1;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			27.9286,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) return 0;\n        if (x < 3) return 1;\n        __uint128_t init = 0;\n        __uint128_t last = x;\n        __uint128_t old_mid = 0;\n        __uint128_t mid = 0;\n        while(1) {\n            mid = (init + last) / 2;\n            if (old_mid == mid) break;\n            if (mid * mid <= x) {\n                init = mid;\n            } else {\n                last = mid;\n            }\n            old_mid = mid;\n        }\n        return (int)mid;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.3333,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        if (x < 2) {\n            return x;\n        }\n        int l = 1;\n        int r = x;\n        while (l < r) {\n            int m = l + (r - l) / 2;\n            if (m > x / m) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        return l - 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.3182,
			"class Solution\n{\npublic:\n\nint mySqrt(int x) \n{\n    if(x == 0) return 0;\n    if(x == 1) return 1;\n    \n    double res = x/2;\n    \n    for(int k = 0; k < 20; k++)\n    {\n        res = 0.5 * (res + x/res);\n    }\n    \n    return res;\n}\n};"
		],
		[
			1.0,
			1.0,
			7,
			28.5,
			"class Solution {\npublic:\nint mySqrt(int x)\n{\n    long mid ;  // because we have to do mid*mid \n    if(x ==0 || x==1) return x;\n    \n    int i=0, j=x ;\n    while(i<j)\n    {\n        mid = (i+j)/2;\n        \n        if(mid*mid == x)  return mid;\n        else if(mid*mid < x) i = mid;\n        else j=mid;\n        \n         if(j-i==1) return i;   \n    }\n    return i;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			27.3889,
			"class Solution\n{\npublic:\n\nint mySqrt(int x) \n{\n    long int l = 1;\n    long int r = x;\n    \n    while(l <= r)\n    {\n        long int mid = (l + r) / 2;\n        \n        if(mid == x / mid)\n        {\n            return mid;\n        }\n        else if(mid < x / mid)\n        {\n            l = mid + 1;\n        }\n        else\n        {\n            r = mid - 1;\n        }\n    }\n    \n    return l - 1;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			24.1429,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        if (x < 2) {\n            return x;\n        }\n        int r = x;\n        while (r > x / r) {\n            r = r / 2 + x / r / 2;\n        }\n        return r + 1 > x / (r + 1) ? r : r + 1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			6.28571,
			"class Solution {\npublic:\nint mySqrt(int x) {\nif(x==0||x==1)\nreturn x;\nreturn (int)(sqrt(x));\n}\n};"
		],
		[
			1.0,
			1.0,
			3,
			16.5455,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        int res = 0;\n        for (int mask = 1 << 15; mask != 0; mask >>= 1) {\n            int next_try = res | mask;\n            if (next_try <= x / next_try) {\n                res = next_try;\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			19.3529,
			"class Solution {\n   public:\n    int mySqrt(int x) {\n        union {\n            float f;\n            int i;\n        } u;\n\n        u.f = x;\n        u.i = 0x5f375a86 - (u.i >> 1);\n\n        float f = 1 / (u.f * (1.5F - 0.5F * x * u.f * u.f));\n\n        // Once Newton method\n        f = f / 2 + x / f / 2;\n\n        int r = f;\n        return r * r > x ? r - 1 : r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			34.0,
			"class Solution {\npublic:\n    int mySqrt(int n)\n    {       \n        if (n < 2) { return n; }\n        \n        int l = 0;\n        int r = n / 2;\n        int sqrt_n = n / 2;  // initial guess\n\t\t\n        while (r - l > 1)\n        {\n            if (n / sqrt_n < sqrt_n) { r = sqrt_n; }\n            else if (n / sqrt_n > sqrt_n) { l = sqrt_n; }\n            else { return sqrt_n; }  // if (n / sqrt_n == sqrt_n)\n            sqrt_n = (r + l) / 2;    \n        }  \n        return sqrt_n;        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			16.9167,
			"class Solution\n{\npublic:\n    int mySqrt(int n)\n    {\n        if (n < 2) { return n; }\n        int root = n / 2;  // initial guess for the root of f(x) = x^2 - n \n        \n        while (n / root < root)\n        {\n            root = (root + n/root) / 2;\n        }\n        \n        return root;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			33.5714,
			"class Solution { // Binary Search - Normal\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1) return x;\n        int low(1), high(x/2);\n        while(low<=high){\n            unsigned long long mid(low+(high-low)/2);\n            if(mid*mid==x || ((mid+1)*(mid+1)>x && mid*mid<x)) return mid;\n            else if(mid*mid<x) low = mid+1;\n            else high = mid-1;\n        }\n        return -1;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			21.7143,
			"class Solution { // Binary Search - Fastest\npublic:\n    int mySqrt(int x) {\n        if(x==0 || x==1) return x;\n        int low(1), high(x/2),result(-1);\n        while(low<=high){\n            int mid(low+(high-low)/2);\n            if(mid<=x/mid){\n                result = mid;\n                low = mid+1;\n            }else{\n                high = mid-1;\n            }\n        }\n        return result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			13.5882,
			"class Solution { // Binary Search - Lightweight\npublic:\n    double calculateSqrt(double x, double n){\n        if(abs(x/n-n)<0.000001) return n;\n        return calculateSqrt(x,(n+x/n)/2); // better n is (n+A/n)/2\n    }\n    int mySqrt(int x) {\n        return (int)calculateSqrt(x,1);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			24.4444,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n        long long int l=0,r=x,m;\n        while(l<=r) {\n            m = l + (r-l)/2;\n            if(m*m >= x) {\n                r = m-1;\n            }\n            else {\n                if((m+1)*(m+1) > x ) {\n                    return m;\n                }\n                l = m+1;\n            }\n        }\n        return l;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			2,
			14.8571,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long int r = x;\n        while (pow(r, 2) > x) {\n            r = (r + x / r) / 2;\n        }\n        return r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			3.5,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        return floor(sqrt(x));\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			31.35,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if(x <= 1) return x;\n        \n        int l = 1, r = x/2;\n        \n        while(l <= r) {\n            long long mid = (l+r)/2;\n            long long p = mid * mid;\n            \n            if(p == x) return mid;\n            \n            if(p < x) l = mid + 1;\n            \n            else r = mid - 1;\n        }\n        \n        return r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			22.6944,
			"class Solution {\npublic:\nint mySqrt(int x) {\n        if(x==0) return 0;\n        long start=1, end=x;\n        while(start<=end)   {\n            long middle = (start+end)/2;\n            if(middle*middle==x) return middle;\n            if(middle*middle<x) start=middle+1;\n            else {end=middle-1;}\n        }\n        return start-1; //start points right next to the answer, hence, we return start-1\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			38.95,
			"class Solution {\npublic:\n\tint mySqrt(int x) {\n\t\tlong long high=x;\n\t\tlong long low=0;\n\t\tlong long mid=(high-low)/2+low;\n\t\twhile(low+1<high){\n\t\t\tmid=(high-low)/2+low;\n\t\t\tif(mid*mid==x) return mid;\n\t\t\tif(mid*mid>x){\n\t\t\t\thigh=mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlow=mid;\n\t\t\t}\n\t\t}\n\t\tif(high*high<=x) return high;\n\t\tif(mid*mid<=x) return mid;\n\n\t\treturn low;\n\n\t}\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.7273,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        long int low=0;\n        long int high=x;\n        while(low<=high){\n            long int mid=(low+high)/2;\n            long int temp=mid*mid;\n            if(temp==x) return mid;\n            else if(temp<x)low=mid+1;\n            else high=mid-1;\n        }\n        return high;        \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			23.75,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int lo = 0, hi = x, res;\n        while(lo <= hi){\n            long long mi = lo + (hi-lo)/2; // to avoid overflow\n            if(mi*mi == x)\n                return mi;\n            else if(mi*mi > x)\n                hi = mi-1;\n            else{\n                lo = mi+1;\n                res = mi;\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			15.75,
			"class Solution \n{\npublic:\n    int mySqrt(int x) \n    {\n        if(x==0)\n        {\n            return 0;\n        }\n        long long int ans=1;\n        for(long long int i=1;i*i<=x;i++)\n        {\n            ans=i;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			28.0,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x < 2) return x;\n        int l = x;\n        while (l > x / l) \n            l = l / 2 + x / l / 2 + (l % 2 && (x / l) % 2);\n        return l;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			23.75,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        int lo = 0, hi = x, res;\n        while(lo <= hi){\n            long long mi = lo + (hi-lo)/2; // to avoid overflow\n            if(mi*mi == x)\n                return mi;\n            else if(mi*mi > x)\n                hi = mi-1;\n            else{\n                lo = mi+1;\n                res = mi;\n            }\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			1,
			5.6,
			"class Solution {\npublic:\n    int mySqrt(int x) {\n        x=(int)sqrt(x);\n        return x;\n    }\n};\n"
		]
	],
	"COUNT_ISLANDS": [
		"n^2",
		[
			17.399108047460793,
			15.219194096954732,
			10,
			43.6364,
			"class Solution {\npublic:\n    void helper(vector<vector<char>>& grid,int x,int y,int n,int m){\n        if(x<0|| x>=n || y<0 || y>=m || grid[x][y]=='0' ) return;\n        grid[x][y]='0'; //mark node as visited\n        helper(grid,x-1,y,n,m);\n        helper(grid,x+1,y,n,m);\n        helper(grid,x,y+1,n,m);\n        helper(grid,x,y-1,n,m);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int ans=0;\n        int n=grid.size();\n        \n        for(int i=0;i<n;i++){\n            int m=grid[i].size();\n            for(int j=0;j<m;j++){\n                if(grid[i][j]=='1'){\n                    ans++;\n                    helper(grid,i,j,n,m);\n                }\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			18.66116786222004,
			15.219194096954734,
			10,
			38.2609,
			"// Logic to this solution: recursively erase all found islands.\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == '1') {\n                    eraseIsland(i, j, grid);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    void eraseIsland(int i, int j, vector<vector<char>>& grid) {\n        if (0 <= i && i < grid.size() && 0 <= j && j < grid[i].size() && grid[i][j] == '1') {\n            grid[i][j] = '0';\n            eraseIsland(i - 1, j, grid);\n            eraseIsland(i, j - 1, grid);\n            eraseIsland(i + 1, j, grid);\n            eraseIsland(i, j + 1, grid);\n        }\n    }\n};\n"
		],
		[
			18.304759837107223,
			15.219194096954732,
			18,
			55.8065,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        queue<pair<int, int>> q;\n        set<pair<int, int>> vis;\n        int no_isl = 0;\n        \n        for(int row = 0; row < grid.size(); row++)\n        {\n            for(int col = 0; col < grid[row].size(); col++)\n            {\n                if(grid[row][col] == '1' && vis.find({row, col}) == vis.end())\n                {\n                    q.push({row, col});\n                    vis.insert({row, col});\n                    while(!q.empty())\n                    {\n                        pair<int, int> front = q.front();\n                        q.pop();\n                        int r = front.first, c = front.second, rsize = grid.size(), csize = grid[row].size();\n                        \n                        if(c+1 < csize && grid[r][c+1] == '1' && vis.find({r, c+1}) == vis.end())\n                        {\n                            q.push({r, c+1});\n                            vis.insert({r, c+1});\n                        }\n                        if(r+1 < rsize && grid[r+1][c] == '1' && vis.find({r+1, c}) == vis.end())\n                        {\n                            q.push({r+1,c});\n                            vis.insert({r+1, c});\n                        }\n                        if(c-1 >= 0 && grid[r][c-1] == '1' && vis.find({r,c-1}) == vis.end())\n                        {\n                            q.push({r, c-1});\n                            vis.insert({r, c-1});\n                        }\n                        if(r-1 >= 0 && grid[r-1][c] == '1' && vis.find({r-1, c}) == vis.end())\n                        {\n                            q.push({r-1,c});\n                            vis.insert({r-1, c});\n                        }   \n                    }\n                    no_isl += 1;\n                }\n            }\n        }\n        return no_isl;\n    }\n};\n"
		],
		[
			20.355967865750422,
			17.87672794258763,
			21,
			56.9032,
			"class Solution {\npublic:\n    vector<int> parent,size;\n    int dis[5]={1,0,-1,0,1};\n    int cou;\n    int find_set(int v)\n    {\n        if(parent[v]==v) return v;\n        return parent[v]=find_set(parent[v]);\n    }\n    void make_set(int v)\n    {\n        parent[v]=v;\n        size[v]=1;\n    }\n    void union_set(int a,int b)\n    {\n        a=find_set(a);\n        b=find_set(b);\n        if(a!=b) \n        {cou--;\n         if(a<b) swap(a,b);\n         parent[b]=a;\n         size[a]+=size[b];\n        }\n            \n    }\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0 || grid[0].size() == 0) return 0;\n        int n=grid.size(),m=grid[0].size();\n        parent.resize(n*m);\n        size.resize(n*m,0);\n        for(int i=0;i<grid.size();i++)\n            for(int j=0;j<grid[0].size();j++)\n                if(grid[i][j]=='1')\n                {   \n                    cou++;\n                    make_set(i*m+j);\n                }\n        for(int i=0;i<grid.size();i++)\n            for(int j=0;j<grid[0].size();j++)\n                if(grid[i][j]=='1')\n                {  \n                 for(int k=0;k<4;k++)\n                 {\n                     int dx=i+dis[k],dy=j+dis[k+1];\n                     if(dx>=0&&dx<n&&dy>=0&&dy<m&&grid[dx][dy]=='1')\n                         union_set(i*m+j,dx*m+dy);\n                 }\n                }\n        return cou;\n    }\n};\n"
		],
		[
			17.561320395298882,
			15.219194096954734,
			11,
			53.6471,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid,int i,int j,int r,int c)\n    {   if(i<0||j<0||i>=r||j>=c||grid[i][j]!='1') return;\n        grid[i][j]='2';\n        dfs(grid,i-1,j,r,c);\n        dfs(grid,i+1,j,r,c);\n        dfs(grid,i,j-1,r,c);\n        dfs(grid,i,j+1,r,c);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int r=grid.size();\n        if(grid.size()==0)\n            return 0;\n        int c=grid[0].size();\n        int ans=0;\n        for(int i=0;i<r;i++)\n        {  for(int j=0;j<c;j++)\n            {   if(grid[i][j]=='1')\n                {   dfs(grid,i,j,r,c);\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n};\n"
		],
		[
			17.499211944681434,
			15.219194096954734,
			12,
			46.1087,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>> &g, int r, int c, int &m, int &n, int *dr, int*dc){\n        g[r][c]='0';\n        for(int i=0; i<4; i++){\n            int rr = r+dr[i];\n            int cc = c+dc[i];\n            \n            if(rr<0||rr>=m||cc<0||cc>=n||g[rr][cc]=='0') continue;\n            \n            dfs(g, rr, cc, m, n, dr, dc);\n        }\n    }\n    \n    \n    int numIslands(vector<vector<char>>& g) {\n        int m=g.size();\n        int n=m?g[0].size():0;\n        \n        int count=0;\n        \n        int dr[] = {0,0,1,-1};\n        int dc[] = {1,-1,0,0};\n        \n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(g[i][j]=='1'){\n                    count++;\n                    dfs(g, i, j, m, n, dr, dc);\n                }\n            }\n        }\n        return count;\n    }\n};\n"
		],
		[
			18.170008602946744,
			15.219194096954734,
			11,
			52.5667,
			"class Solution {\npublic:\n    void getnumislands(vector<vector<char>>& grid, int i, int j)\n    {\n        if(i<0 || i>=grid.size()) return;\n        if(j<0 || j>=grid[0].size()) return;\n        if(grid[i][j]=='0' || grid[i][j]=='2') return;\n            \n        grid[i][j]='2';\n        \n        getnumislands(grid,i+1,j);\n        getnumislands(grid,i,j+1);\n        getnumislands(grid,i-1,j);\n        getnumislands(grid,i,j-1);\n        \n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int count=0;\n        \n        for(int i=0; i<grid.size(); i++)\n        {\n            for(int j=0; j<grid[0].size(); j++)\n            {\n                if(grid[i][j]=='1')\n                {\n                    getnumislands(grid,i,j);\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n"
		],
		[
			18.413327542786856,
			15.219194096954734,
			9,
			37.2727,
			"class Solution {\nprivate:\n    const vector<vector<int>> DIR {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    \n    bool isSafe(const vector<vector<char>>& grid, int x, int y) {\n        return x >= 0 and x < grid.size() and y >= 0 and y < grid[0].size() and grid[x][y] == '1';\n    }\n    \n    void markBfs(vector<vector<char>>& grid, int x, int y) {\n        queue<array<int, 2>> q;\n        q.push({x, y});\n        while (!q.empty()) {\n            auto current = q.front(); q.pop();\n            for (const vector<int>& d : DIR) {\n                int i = d[0] + current[0];\n                int j = d[1] + current[1];\n                if (isSafe(grid, i, j)) {\n                    grid[i][j] = '0';\n                    q.push({i, j});\n                }\n            }\n        }\n    }\n    \npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int islands = 0;\n        for (int i=0; i<grid.size(); i++) {\n            for (int j=0; j<grid[0].size(); j++) {\n                if (grid[i][j] == '1') {\n                    markBfs(grid, i, j);\n                    islands++;\n                }\n            }\n        }\n        return islands;\n    }\n};\n"
		],
		[
			17.80750166965936,
			16.98649012586746,
			14,
			48.0,
			"class Solution {\n    int c=0;\n    int x[4]={-1,0,1,0};\n    int y[4]={0,1,0,-1};\npublic:\n    void dfs(vector<vector<char> > &gr,int i,int j,int m,int n,vector<vector<int> > &vis){\n        vis[i][j]=1;\n        for(int dir=0;dir<4;dir++){\n            int xd=i+x[dir];\n            int yd=j+y[dir];\n            if(xd>=0 && yd>=0 && xd<=m-1 && yd<=n-1){\n                if(!vis[xd][yd] && gr[xd][yd]=='1'){\n                    dfs(gr,xd,yd,m,n,vis);\n                }\n            }\n        }\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int m=grid.size();\n        if(m==0) return 0;\n        int n=grid[0].size();\n        vector<vector<int> > visi(m+1,vector<int>(n+1,0));\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]=='1' && !visi[i][j]){\n                    c++;\n                    dfs(grid,i,j,m,n,visi);\n                }\n            }\n        }\n        return c;\n    }\n};\n"
		],
		[
			16.716281784362575,
			15.307066869085832,
			14,
			42.2308,
			"class Solution {\npublic:\n    int x[4] = {-1, 0, 1, 0};\n    int y[4] = {0, 1, 0, -1};\n\n    void dfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {\n        if (i < 0 || j < 0 || i > grid.size()-1 || j > grid[0].size()-1 || visited[i][j] || grid[i][j] == '0') return;\n        visited[i][j] = true;\n        for (int k=0; k<4; k++) {\n            dfs(i+x[k], j+y[k], grid, visited);\n        }\n    }\n\n    int ff(vector<vector<char>>& grid) {\n        if (!grid.size()) return 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        int count = 0;\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                if (grid[i][j] == '1' and !visited[i][j]) {\n                    dfs(i, j, grid, visited);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        return ff(grid);\n    }\n};\n"
		],
		[
			17.456014633012057,
			15.219194096954734,
			11,
			31.6667,
			"#define fastIO ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\nclass Solution {\npublic:\nint r,c;\nint isl=0;\nvoid markcurr(vector<vector<char>>& grid , int x,int y){\n    if(x<0 || x>=r || y<0 || y>=c || grid[x][y]!='1')return ;\n    grid[x][y]='2';\n    \n    markcurr(grid,x+1,y);\n    markcurr(grid,x-1,y);\n    markcurr(grid,x,y+1);\n    markcurr(grid,x,y-1);\n}\nint numIslands(vector<vector<char>>& grid) {\n    fastIO;\n    r=grid.size();\n    if(r==0)return 0;\n    c=grid[0].size();\n    \n    for(int i=0;i<r;++i)\n        for(int j=0;j<c;++j)\n            if(grid[i][j]=='1')\n                {markcurr(grid,i,j);\n                isl++;}\n                \n    return isl;\n}\n};"
		],
		[
			17.608251101390596,
			15.219194096954734,
			11,
			45.5,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>> &grid, int row, int col){\n        int ROWS = grid.size();\n        int COLS = grid[0].size();\n        \n        if(row>=ROWS || row<0 || col>=COLS || col<0 || grid[row][col]=='2' || grid[row][col]=='0')\n            return;\n        \n        grid[row][col] = '2';\n        \n        dfs(grid,row-1,col);\n        dfs(grid, row, col-1);\n        dfs(grid, row, col+1);\n        dfs(grid, row+1, col);\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        \n        int ROWS = grid.size();\n        int COLS = grid[0].size();\n        \n        int count = 0;\n        \n        for(int i=0;i<ROWS;i++){\n            for(int j=0;j<COLS;j++){\n                if(grid[i][j]=='1'){\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        \n        return count++;\n    }\n};\n"
		],
		[
			18.33361470827628,
			15.219194096954734,
			10,
			24.6774,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int island_count = 0;\n        \n\t\t// iterate through the matrix O(m x n)\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == '1') {\n\t\t\t\t\t// found an island, increment count and call sink\n                    ++island_count;\n                    sinkIsland(&grid, i, j);\n                }\n            }\n        }\n        \n        return island_count;\n    }\nprivate:\n    void sinkIsland(vector<vector<char>>* grid_ptr, int i, int j) {\n\t\t// passing by pointer to avoid using non-const references\n\t\t// this is a C++ style choice\n        auto& grid = *grid_ptr;\n        \n\t\t// if the current coordinate isn't part of the island, return\n        if (grid[i][j] != '1') return;\n        \n\t\t// sink the current coordinate\n        grid[i][j] = '0';\n        \n\t\t// if the any of the following coordinates is valid\n\t\t// call sinkIsland recursively\n\t\tif (i < grid.size() - 1) sinkIsland(grid_ptr, i + 1, j);  // east\n        if (i > 0) sinkIsland(grid_ptr, i - 1, j);  // west\n\t\tif (j < grid[i].size() - 1) sinkIsland(grid_ptr, i, j + 1);  // north\n        if (j > 0) sinkIsland(grid_ptr, i, j - 1);  // south\n    }\n};\n"
		],
		[
			21.204519951469276,
			7.444265120541342,
			17,
			56.6346,
			"class Solution {\nprivate:\n    void dfs(int i, int j, const vector<vector<char>>& grid, set<pair<int, int>>& vis, int n, int m){\n        if( (i < 0 || j < 0 || i >= n || j >= m) ) return;\n        vis.insert({i,j});\n        if(grid[i][j] == '0') return;\n        auto p = vis.find({i+1, j});\n        if(p == vis.end()){\n            dfs(i+1, j, grid, vis, n, m);\n        }\n        p = vis.find({i-1, j});\n        if(p == vis.end()){\n            dfs(i-1, j, grid, vis, n, m);\n        }\n        p = vis.find({i, j+1});\n        if(p == vis.end()){\n            dfs(i, j+1, grid, vis, n, m);\n        }\n        p = vis.find({i, j-1});\n        if(p == vis.end()){\n            dfs(i, j-1, grid, vis, n, m);\n        }\n    }\n    \npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size();\n        if(!n) return 0;\n        int m = grid[0].size();\n        if(!m) return 0;\n        int cnt = 0;\n        set<pair<int, int>> vis;\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < m; ++j){\n                auto p = vis.find({i, j});\n                if(grid[i][j] == '1' && p == vis.end()){\n                    dfs(i, j, grid, vis, n, m);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			18.272131846075713,
			15.219194096954734,
			13,
			38.6207,
			"class Solution {\npublic:\n    void recur(vector<vector<char>>& grid, int row, int col) {\n        grid[row][col] = '2'; // Visisted so mark to '2'\n        if (row-1 >= 0 && grid[row-1][col] == '1') recur(grid, row-1, col);\n        if (col-1 >= 0 && grid[row][col-1] == '1') recur(grid, row, col-1);\n        if (row+1 < grid.size() && grid[row+1][col] == '1') recur(grid, row+1, col);\n        if (col+1 < grid[0].size() && grid[row][col+1] == '1') recur(grid, row, col+1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for (int i = 0; i<grid.size(); i++) {\n            for (int j = 0; j<grid[0].size(); j++) {\n                if (grid[i][j] == '1') { // Found a land, find the region by recursion\n                    recur(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};"
		],
		[
			17.5312080078524,
			15.219194096954734,
			14,
			59.8235,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>> &grid) {\n        int m = grid.size();\n        if (m==0) return 0;\n        int n = grid[0].size();\n        int count = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j]=='1') {\n                    helper(grid,i,j,m,n);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n    \n    void helper(vector<vector<char> >& a, int i, int j, int m, int n) {\n        a[i][j] = 0;\n        if (i > 0 && a[i-1][j]=='1') helper(a,i-1,j,m,n);\n        if (j > 0 && a[i][j-1]=='1') helper(a,i,j-1,m,n);\n        if (i < m-1 && a[i+1][j]=='1') helper(a,i+1,j,m,n);\n        if (j < n-1 && a[i][j+1]=='1') helper(a,i,j+1,m,n);\n    }\n};"
		],
		[
			23.023654808759616,
			17.877371165911615,
			14,
			59.7143,
			"class Solution {\npublic:\n    struct Point {\n        int row, col;\n        Point(int _x, int _y) : row(_x), col(_y) {}\n    };\n    int nr_row, nr_col;\n    int numIslands(vector<vector<char> > &grid) {\n        if (grid.empty() || grid[0].empty()) {\n            return 0;\n        }\n\n        nr_row = grid.size();\n        nr_col = grid[0].size();\n\n        int res = 0;\n        queue<Point> q;\n        \n        for (int i = 0; i < nr_row; ++i) {\n            for (int j = 0; j < nr_col; ++j) {\n                if (grid[i][j] == '0') {\n                    continue;\n                }\n                ++res;\n\n                grid[i][j] = '0';\n                q.push(Point(i, j));\n                while (!q.empty()) {\n                    Point point = q.front();\n                    q.pop();\n                    addNeighbor(grid, point, -1,  0, q);\n                    addNeighbor(grid, point,  0, -1, q);\n                    addNeighbor(grid, point,  1,  0, q);\n                    addNeighbor(grid, point,  0,  1, q);\n                }\n            }\n        }\n        return res;\n    }\n\n    void addNeighbor(vector<vector<char> > &grid, Point point, \n            int d_row, int d_col, queue<Point> &q) {\n        point.row += d_row;\n        point.col += d_col;\n        if (point.row >= nr_row || point.col >= nr_col || \n                point.row < 0 || point.col < 0 ||\n                grid[point.row][point.col] == '0') {\n            return;\n        }\n        grid[point.row][point.col] = '0';\n\n        q.push(point);\n    }\n};"
		],
		[
			24.778549169086133,
			17.01834221306894,
			17,
			71.52,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (!grid.size() || !grid[0].size()) return 0;\n        int count = 0;\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<int> queue; \n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '0' || visited[i][j]) continue;\n                count++;\n                visited[i][j] = true;\n                queue.push(i * n + j);\n                while (!queue.empty()) {\n                    int x = queue.front() / n, y = queue.front() % n;\n                    queue.pop();\n                    if (grid[x][y] == '0') continue;\n                    if (x - 1 >= 0 && !visited[x-1][y]) {queue.push((x-1) * n + y); visited[x-1][y] = true;}\n                    if (y - 1 >= 0 && !visited[x][y-1]) {queue.push(x * n + y-1); visited[x][y-1] = true;}\n                    if (x + 1 < m && !visited[x+1][y]) {queue.push((x+1) * n + y); visited[x+1][y] = true;}\n                    if (y + 1 < n && !visited[x][y+1]) {queue.push(x * n + y+1); visited[x][y+1] = true;}\n                }\n            }\n                \n        return count;           \n    }\n\n};"
		],
		[
			17.324149476727463,
			15.219194096954732,
			14,
			66.1111,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid, int rows, int cols, int i, int j) {\n        // cout << i << j << endl;\n        grid[i][j] = '0';\n        if ((i-1) >= 0 && grid[i-1][j] == '1') dfs(grid, rows, cols, i-1, j);\n        if ((i+1) < rows && grid[i+1][j] == '1') dfs(grid, rows, cols, i+1, j);\n        if ((j-1) >= 0 && grid[i][j-1] == '1') dfs(grid, rows, cols, i, j-1);\n        if ((j+1) < cols && grid[i][j+1] == '1') dfs(grid, rows, cols, i, j+1);\n        // return;\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        if (!grid.size()) return 0;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int numberIslands = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j]=='1') {\n                    ++numberIslands;\n                    dfs(grid, rows, cols, i, j);\n                }\n            }\n        }\n        return numberIslands;\n    }\n};\n"
		],
		[
			18.262745754411572,
			15.219194096954734,
			11,
			27.9776,
			"/*\n    https://leetcode.com/problems/number-of-islands/\n    TC: O(V^2)\n*/\nclass Solution {\npublic:\n    void DFS(vector<vector<char>>& grid, int i, int j) {\n        // boundary checking\n        if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size())\n            return;\n        // return if current position is of water or is already visited\n        if(grid[i][j] == '2' || grid[i][j] == '0')\n            return;\n        \n        // mark the current as visited\n        grid[i][j] = '2';\n        \n        // do DFS in all 4 directions\n        DFS(grid, i+1, j);\n        DFS(grid, i, j-1);\n        DFS(grid, i-1, j);\n        DFS(grid, i, j+1);\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        // We can treat the matrix grid as a grid. Each Island is a\n        // connected component. The task is to find no. of disconnectedd components\n        // in the graph.\n        \n        int islands = 0;\n        // We make each 1 as 2 in when it is visited\n        for(int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[0].size(); j++) {\n                // do DFS in case has not been visited and there is land\n                if(grid[i][j] == '1') {\n                    DFS(grid, i, j);\n                    ++islands;\n                } \n            }\n        }\n        return islands;\n    }\n};\n"
		],
		[
			18.301664182098715,
			15.219194096954734,
			11,
			29.7759,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        //test edge cases\n        if(grid.size()==0) return 0;\n        int numIslands = 0;\n        //lets traverse the matrix now and check for every cell\n        for(int i=0; i<grid.size(); i++)\n        {\n            for(int j=0; j<grid[0].size(); j++)\n            {\n                if(grid[i][j] == '1')\n                {\n                    numIslands += dfs(grid, i, j);\n                }\n            }\n        }\n        return numIslands;\n    }\n    \n    int dfs(vector<vector<char>>& grid, int i, int j) {\n        //check the bounds of 2-d matrix\n        //it shouldn't go out of bounds i.e beyond the scope of matrix\n        //And if grid[i][j] is 0 then we don't care and only return 0\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]=='0') \n            return 0;\n        \n        //since we have visited grid[i][j] lets mark it as 0 to avoid visiting it again\n        grid[i][j]='0';\n        //now lets traverse its neighbours \n        dfs(grid, i+1, j); //down\n        dfs(grid, i-1, j); //up\n        dfs(grid, i, j+1); //right\n        dfs(grid, i, j-1); //left\n        return 1;\n    }    \n};\n"
		],
		[
			17.50587165451414,
			15.219194096954734,
			11,
			42.5,
			"class Solution {\npublic:\n\tint m;\n\tint n;\n\tvoid fill(vector<vector<char>>& grid,int x,int y){\n\t\tif(x<0 ||x>=m || y<0 || y>=n || grid[x][y]=='0'){\n\t\t\treturn;\n\t\t}\n\t\tgrid[x][y]='0';\n\t\tfill(grid,x+1,y);\n\t\tfill(grid,x-1,y);\n\t\tfill(grid,x,y+1);\n\t\tfill(grid,x,y-1);\n\t}\n\tint numIslands(vector<vector<char>>& grid) {\n\t\tif(grid.empty()) return 0;\n\t\tm=grid.size();\n\t\tn=grid[0].size();\n\t\tint res=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(grid[i][j]=='1'){\n\t\t\t\t\tres++;\n\t\t\t\t\tfill(grid,i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\n\t}\n};"
		],
		[
			26.48074819188916,
			18.504947090861318,
			29,
			90.3409,
			"class Solution {\npublic:\n    #include<vector>\n    class UnionFind{\npublic:\n    int n, m;   \n    vector < vector <int> > size;\n    vector <vector <pair <int, int> > > parent;\n    vector < vector <bool> > cross;\n    int numofcomponents;\n    UnionFind(int n, int m) {\n        this->n = n;\n        this->m = m;\n        size.assign(n, vector <int> (m, 1));\n        cross.assign(n, vector <bool> (m, true));\n        parent.assign(n, vector <pair <int, int> > (m, {-1, -1}));\n        for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) {parent[i][j] = {i, j};} }\n        numofcomponents = n*m;\n    }\n\n    pair <int, int> find(pair <int, int> p) {\n        pair <int, int> root = p;\n        while (root != parent[root.first][root.second]) {\n            root =  parent[root.first][root.second];\n        }\n        // Armortized Algorithm\n        while (p != root) {\n            pair <int, int> next = parent[p.first][p.second];\n            parent[p.first][p.second] = root;\n            p = next;\n        }\n        return root;\n    }\n\n    bool isConnected(pair <int, int> p, pair <int, int> q) {\n        return find(p) == find(q);\n    }\n\n    int componentsize(pair <int, int> p ) {\n        pair <int, int> temp = find(p);\n        return size[temp.first][temp.second];\n    }\n\n    int commponents() {\n        return numofcomponents;\n    }\n\n    void unify(pair <int, int> p, pair <int, int> q) {\n        pair <int, int> root1 = find(p);\n        pair <int, int> root2 = find(q);\n        if (root1 == root2) return;\n        if (size[root1.first][root1.second] > size[root2.first][root2.second]) {\n            size[root1.first][root1.second] += size[root2.first][root2.second];\n            parent[root2.first][root2.second] = root1;\n        } else {\n            size[root2.first][root2.second] += size[root1.first][root2.second];\n            parent[root1.first][root1.second] = root2;\n        }\n\n        numofcomponents--;\n    }\n};\n    int numIslands(vector<vector<char>>& grid) {\n         int n = grid.size();\n        if (n == 0)return 0;\n        int zeros = 0;\n        int m = grid[0].size();\n        UnionFind U(n, m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == '0') {\n                    zeros++;\n                    continue;\n                }\n                if (i != 0) {\n                    if (grid[i][j] == grid[i - 1][j])\n                    U.unify({i, j},{i - 1, j});\n                }\n                if (j != 0) {\n                     if (grid[i][j] == grid[i][j - 1])\n                    U.unify({i, j}, {i, j - 1});\n                }\n                if (i != n - 1) {\n                    if (grid[i][j] == grid[i + 1][j])\n                    U.unify({i, j}, {i + 1, j});\n                }\n                if (j != m - 1) {\n                     if (grid[i][j] == grid[i][j + 1])\n                    U.unify({i, j}, {i, j + 1});\n                }\n                if (i == 0 || j == 0 || i == n - 1 || j == m-1) {\n                    pair <int, int> tmp = U.find({i, j});\n                    U.cross[tmp.first][tmp.second] = false;\n                }\n               \n            }\n        }\n        return U.numofcomponents - zeros;\n\n    }\n};\n\n"
		],
		[
			18.357257736684076,
			15.219194096954734,
			11,
			24.5455,
			"class Solution {\n    void sinkIsland(int x, int y, vector<vector<char>>& grid) {\n        if (x < 0 || y < 0 || x == grid.size()  || y == grid[0].size()) return; // Return if we are out of bounds\n        if (grid[x][y] == '0') return; // return if we hit the ocean\n        grid[x][y] = '0'; // Otherwise, we didn't hit the ocean, time to sink the island\n        sinkIsland(x + 1, y, grid); // Go down one \n        sinkIsland(x - 1, y, grid); // Go up one\n        sinkIsland(x, y + 1, grid);  // Go right one\n        sinkIsland(x, y - 1, grid); // go left one.\n        return; // Island is sunk. Return to main function.\n    }\n      \npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int cnt{};\n        if (grid.empty()) return 0;\n        for (int i{}; i < grid.size(); i++) {\n            for (int j{}; j < grid[0].size(); j++) {\n                if (grid[i][j] == '1') { // If there is a 1, it's an island, lets wipe it off the map.\n                    sinkIsland(i, j, grid);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			18.22051957718391,
			17.876742958928283,
			14,
			78.8889,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0) return 0;\n        int row = grid.size();\n        int col = grid[0].size();\n        int flag = 0;\n        vector<vector<int>> M(row, vector<int>(col, 0));\n        vector<vector<int>> visited(row, vector<int>(col, 0));\n        for(int i = 0; i < row; i++) {\n            for(int j = 0; j < col; j++) {\n                if(grid[i][j] == '1' && M[i][j] == 0) {\n                    dfs(grid, M, visited, i, j, ++flag);\n                } else {\n                    continue;\n                }\n            }\n        }\n        return flag;\n    }\n    \n    void dfs(vector<vector<char>>& grid, vector<vector<int>>& M, vector<vector<int>>& visited, int i, int j, int flag) {\n        if(i < 0 || j < 0 || i == grid.size() || j == grid[0].size() || visited[i][j] == 1) {\n            return;\n        } else if(grid[i][j] == '0') {\n            visited[i][j] = 1;\n            return;\n        }\n        \n        if(grid[i][j] == '1') {\n            M[i][j] = flag;\n            visited[i][j] = 1;\n            dfs(grid, M, visited, i, j - 1, flag);\n            dfs(grid, M, visited, i - 1, j, flag);\n            dfs(grid, M, visited, i, j + 1, flag);\n            dfs(grid, M, visited, i + 1, j, flag);\n        }\n        \n        return;\n    }\n};\n"
		],
		[
			18.881175507363743,
			16.986474838193747,
			18,
			42.5714,
			"class Solution {\npublic:\nclass UnionFind {\nprivate:\n    vector<int> parent;\n\npublic:\n    int count;\n\n    UnionFind(int n) : parent(n), count(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    void uni(int p, int q) {\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if (pRoot != qRoot) {\n            parent[pRoot] = qRoot;\n            count--;\n        }\n    }\n\n    int find(int node) {\n        if (parent[node] == node) {\n            return node;\n        }\n        //path compression\n        parent[node] = find(parent[node]);\n        return parent[node];\n    }\n\n    bool connected(int p, int q) {\n        return find(p) == find(q);\n    }\n};\n    int numIslands(vector<vector<char>> &grid) {\n        if (grid.empty()) return 0;\n        int d[2][2]{{1, 0},\n                    {0, 1}};  //search right/down.\n        int m = grid.size(), n = grid[0].size(), zeros = 0;\n        UnionFind uf(m * n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] != '1') {\n                    zeros++;\n                    continue;\n                }\n                int node1 = i * n + j;\n                for (int k = 0; k < 2; k++) {\n                    int newX = i + d[k][0];\n                    int newY = j + d[k][1];\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == '1') {\n                        int node2 = newX * n + newY;\n                        uf.uni(node1, node2);\n                    }\n                }\n            }\n        }\n        return uf.count - zeros;\n    }\n};\n"
		],
		[
			18.251291366669943,
			15.219194096954732,
			10,
			45.2647,
			"class Solution {\npublic:\n    \n    void dfs(vector<vector<char>>& graph,int row,int col){\n\n    if(graph[row][col] == '1'){\n        graph[row][col] = '0';\n    if(row >=1)\n        dfs(graph,row-1,col);\n    if(row <graph.size()-1)\n        dfs(graph,row+1,col);\n    if(col >= 1)\n        dfs(graph,row,col-1);\n    if(col < graph[0].size()-1)\n        dfs(graph,row,col+1);\n    }\n\n}\n    \n    \n    int numIslands(vector<vector<char>>& grid) {\n            int ans = 0;\n    for(int i=0;i<grid.size();i++){\n        for(int j=0;j<grid[0].size();j++){\n            if(grid[i][j] == '1'){\n                dfs(grid,i,j);\n                ans++;\n            }\n        }\n    }\n    return ans;\n    }\n};\n"
		],
		[
			17.234029878531786,
			15.219194096954734,
			11,
			45.0,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.empty()) {\n            return 0;\n        }\n        int res = 0, m = grid.size(), n = grid[0].size();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == '1') {\n                    ++res;\n                    dfs(grid, i, j, m, n);\n                }\n            }\n        }\n        return res;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int r, int c, int& m, int& n) {\n        if (r < 0 || c < 0 || r == m || c == n || grid[r][c] == '0') {\n            return;\n        }\n        grid[r][c] = '0';\n        dfs(grid, r + 1, c, m, n);\n        dfs(grid, r - 1, c, m, n);\n        dfs(grid, r, c - 1, m, n);\n        dfs(grid, r, c + 1, m, n);\n    }\n};\n"
		],
		[
			19.46671585918455,
			17.87672794258763,
			19,
			62.6552,
			"class Solution {\npublic:\nclass UF\n{\npublic:\n\tUF(int n) :id(n), sz(n, 1), counter(n)\n\t{\n\t\tfor (int i = 0; i < n; ++i) id[i] = i;\n\t}\n\n\tvoid uni(int p, int q)\n\t{\n\t\tint i = root(p);\n\t\tint j = root(q);\n\t\tif (i != j)\n\t\t{\n\t\t\tif (sz[i] < sz[j]) {\n\t\t\t\tid[i] = j;\n\t\t\t\tsz[j] += sz[i];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tid[j] = i;\n\t\t\t\tsz[i] += sz[j];\n\t\t\t}\n\t\t\t--counter;\n\t\t}\n\t}\n\n\tint root(int i)\n\t{\n\t\twhile (i != id[i])\n\t\t{\n\t\t\tid[i] = id[id[i]];\n\t\t\ti = id[i];\n\t\t}\n\t\treturn i;\n\t}\n\n\tbool connected(int p, int q)\n\t{\n\t\treturn root(p) == root(q);\n\t}\n\n\tint count(){\n\t\treturn counter;\n\t}\nprivate:\n\tint counter;\n\tvector<int> id;\n\tvector<int> sz;\n};\n    int numIslands(vector<vector<char>>& grid) {\n        int rows = grid.size();\n        if(rows == 0) return 0;\n        int cols = grid[0].size();\n        if(cols == 0) return 0;\n        int n = rows * cols;\n        int zeros = 0;\n        UF uf(n);\n        for(int i = 0; i < rows; ++i){\n            for(int j = 0; j < cols; ++j){\n                if(grid[i][j] == '1'){\n                    int id = i*cols + j;\n                    if(i+1<=rows-1 && grid[i+1][j] == '1'){\n                        uf.uni(id, id + cols);\n                    }\n                    if(j+1<=cols-1 && grid[i][j+1] == '1'){\n                        uf.uni(id, id + 1);\n                    }\n                }\n                else\n                {\n                    ++zeros;\n                }\n            }\n        }\n        return uf.count() - zeros;\n    }\n};"
		],
		[
			17.53274812616522,
			15.219194096954734,
			14,
			55.5882,
			"class Solution {\nprivate:\n    int row, column;\n    void traverse(vector<vector<char>>& grid, int r, int c)\n    {\n        grid[r][c] = '0';\n        if(r-1>-1 && grid[r-1][c]=='1') traverse(grid, r-1, c);\n        if(c-1>-1 && grid[r][c-1]=='1') traverse(grid, r, c-1);\n        if(r+1<row && grid[r+1][c]=='1') traverse(grid, r+1, c);\n        if(c+1<column && grid[r][c+1]=='1') traverse(grid, r, c+1); \n        \n    }\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        row=grid.size();\n        if(!row) return 0;\n        column=grid[0].size();\n        int count = 0;\n        for(int r = 0; r < row; r++)\n            for(int c = 0; c < column; c++)\n                if(grid[r][c] == '1') count++,traverse(grid, r, c);\n        return count;\n    }\n};"
		],
		[
			26.506908569306155,
			20.203928002449988,
			11,
			34.1136,
			"class Solution {\npublic:\n    bool DFS(vector<vector<char>>& grid, int i, int j) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n            return false;\n        grid[i][j] = '0';\n        vector<pair<int, int>> dirs = {{-1,0}, {0,-1}, {1,0}, {0,1}};\n        for (auto dir : dirs) {\n            DFS(grid, i + dir.first, j + dir.second);\n        }\n        return true;\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        int ans = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (DFS(grid, i, j))\n                    ans++;\n            }\n        }\n        return ans;\n    }\n};"
		],
		[
			18.543562054819226,
			16.986486728617333,
			14,
			56.28,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int row = grid.size();\n        if (row == 0)\n            return 0;\n        int col = grid[0].size();\n        if (col == 0)\n            return 0;\n\n        vector<vector<int>> visited(row, vector<int>(col, 0));\n        \n        int count = 0;\n        int i = 0;\n        int j = 0;\n        \n        for (i = 0; i < row; i++)\n        {\n            for (j = 0; j < col; j++)\n            {\n                if ( (visited[i][j] == 0) && (grid[i][j] == '1') )\n                {\n                    count++;\n                    dfs(grid, visited, i, j, row, col);\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    void dfs(vector<vector<char>> &grid, vector<vector<int>> &visited, int i, int j, int row, int col)\n    {\n        if (i < 0 || i >= row || j < 0 || j >= col)\n            return;\n        \n        if (grid[i][j] == '0' || visited[i][j] == 1)//water or has been visited\n            return;\n            \n        visited[i][j] = 1;\n        \n        dfs(grid, visited, i-1, j, row, col);//up\n        dfs(grid, visited, i, j+1, row, col);//right\n        dfs(grid, visited, i+1, j, row, col);//down\n        dfs(grid, visited, i, j-1, row, col);//left\n    }\n};"
		],
		[
			19.814706603328652,
			16.986474838193747,
			18,
			44.1224,
			"//number of islands\n//\u8f6c\u6362\u6210\u4e00\u7ef4id\uff0c\u5b58\u5165\u8fb9\u96c6\u5408\uff0c\u7136\u540e\u6c42\u8fde\u901a\u5206\u91cf\u7684\u4e2a\u6570\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char> >& grid) {\n        if (grid.size() == 0) return 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        //first convert to 1 dimension position, and convert all connections to edges\n        vector<pair<int, int> >edges;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    int id = i * n + j;\n                    //go right\n                    if (j + 1 < n) {\n                        if (grid[i][j+1] == '1') {\n                            int right = i * n + j + 1;\n                            edges.push_back(make_pair(id, right));\n                        }\n                    }\n                    //go down\n                    if (i + 1 < m) {\n                        if (grid[i+1][j] == '1') {\n                            int down = (i + 1) * n + j;\n                            edges.push_back(make_pair(id, down));\n                        }\n                    }\n                }\n            }\n        }\n        \n        //First construct the Union Find structure\n        vector<int> hashSet(m * n, 0);\n        for (int i = 0; i < m * n; i++) {\n            hashSet[i] = i;\n        }\n        \n        //Next Union Find\n        for (auto edge : edges) {\n            Union(hashSet, edge.first, edge.second);\n        }\n        \n        int numComponents = 0;\n        for (int i = 0; i < m * n; i++) {\n            if ( grid[i / n][i % n] == '1' && hashSet[i] == i)\n                numComponents++;\n        }\n        \n        return numComponents;\n    }\n    \n    void Union(vector<int>& hashSet, int first, int second) {\n        int first_father = Find(hashSet, first);\n        int second_father = Find(hashSet, second);\n        \n        if (first_father != second_father)\n            hashSet[first_father] = second_father;\n    }\n    \n    int Find(vector<int>& hashSet, int val) {\n        int parent = val;\n        while (parent != hashSet[parent]) {\n            parent = hashSet[parent];\n        }\n        return parent;\n    }\n};"
		],
		[
			18.469528045489046,
			15.219194096954734,
			11,
			49.2812,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n        int count = 0;\n        for(int i = 0; i < grid.size(); i++)\n        {\n            for(int j = 0; j < grid[i].size(); j++)\n            {\n                if (grid[i][j] == '1')\n                {\n                    count++;\n                    depthFirstSearch(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n    \n    void depthFirstSearch(vector<vector<char>>& grid, int x, int y)\n    {\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size())\n            return;\n        if (grid[x][y] == '0')\n            return;\n        if (grid[x][y] == '1')\n        {\n            grid[x][y] = '0';\n            depthFirstSearch(grid, x + 1, y);\n            depthFirstSearch(grid, x - 1, y);\n            depthFirstSearch(grid, x, y + 1);\n            depthFirstSearch(grid, x, y - 1);\n        }\n    }\n};"
		],
		[
			18.918594699036962,
			16.986474838193747,
			16,
			43.4483,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n  int N = grid.size();\n  int count = 0;\n  vector<int> parent(N ? N * grid[0].size() : 0);\n  for (int r = 0; r < grid.size(); ++r) {\n    for (int c = 0; c < grid[r].size(); ++c) {\n      if (grid[r][c] == '1') {\n        ++count;\n        int i = idx(r, c, N);\n        parent[i] = i;\n        if (r > 0 && grid[r-1][c] == '1' && doUnion(i, idx(r-1, c, N), parent))\n          --count;\n        if (c > 0 && grid[r][c-1] == '1' && doUnion(i, idx(r, c-1, N), parent))\n          --count;\n      }\n    }\n  }\n  return count;\n}\n\nbool doUnion(int x, int y, vector<int>& parent) {\n  int rootx = find(x, parent);\n  int rooty = find(y, parent);\n  if (rootx == rooty)\n      return false;\n  parent[rooty] = rootx;\n  return true;\n}\n\nint find(int x, vector<int>& parent) {\n  return (parent[x] == x) ? x : find(parent[x], parent);\n}\n\ninline int idx(int row, int col, int nrows) { return col * nrows + row; }\n};"
		],
		[
			8.925242314860563,
			15.219194096954734,
			12,
			35.625,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n    const int row = grid.size();\n    if (0 == row) return 0;\n    const int col = grid[0].size();\n    int cnt = 0;\n    for (int i = 0; i < row; i++)\n     for (int j = 0; j < col; j++) {\n         if (grid[i][j] == '1') {\n             cnt++;\n             dfs(grid, i, j);\n         }\n     }\n     return cnt;\n}\nvoid dfs(vector<vector<char>> &grid, int i, int j) {\n    if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != '1') return;\n    grid[i][j] = '2';\n    vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    for (auto dir : dirs) dfs(grid, i + dir.first, j + dir.second);\n}\n};"
		],
		[
			18.477396247312658,
			15.219194096954734,
			10,
			53.6071,
			"class Solution {\npublic:\nvoid DFS(vector<vector<char>>& grid, int i, int j){\n\t    if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return;\n\t    if('0' == grid[i][j]) return;\n\t    grid[i][j] = '0';\n\t    DFS(grid, i-1, j);\n\t    DFS(grid, i+1, j);\n\t    DFS(grid, i, j - 1);\n\t    DFS(grid, i, j + 1);\n\t}\n\tint numIslands(vector<vector<char>>& grid) {\n\t\tint counter = 0;\n\t\tfor (int i = 0; i < grid.size(); ++i)\n\t\t\tfor (int j = 0; j < grid[i].size(); ++j)\n\t\t\t\tif ('1' == grid[i][j])\n\t\t\t\t{\n\t\t\t\t\t++counter;\n\t\t\t\t\tDFS(grid, i, j);\n\t\t\t\t}\n\t\treturn counter;\n\t}\n};"
		],
		[
			17.0704332711851,
			16.986486728617336,
			15,
			47.5,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n    if (grid.size() == 0) return 0;\n    vector<vector<int>> cnt(grid.size(), vector<int>(grid[0].size(), 0));\n    \n    int max = 0;\n    int dup = 0;\n    map<int, int> mapping;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == '1') {\n                int a = (i == 0) ? 0: cnt[i-1][j]; \n                int b = (j == 0) ? 0: cnt[i][j-1];\n                if (a == 0 && b == 0) {\n                    max++;\n                    cnt[i][j] = max;\n                    mapping[max] = max;\n                } else if (a == 0) { // b != 0\n                    cnt[i][j] = b;\n                } else if (b == 0) { // a != 0\n                    cnt[i][j] = a;\n                } else if (a == b) {\n                    cnt[i][j] = a;\n                } else { // both not zero and not equal\n                    if (mapping[a] != mapping[b]) {\n                        dup++;\n                        if (mapping[a] > mapping[b]) {\n                            remap(mapping, a, mapping[b]);\n                        } else {\n                            remap(mapping, b, mapping[a]);\n                        }\n                    }\n                    cnt[i][j] = mapping[a];\n                }\n            }\n        }\n    }\n    return max - dup;\n}\n\nvoid remap(map<int,int>& mapping, int key, int val) {\n    mapping[mapping[key]] = val; // important\n    mapping[key] = val;\n} };"
		],
		[
			17.46591002623481,
			15.219194096954734,
			12,
			34.3966,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0, offsets[] = {0, 1, 0, -1, 0};\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    grid[i][j] = '0';\n                    queue<pair<int, int>> todo;\n                    todo.push({i, j});\n                    while (!todo.empty()) {\n                        pair<int, int> p = todo.front();\n                        todo.pop();\n                        for (int k = 0; k < 4; k++) {\n                            int r = p.first + offsets[k], c = p.second + offsets[k + 1];\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == '1') {\n                                grid[r][c] = '0';\n                                todo.push({r, c});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return islands;\n    }\n};"
		],
		[
			17.556191508388032,
			15.219194096954734,
			11,
			47.6471,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    eraseIslands(grid, i, j);\n                }\n            }\n        }\n        return islands;\n    }\nprivate:\n    void eraseIslands(vector<vector<char>>& grid, int i, int j) {\n        int m = grid.size(), n = grid[0].size();\n        if (i < 0 || i == m || j < 0 || j == n || grid[i][j] == '0') {\n            return;\n        }\n        grid[i][j] = '0';\n        eraseIslands(grid, i - 1, j);\n        eraseIslands(grid, i + 1, j);\n        eraseIslands(grid, i, j - 1);\n        eraseIslands(grid, i, j + 1);\n    }\n};"
		],
		[
			17.491307118406898,
			15.219194096954734,
			11,
			25.4167,
			"class Solution {\npublic:\n    int maxX, maxY, res = 0;\n    void dfs(vector<vector<char>>& grid, int x, int y) {\n\t    // checking if we are out of bounds\n        if (x < 0 || x == maxX || y < 0 || y == maxY) return;\n        char &currCell = grid[y][x];\n        if (currCell != '1') return;\n        // we mark it as visited\n        currCell = '#';\n        // exploring right, left, down, up\n        dfs(grid, x + 1, y);\n        dfs(grid, x - 1, y);\n        dfs(grid, x, y + 1);\n        dfs(grid, x, y - 1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        maxY = grid.size();\n        // exit condition for empty map\n        if (!maxY) return res;\n        maxX = grid[0].size();\n        for (int y = 0; y < maxY; y++) {\n            for (int x = 0; x < maxX; x++) {\n                if (grid[y][x] == '1') {\n                    // oh, we found an island!\n                    res++;\n                    // then we need to mark all the tiles on that island as visited!\n                    dfs(grid, x, y);\n                }\n            }\n        }\n        return res;\n    }\n};"
		],
		[
			17.36516941738023,
			15.219194096954734,
			14,
			28.8372,
			"class Solution {\npublic:\n    int maxX, maxY, res = 0;\n    void dfs(vector<vector<char>>& grid, int x, int y) {\n        char &currCell = grid[y][x];\n        if (currCell != '1') return;\n        // we mark it as visited\n        currCell = '#';\n        // exploring right, left, down, up\n        if (x + 1 < maxX) dfs(grid, x + 1, y);\n        if (x > 0 || x == maxX || y < 0 || y == maxY) dfs(grid, x - 1, y);\n        if (y + 1 < maxY) dfs(grid, x, y + 1);\n        if (y > 0) dfs(grid, x, y - 1);\n    }\n    int numIslands(vector<vector<char>>& grid) {\n        maxY = grid.size();\n        // exit condition for empty map\n        if (!maxY) return res;\n        maxX = grid[0].size();\n        for (int y = 0; y < maxY; y++) {\n            for (int x = 0; x < maxX; x++) {\n                if (grid[y][x] == '1') {\n                    // oh, we found an island!\n                    res++;\n                    // then we need to mark all the tiles on that island as visited!\n                    dfs(grid, x, y);\n                }\n            }\n        }\n        return res;\n    }\n};"
		],
		[
			17.73848824349856,
			15.219194096954734,
			11,
			49.6111,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n        int label = 0;\n        int rowNum = grid.size(), colNum = rowNum ? grid[0].size() : 0;\n        \n        for (int i = 0; i < rowNum; ++i) {\n            for (int j = 0; j < colNum; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j, rowNum, colNum);\n                    ++label;\n                }\n            }\n        }\n        \n        return label;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int row, int col, \n                      int& rowNum, int& colNum) {\n        if (row < 0 || col < 0 || row >= rowNum || col >= colNum || grid[row][col] == '0') return;\n        \n        grid[row][col] = '0';\n        dfs(grid, row + 1, col, colNum, rowNum);\n        dfs(grid, row - 1, col, colNum, rowNum);\n        dfs(grid, row, col + 1, colNum, rowNum);\n        dfs(grid, row, col - 1, colNum, rowNum);\n    }\n};"
		],
		[
			16.57657017333483,
			15.219194096954734,
			12,
			48.0278,
			"class Solution {\npublic:\nint numIslands(vector<vector<char>>& grid) {\n        int label = 0;\n        int rowNum = grid.size(), colNum = rowNum ? grid[0].size() : 0;\n        \n        for (int i = 0; i < rowNum; ++i) {\n            for (int j = 0; j < colNum; ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    ++label;\n                }\n            }\n        }\n\t\t\n        return label;\n    }\n    \n    void dfs(vector<vector<char>>& grid, int row, int col) {\n        int rowNum = grid.size(), colNum = rowNum ? grid[0].size() : 0;\n        if (row < 0 || col < 0 || row >= rowNum || col >= colNum || grid[row][col] == '0') return;\n        \n        grid[row][col] = '0';\n        dfs(grid, row + 1, col);\n        dfs(grid, row - 1, col);\n        dfs(grid, row, col + 1);\n        dfs(grid, row, col - 1);\n    }\n};"
		],
		[
			17.704868590400405,
			15.219194096954734,
			13,
			41.6818,
			"class Solution {\npublic:\n   //make as visited as you traverse by making it \"0\"(change from land to water)\n    void bfs(vector<vector<char>>& grid, int i, int j, int n, int m){\n        grid[i][j] = '0';\n        \n        if(i-1 >= 0 && grid[i-1][j] == '1') //up\n            bfs(grid, i-1, j, n, m);\n        if(i+1 < n && grid[i+1][j] == '1') //down\n            bfs(grid, i+1, j, n, m);\n        if(j+1 < m && grid[i][j+1] == '1') //right\n            bfs(grid, i, j+1, n, m);\n        if(j-1 >= 0 && grid[i][j-1] == '1') //left\n            bfs(grid, i, j-1, n, m);\n    }\n        \n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < m; j++){\n                if(grid[i][j] == '1'){\n                    bfs(grid, i, j , n, m);\n                    count++;\n                }    \n            }\n        }\n        return count;\n    }\n};\n"
		],
		[
			8.488312451469056,
			15.219194096954732,
			12,
			59.375,
			"class Solution {\npublic:\n    void dfs(int i, int j, vector<vector<char>>& grid, int rows, int cols){\n        if(i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == '0') return;\n        grid[i][j] = '0';\n        dfs(i - 1, j, grid, rows, cols);\n        dfs(i + 1, j, grid, rows, cols);\n        dfs(i, j - 1, grid, rows, cols);\n        dfs(i, j + 1, grid, rows, cols);\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0 || grid[0].size() == 0) return 0;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int cnt = 0;\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(grid[i][j] == '1'){\n                    dfs(i, j, grid, rows, cols);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			18.322485165105434,
			15.219194096954734,
			24,
			69.4878,
			"typedef pair<int, int> pii;\n\nclass Solution {\npublic:\n    void makeSet(pii x, map<pii, pair<pii, int>>& m, int& cnt){\n        m.insert(make_pair(x, make_pair(x, 0)));\n        cnt++;\n    }\n    \n    pii findSet(pii x, map<pii, pair<pii, int>>& m){\n        if(m[x].first == x) return x;\n        else{\n            m[x].first = findSet(m[x].first, m);\n            return m[x].first; \n        }\n    }\n    \n    void unionSet(pii x, pii y, map<pii, pair<pii, int>>& m, int& cnt){\n        pii parX = findSet(x, m);\n        pii parY = findSet(y, m);\n        if(parX == parY) return;\n        \n        int rankX = m[parX].second; \n        int rankY = m[parY].second;\n        if(rankX < rankY) m[parX].first = parY;\n        else m[parY].first = parX;\n        \n        if(rankX == rankY) m[parX].second += 1; \n        cnt--; \n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0 || grid[0].size() == 0) return 0;\n        int rows = grid.size(), cols = grid[0].size();\n        map<pii, pair<pii, int>> m; // map to parent & rank\n        int cnt = 0; // counter for sets\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(grid[i][j] == '1') makeSet(make_pair(i, j), m, cnt);\n            }\n        }\n        int x = 0, y = 0;\n        for(int i = 0; i < rows; i++){\n            for(int j = 0; j < cols; j++){\n                if(grid[i][j] == '1'){\n                    // explore four directions\n                    x = i - 1;\n                    y = j;\n                    if(x >= 0 && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                    x = i + 1;\n                    if(x < rows && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                    x = i;\n                    y = j - 1;\n                    if(y >= 0 && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                    y = j + 1;\n                    if(y < cols && grid[x][y] == '1')\n                        unionSet(make_pair(i, j), make_pair(x, y), m, cnt);\n                }\n            }\n        }\n        return cnt;\n    }\n};"
		],
		[
			17.404876132669727,
			15.219194096954734,
			14,
			51.3043,
			"class Solution {\npublic:\n    \n    void DepthFirstSearch(vector<vector<char>> &grid, int r, int c){\n        int Rows = grid.size();\n        int Columns = grid[0].size();\n        \n        grid[r][c] = '0';\n        \n        if (r+1 <  Rows    && grid[r+1][c] == '1') DepthFirstSearch(grid, r+1, c); //visit uper\n        if (r-1 >= 0       && grid[r-1][c] == '1') DepthFirstSearch(grid, r-1, c); //visit lower \n        if (c+1 <  Columns && grid[r][c+1] == '1') DepthFirstSearch(grid, r, c+1); //visit right\n        if (c-1 >= 0       && grid[r][c-1] == '1') DepthFirstSearch(grid, r, c-1); //visit left\n        \n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int numberOfIslands = 0;\n        int Rows = grid.size();\n        if (Rows == 0) return 0;\n        int Columns = grid[0].size();\n        \n        for (int iI = 0; iI < Rows; iI++){\n            for (int iJ = 0; iJ < Columns; iJ++){\n                if (grid[iI][iJ] == '1'){\n                    numberOfIslands++;\n                    DepthFirstSearch(grid, iI, iJ);\n                }\n            }\n        }\n        \n        return numberOfIslands;\n    }\n};"
		],
		[
			1.0,
			1.0,
			14,
			52.6923,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int numberOfIslands = 0;\n        int Rows = grid.size();\n        if (Rows == 0) return 0;\n        int Columns = grid[0].size(); \n        \n        stack<pair<int, int>> s;\n        \n        for (int iI = 0; iI < Rows; iI++){\n            for(int iJ = 0; iJ < Columns; iJ++){\n                if (grid[iI][iJ] == '1'){\n                    numberOfIslands++;\n                    grid[iI][iJ] = '0';\n                    s.push(pair(iI, iJ));\n                    while(!s.empty()){\n                        pair rc = s.top();\n                        s.pop();\n                        int r = rc.first, c = rc.second;\n                        if(r+1 < Rows    && grid[r+1][c] == '1'){\n                            s.push(pair(r+1,c));\n                            grid[r+1][c] = '0';\n                        }\n                        if(r-1 >= 0      && grid[r-1][c] == '1'){\n                            s.push(pair(r-1,c));\n                            grid[r-1][c] = '0';\n                        }\n                        if(c+1 < Columns && grid[r][c+1] == '1'){\n                            s.push(pair(r,c+1));\n                            grid[r][c+1] = '0';\n                        }\n                        if(c-1 >= 0      && grid[r][c-1] == '1'){\n                            s.push(pair(r,c-1));\n                            grid[r][c-1] = '0';\n                        }\n                    }\n                }\n            }\n        }\n        \n        return numberOfIslands;\n    }\n};"
		],
		[
			18.29725288472175,
			15.219194096954734,
			12,
			38.641,
			"class Solution {\npublic:\n    //dfs + recursive\n    //time: o(row * column)\n    //space: o(row)\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty())\n            return 0;\n        \n        int count_of_islands = 0;\n        for(int row = 0; row < grid.size(); ++row) {\n            for(int col = 0; col < grid[0].size(); ++col) {\n                if(grid[row][col] == '1') {\n                    ++count_of_islands;\n                    dfs(grid, row, col);//use dfs to mark every grid = 2 which belongs to this island.\n                }   \n            }  \n        }\n        return count_of_islands;\n    }\nprivate:\n    //dfs to mark every grid in this island.\n    int dfs(vector<vector<char>>& grid, int row, int col) {\n        grid[row][col] = '2';\n        for(auto d : dir) {\n            int next_row = row + d.first;\n            int next_col = col + d.second;\n            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == '1') {\n                dfs(grid, next_row, next_col);\n            }   \n        }\n        return 0;\n    }\nprivate:\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\n};"
		],
		[
			17.963240361730616,
			15.219194096954734,
			12,
			40.6154,
			"class Solution {\npublic:\n    //bfs + iterative\n    //time: o(row * column)\n    //space: o(column)\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty())\n            return 0;\n        \n        int count_of_islands = 0;\n        for(int row = 0; row < grid.size(); ++row) {\n            for(int col = 0; col < grid[0].size(); ++col) {\n                if(grid[row][col] == '1') {\n                    ++count_of_islands;\n                    std::queue<pair<int, int>> bfs_que;//<row, column>\n                    grid[row][col] = '2';\n                    bfs_que.push(make_pair(row, col));\n                    while(!bfs_que.empty()) {\n                        std::pair<int, int> visited_node = bfs_que.front();\n                        bfs_que.pop();\n                        for(auto d : dir) {\n                            int next_row = visited_node.first + d.first;\n                            int next_col = visited_node.second + d.second;\n                            if(next_row >= 0 && next_row < grid.size() && next_col >= 0 && next_col < grid[0].size() && grid[next_row][next_col] == '1') {\n                                grid[next_row][next_col] = '2';\n                                bfs_que.push(make_pair(next_row, next_col));\n                            }\n                            \n                        }\n                    }\n                }   \n            }  \n        }\n        return count_of_islands;\n    }\n\nprivate:\n    vector<pair<int, int>> dir{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};//<row, column>\n};"
		],
		[
			19.23467203633026,
			15.219198662624617,
			12,
			44.5946,
			"class Solution {\npublic:\n    int nr_row, nr_col;\n    const int TYPE_WATER = 0x7fffffff;\n    int numIslands(vector<vector<char> > &grid) {\n        if (grid.empty() || grid[0].empty()) {\n            return 0;\n        }\n        nr_row = grid.size();\n        nr_col = grid[0].size();\n\n        int type_num = 0;\n        vector<int> type(nr_col + 1, TYPE_WATER); //type[k+1] => grid[x][k] type\n        unordered_map<int, int> table;            //\u5e76\u67e5\u96c6, disjoint set\n        for (int i = 0; i < nr_row; ++i) {\n            for (int j = 0; j < nr_col; ++j) {\n                int near_type = min(type[j], type[j+1]);\n                if (grid[i][j] == '1') {\n                    if (type[j] != TYPE_WATER && type[j+1] != TYPE_WATER) {\n                        int group1 = find_parent(table, type[j]);\n                        int group2 = find_parent(table, type[j+1]);\n                        table[max(group1, group2)] = min(group1, group2);\n                    }\n                    if (near_type == TYPE_WATER) {\n                        type[j+1] = ++type_num;\n                        table[type[j+1]] = type[j+1];\n                    } else {\n                        type[j+1] = near_type;\n                    }\n                } else {\n                    type[j+1] = TYPE_WATER;\n                }\n            }\n        }\n\n        unordered_set<int> s;\n        for (int i = 1; i <= type_num; ++i) {\n            s.insert(find_parent(table, i));\n        }\n        return s.size();\n    }\n\n    int find_parent(unordered_map<int, int> &table, int type) {\n        return table[type] == type ? type :\n                table[type] = find_parent(table, table[type]);\n    }\n};"
		],
		[
			17.96068141855459,
			15.317879321466405,
			19,
			48.7097,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0){\n            return 0;\n        }\n        int m = grid.size();\n        int n = grid[0].size();\n        int ret = 0;\n        stack<pair<int, int>> s;\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == '1' && !visited[i][j]){\n                    ret++;\n                    s.push(make_pair(i, j));\n                    while(!s.empty()){\n                        pair<int, int> cur = s.top();\n                        s.pop();\n                        int x = cur.first;\n                        int y = cur.second;\n                        visited[x][y] = true;\n                        if((x+1) < m && grid[x+1][y] == '1' && !visited[x+1][y]){\n                            s.push(make_pair(x+1, y));\n                        }\n                        if((x-1) >=0 && grid[x-1][y] == '1' && !visited[x-1][y]){\n                            s.push(make_pair(x-1, y));\n                        }\n                        if((y+1) < n && grid[x][y+1] == '1' && !visited[x][y+1]){\n                            s.push(make_pair(x, y+1));\n                        }\n                        if((y-1) >= 0 && grid[x][y-1] == '1' && !visited[x][y-1]){\n                            s.push(make_pair(x, y-1));\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};"
		],
		[
			17.452535403499265,
			15.318386844219892,
			19,
			48.7097,
			"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size() == 0){\n            return 0;\n        }\n        int m = grid.size();\n        int n = grid[0].size();\n        int ret = 0;\n        queue<pair<int, int>> q;\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == '1' && !visited[i][j]){\n                    ret++;\n                    q.push(make_pair(i, j));\n                    while(!q.empty()){\n                        pair<int, int> cur = q.front();\n                        q.pop();\n                        int x = cur.first;\n                        int y = cur.second;\n                        visited[x][y] = true;\n                        if((x+1) < m && grid[x+1][y] == '1' && !visited[x+1][y]){\n                            q.push(make_pair(x+1, y));\n                        }\n                        if((x-1) >=0 && grid[x-1][y] == '1' && !visited[x-1][y]){\n                            q.push(make_pair(x-1, y));\n                        }\n                        if((y+1) < n && grid[x][y+1] == '1' && !visited[x][y+1]){\n                            q.push(make_pair(x, y+1));\n                        }\n                        if((y-1) >= 0 && grid[x][y-1] == '1' && !visited[x][y-1]){\n                            q.push(make_pair(x, y-1));\n                        }\n                    }\n                }\n            }\n        }\n        return ret;\n    }\n};"
		],
		[
			18.120830949930188,
			15.219194096954734,
			10,
			53.6071,
			"class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid,int i,int j){\n        if(i<0||j<0||i>=grid.size()||j>=grid[i].size()||grid[i][j]=='0')\n            return;\n        grid[i][j]='0';\n        dfs(grid,i+1,j);\n        dfs(grid,i-1,j);\n           dfs(grid,i,j-1);\n         dfs(grid,i,j+1);\n        return ;\n        }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        int x=0;\n        for(int i=0;i<grid.size();i++){\n            for(int j=0;j<grid[i].size();j++){\n                if(grid[i][j]=='1'){\n                    dfs(grid,i,j);\n                    x++;   \n                }\n            }         \n        }\n          return x;  }};"
		],
		[
			17.290091497649605,
			15.219194096954734,
			11,
			44.5,
			"class Solution {\npublic:\n    int count=0;\n    int numIslands(vector<vector<char>>& grid) {\n        int row=grid.size();\n        int col=grid[0].size();\n        for (int i=0; i<row; i++) {\n            for (int j=0; j<col; j++) {\n                if (grid[i][j]=='1') count++, dfs (grid, i, j) ;\n            }\n        }\n        return count;\n    }\n    void dfs (vector<vector<char>> &grid, int i, int j) {\n        if (i<0 || j<0 || i>=grid.size() || j>=grid[0].size() || grid[i][j]!='1') return;\n        grid[i][j]='0';\n        vector <vector<int>> v={{0,1}, {1,0}, {-1,0}, {0,-1}};\n        for (int x=0; x<4; x++) {\n            dfs (grid, i+v[x][0], j+v[x][1]);\n        }\n    }\n};\n"
		],
		[
			17.586095340941668,
			15.219194096954734,
			12,
			39.4615,
			"class Solution {\npublic:\n    int rowArr[4] = {1, -1, 0, 0};\n    int colArr[4] = {0, 0, 1, -1};\n    \n    bool isValid(vector<vector<char>>& grid, int i, int j){\n        int R = grid.size();\n        int C = grid[0].size();\n        return i>=0 && i<R && j>=0 && j<C && grid[i][j] == '1';\n    }\n    \n    void dfs(vector<vector<char>>& grid, int i, int j){\n        \n        grid[i][j] = '0';\n        for(int k = 0; k<4; k++){\n            int r = i + rowArr[k];\n            int c = j + colArr[k];\n            \n            if(isValid(grid, r, c))\n                dfs(grid, r, c);\n        }\n    }\n    \n    int numIslands(vector<vector<char>>& grid) {\n        \n        int rows = grid.size();\n        int cols = grid[0].size();\n        int cnt = 0;\n      \n        for(int i = 0; i<rows; i++){\n            for(int j = 0; j<cols; j++){\n                if(grid[i][j] == '1'){\n                    dfs(grid, i, j);\n                    cnt++;\n                }\n            }\n        }\n        return cnt;\n    }\n};\n"
		],
		[
			18.319211116320275,
			15.219194096954734,
			11,
			59.5385,
			"class Solution {\npublic:\n      int dfs(vector<vector<char>>& grid,int i,int j){\n        if(i<0||j<0||i>grid.size()-1||j>grid[0].size()-1||grid[i][j]=='0')\n            return 0;\n        grid[i][j]='0';\n        dfs(grid,i+1,j);\n        dfs(grid,i-1,j);\n        dfs(grid,i,j+1);\n        dfs(grid,i,j-1);\n          \n        return 1;  \n    } \n\t\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.size()==0 )  return 0;\n        int ans=0;\n        for(int i=0;i<grid.size();i++)\n\t\t{\n            for(int j=0;j<grid[0].size();j++)\n\t\t\t{\n                if(grid[i][j]=='1')\n                {  \n                    ans+=dfs(grid,i,j);            \n                }\n            }\n        }\n        return ans;\n    }\n};"
		]
	],
	"CATALAN_NUM": [
		"n^2",
		[
			16.596898230666657,
			4.266807006446484,
			3,
			24.0,
			"class Solution {\npublic:\n    #include<vector>\n    int numTrees(int n) {\n        vector<int> dp(n+1);\n        dp[0]=1;\n        dp[1]=1;\n        for(int i=2;i<=n;i++){\n            for(int j=0;j<i;j++){\n                dp[i]+=(dp[j]*dp[i-j-1]);\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			16.50245106567796,
			4.266807006446484,
			10,
			29.9178,
			"/*\n    https://leetcode.com/problems/unique-binary-search-trees/\n    \n    For a current n, each node 'i' till 'n' can become\n    a root, and the elements smaller than 'i' are left \n    subtree nodes and greater than 'i' are part of right subtree.\n    Both left and right subtree nodes then again be arranged amongst themselves\n*/\nclass Solution {\npublic:\n    // using bottom-up approach\n    int numTreesTabular(int n) {\n        if(n <= 1)\n            return 1;\n        \n        vector<int> dp(n + 1, 0);\n        // there is exactly one way to get a BST with 0 or 1 node\n        dp[0] = dp[1] = 1;\n        \n        // Cn = Sum( Ci * C((n-1) - i)) , 0 <= i <= n-1\n        for(int i = 2; i <= n; i++) {\n            for(int j = 0; j <= i-1; j++) {\n                dp[i] += dp[j] * dp[i - 1 - j];\n            }\n        }\n        return dp[n];\n    }\n    \n    // using memoization\n    int numTreesRec(int n, vector<int>& dp) {\n        if(n <= 1)\n            return 1;\n        \n        // for current n, each node 'i' till 'n' can become\n        // a root, and the elements smaller than 'i' are left \n        // subtree and greater than 'i' are part of right subtree\n        // both left and right subtree nodes then again be arranged amongst themselves\n        if(dp[n] == 0) {\n            for(int i = 1; i <= n; i++) \n                dp[n] += numTreesRec(i - 1, dp) * numTreesRec(n - i, dp);\n        }\n        return dp[n];\n    }\n    \n    // driver function for memoization\n    int numTreesRecDriver(int n) {\n        vector<int> dp(n + 1, 0);\n        return numTreesRec(n, dp);\n    }\n    \n    \n    int numTrees(int n) {\n        // return numTreesRecDriver(n);\n        return numTreesTabular(n);\n    }\n};\n"
		],
		[
			16.587460998767593,
			4.266807006446484,
			3,
			27.2,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int>dp(n+1,0);\n        dp[0]=1;\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=i;j++)\n                dp[i]+=dp[i-j]*dp[j-1];\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			16.60246653373426,
			4.266807006446484,
			4,
			40.7143,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        // trival cases\n        if (n <= 1) {\n            return n;\n        }\n        // dp: dp[k] = sum_{j=0}^{k-1} (dp[j] * dp[k-j-1]) \n        vector<int> dp(n+1, 0);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for (int k(2); k <= n; ++k) {\n            dp[k] = 0;\n            for (int j(0); j < k; ++j) {\n                dp[k] += dp[j] * dp[k-j-1];\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			16.49088920956099,
			4.266807006446484,
			3,
			21.1765,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 10, 0);\n        dp[0] = 1; // Null tree is still a tree\n        dp[1] = 1;\n        for (int i{2}; i <= n; i++) {\n            for (int j{}; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n};"
		],
		[
			16.61694264238349,
			4.266807006446483,
			3,
			25.65,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n+1,0);\n        dp[1] = 1;\n        for(int i=2; i<=n;i++){\n            // when n is leaf node or root node, count of such trees is dp[n-1]\n            dp[i]+= 2*dp[i-1];\n\n         // when n is intermediate node we have nodes on both sides of node n \n        // if there are x nodes above node n, no of trees which can be formed above =dp[x]\n        // There will be n-1 - x nodes below node n \n        // no of trees which can be formed  below = dp[n-1-x]\n    \n        // we can select any permutation of the trees above and below\n    //therefore total number of trees with node n as intermediate  =  dp[x] * dp[n-1-x]\n            \n            for(int j=1; j<i-1; j++)\n                dp[i]+= dp[j]*dp[i-1-j];\n         \n        }\n        return dp[n];\n        \n    }\n};\n"
		],
		[
			17.89323994372094,
			4.266807006446483,
			5,
			39.75,
			"class Solution {\npublic:\n\tvector<int> v;\n\tint numTressHelper(int n) {\n\t\tif (v[n] != 0)\n\t\t\treturn v[n];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[n] += numTressHelper(i - 1) * numTressHelper(n - i);\n\t\t}\n\t\treturn v[n];\n\n\t}\n\tint numTrees(int n) {\n\t\tv.resize(n + 1);\n\t\tv[0] = 1;\n\t\tv[1] = 1;\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tsum += numTressHelper(i - 1) * numTressHelper(n - i);\n\t\t}\n\t\treturn sum;\n\t}\n};\n"
		],
		[
			15.225480856203466,
			1.0,
			4,
			31.6818,
			"class Solution {\npublic:\n    int numTrees(int n) {\n            \n        if(n<3) return n;\n        \n        int a[n+1],i,j;\n        a[0]=1, a[1]=1;\n        \n        for(i=2;i<=n;i++)\n        {\n            a[i]=0;\n            for(j=0;j<i;j++)\n                a[i] += a[j]*a[i-j-1];\n        }\n        return a[n];\n    }\n};\n"
		],
		[
			16.587971996162597,
			4.266807006446484,
			3,
			27.2,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int k = 1; k <= i; ++k) {\n                dp[i] += dp[k - 1] * dp[i - k];\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			15.454929333326874,
			4.266807006446483,
			4,
			33.3333,
			"class Solution {\npublic:\nint numTrees(int n) {\n    vector<int> trees(n+1, 1);\n    for(int i = 2; i <= n; i++)\n    {\n        int j = 0, k = i-1;\n        for(; j < k; j++, k--)\n            trees[i] += (trees[j] * trees[k] * 2);\n        if(j == k)\n            trees[i] += (trees[j] * trees[k]);\n    }\n    return trees[n];\n}\n};"
		],
		[
			16.58468233032001,
			4.266807006446484,
			6,
			38.0,
			"class Solution {\npublic:\n\tint numTrees(int n) {\n\t\tif(n==0) return 1;\n\t\tif(n==1) return 1;\n\t\tif(n==2) return 2;\n\t\tvector<int> dp(n+1,0);\n\t\tdp[0]=1;\n\t\tdp[1]=1;\n\t\tdp[2]=2;\n\t\tfor(int i=3;i<n+1;i++){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tdp[i]+=dp[j-1]*dp[i-j];\n\t\t\t}\n\t\t}\n\t\treturn dp[n];\n\t}\n};"
		],
		[
			13.91972380513352,
			1.0,
			4,
			42.3182,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[n+1];\n        dp[0]=1,dp[1]=1;\n        for(int i=2;i<=n;i++){\n            int total=0;\n            for(int j=0;j<i/2;j++)\n                total+=dp[j]*dp[i-j-1]*2;\n            dp[i]=total+(i%2==0?0:dp[i/2]*dp[i/2]);\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			53.57160666331231,
			4.266807006446484,
			7,
			30.8125,
			"class Solution {\npublic:\n\nint numTrees(int n) {\n    if (n <= 0) return 0;\n    \n    int result = 0;\n    vector<int> array(n + 1, 0);\n    \n    array[0] = 1;\n    for (int i = 2; i <= n; i++) {\n        int cur = array[0];\n        \n        for (int j = 0; j < i - 1; j++) {\n            int next = array[j + 1];\n            \n            for (int k = 0; k <= j + 1; k++) {\n                if (k != j)\n                    array[k] += cur;\n            }\n            cur = next;\n        }\n    }\n    for (int r = 0; r < n + 1; r++)\n        result += array[r];\n    return result;\n}\n};"
		],
		[
			53.2704430645742,
			4.266807006446484,
			7,
			30.8125,
			"class Solution {\npublic:\n\nint numTrees(int n) {\n    if (n <= 0) return 0;\n    \n    int result = 0;\n    vector<int> array(n + 1, 0);\n    \n    array[0] = 1;\n    for (int i = 2; i <= n; i++) {\n        int cur = array[0];\n        \n        for (int j = 0; j < i - 1; j++) {\n            int next = array[j + 1];\n            \n            for (int k = 0; k <= j + 1; k++) {\n                if (k != j)\n                    array[k] += cur;\n            }\n            cur = next;\n        }\n    }\n    for (int r = 0; r < n + 1; r++)\n        result += array[r];\n    return result;\n}\n};"
		],
		[
			16.826312233465373,
			1.0,
			3,
			28.5,
			"class Solution {\npublic:\nint numTrees(int n) {\nlong long int dp[n+1];\nmemset(dp,0,sizeof(dp));\ndp[0]=1;\nfor(int i=1;i<=2*n;i++){\nfor(int j=min(i,n);j>0;j--){\ndp[j]=dp[j-1]+dp[j];\n}\n}\nreturn dp[n]/(n+1);\n}\n};"
		],
		[
			63.31635937770158,
			16.311521014234586,
			5,
			38.0769,
			"class Solution {\npublic:\nint func(int l,int r,vector<vector<int>>&dp){\n        if(r<l){return 1;}\n        if(dp[l][r]!=-1)return dp[l][r];\n        int temp=0;\n        for(int i=l;i<=r;i++){\n            temp+=func(l,i-1,dp)*func(i+1,r,dp);\n        }\n        return dp[l][r]=temp;\n    }\n    int numTrees(int n) {\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\n        return func(1,n,dp);\n    }\n};"
		],
		[
			17.93647193636917,
			1.0,
			6,
			40.5909,
			"class Solution {\npublic:\nint func(int n,vector<int>&dp){\n        if(n==1 || n==0)return dp[n]=1;\n        if(dp[n]!=-1)return dp[n];\n        int temp=0;\n        for(int i=1;i<=n;i++){\n            temp+=func(i-1,dp)*func(n-i,dp);\n        }\n        return dp[n]=temp;\n    }\n    int numTrees(int n) {\n        vector<int>dp(n+1,-1);\n        return func(n,dp);\n    }\n};"
		],
		[
			15.216281232547278,
			1.0,
			3,
			27.0,
			"class Solution {\npublic:\nint numTrees(int n) {\n\n    int arr[n+1];\n    arr[0]=1;\n    arr[1]=1;\n    \n    for(int i=2;i<=n;i++)\n    {\n        arr[i]=0;\n        for(int j=0;j<i;j++)\n        {\n            arr[i]+=arr[j]*arr[i-j-1];\n        }\n    }\n    return arr[n];\n}\n};"
		],
		[
			15.480694231900548,
			1.0,
			5,
			35.0769,
			"class Solution {\nprivate:\n    int history[10000] = {};\npublic:\n    int numTrees(int n) {\n        if(n<=1) return 1;\n        else{\n            int count = 0;\n            for(int i =1;i<=n ;i++){\n                int left_count = history[i-1];\n                if(!left_count) {\n                    left_count = numTrees(i-1);\n                    history[i-1] = left_count;\n                }\n                int right_count = history[n-i];\n                if(!right_count){\n                    right_count = numTrees(n-i);\n                    history[n-i] = right_count;\n                }\n                count += left_count * right_count;\n            }\n            return count;\n        }\n    }\n};"
		],
		[
			16.606940251111055,
			4.266807006446484,
			4,
			35.1,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if (n < 0) return 1;\n        \n        vector<int> bst(n+1, 0);\n        int i = 0, j = 0;\n        bst[0] = 1;\n        \n        for (i = 1; i <= n; ++i)\n            for (j = 1; j <= i; ++j)\n                bst[i] += (bst[j-1] * bst[i-j]);\n                \n        return bst[n];\n    }\n};"
		],
		[
			16.591353704553132,
			4.8115803230595455,
			3,
			24.0833,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> f;\n        f.push_back(1);\n        for (int i = 1; i <= n; ++ i){\n            f.push_back(0);\n            for (int j = 1; j <= i; ++ j)\n                f[i] += f[j - 1] * f[i - j];\n        }\n        return f[n];\n    }\n};"
		],
		[
			25.238592700965253,
			5.371591767636878,
			3,
			25.5,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        map<int, int> Mymap;\n\t\tMymap[0] = 1;\n\t\tfor (int i = 1; i <= n; i++){\n\t\t    int cont = 0;\n\t\t\tfor (int k = 0; k < i; k++)\n\t\t\tcont+= Mymap[k] * Mymap[i - 1 - k];\n\t\t\tMymap[i] = cont;\n\t\t}\n\t\treturn Mymap[n];\n    }\n};"
		],
		[
			5.0209787817831995,
			1.0,
			2,
			16.6667,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        unsigned long  c=1;\n        for(int i = 1;i < n;  ) c = 2*(++i*2 -1)*c/(i + 1);\n        return c;\n    }\n};\n"
		],
		[
			14.99701051371882,
			1.0,
			5,
			34.7083,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if(n < 2) return 1;\n        if(n == 2) return 2;\n        int DP[n + 1];\n        DP[0] = 1;\n        DP[1] = 1;\n        int sub_res = 0;\n        for(int i = 2; i <= n; i++){\n            sub_res = 0;\n            for(int j = 1; j <= i; j++){\n                sub_res += DP[i - j] * DP[j - 1];\n            } \n            DP[i] = sub_res;\n        }\n        return DP[n];\n    }\n};"
		],
		[
			4.2262224601028615,
			1.0,
			2,
			22.2632,
			"//as for n number of trees possible= ((2n)C(n))/(n+1)\n //(2n)C(n) is equal to ((2n)*(2n-1)*...n terms) / (n*(n-1)*...*1)\n\n class Solution {\n public:\n     int numTrees(int n) {\n         double ans=1,i=2*n;\n         for(int j=1;j<=n;j++,i--){\n             ans*=(i/j);\n              }\n         return ans/(n+1);\n     }\n };"
		],
		[
			16.58211744934605,
			4.266807006446484,
			3,
			23.5385,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1);\n        dp[0]=1;\n        dp[1]=1;\n        for(int i=2;i<=n;i++){\n            for(int j=0;j<i;j++){\n                dp[i]+=dp[j]*dp[i-j-1];  //catalan number\n            }\n        }\n        return dp[n];\n    }\n};"
		],
		[
			16.214592582769352,
			1.0,
			6,
			18.375,
			"class Solution {\npublic:\n    vector<int> sols = {1, 1, 2};\n    int nextSol(int n) {\n        // accumulator variable for the result\n        int res = 0;\n        // and I proceed to consider all the possible occurrences, leveraging pre-computed solutions\n        for (int i = 0; i < n; i++) {\n            res += sols[i] * sols[n - i - 1];\n        }\n        return res;\n    }\n    void expandSols(int n) {\n        // helper to expand sol - notice that I start with lower numbers, going up to n\n        while (sols.size() <= n) {\n            sols.push_back(nextSol(sols.size()));\n        }\n    }\n    int numTrees(int n) {\n        // checks if I have already the results in sol, otherwise it expands it\n        return n < sols.size() ? sols[n] : (expandSols(n), sols[n]);\n    }\n};"
		],
		[
			15.193090077145385,
			1.0,
			3,
			25.2,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[++n];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i < n; i++) {\n            dp[i] = 0;\n            for (int j = 0; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n};"
		],
		[
			16.615334279395483,
			4.266807006446483,
			3,
			19.2273,
			"class Solution {\npublic:\nint numTrees(int n) {\n        // let C[i] be the number of unique binary search trees with 1 to i\n        vector<int> C(n+1,1);\n        \n        for (int i = 2; i <= n; ++i) {\n            C[i] = 0;\n            for (int j = 1; j <= i; ++j) {\n                C[i] += C[j-1] * C[i-j];\n            }\n        }\n        return C[n];\n    }\n};"
		],
		[
			15.48004394832137,
			4.266807006446484,
			4,
			36.0938,
			"class Solution {\npublic:\nint numTrees(int n) \n{\n\tvector<int> t(n + 1, 0);\n\tt[0] = t[1] = 1;\n\tint i, j;\n\tfor (i = 2; i <= n; ++i)\n\t{\n\t\tfor (j = 1; j <= i / 2; ++j)\n\t\t\tt[i] += t[j - 1] * t[i - j];\n\t\tt[i] *= 2;\n\t\tif (i % 2)\n\t\t\tt[i] += t[i / 2] * t[i / 2];//Plus the middle 'root' trees.\n\t}\n\treturn t[n];\n}\n};"
		],
		[
			15.8154629203599,
			4.864390269036466,
			3,
			23.5385,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int sum;\n        vector<int> temp;\n        temp.push_back( 1 );\n        for( int i = 1; i <= n; i++ )\n        {\n            sum = 0;\n            for( int j = 1; j <= i; j++ )\n                sum += temp[ j - 1 ] * temp[ i - j ];\n            \n            temp.push_back( sum );\n        }\n        return temp[ n ];\n    }\n};"
		],
		[
			26.560203241427562,
			5.371591767636878,
			4,
			28.8,
			"class Solution {\npublic:\nint numTrees(int n)\n    {\n    \tif (n <= 0)\n    \t\treturn 0;\n    \n    \tmap<int, int> dic;\n    \tdic[0] = 1;\n    \tfor (int i = 1; i <= n; i++)\n    \t{\n    \t\tfor (int j = 1; j <= i; ++j)\n    \t\t{\n    \t\t\tdic[i] += dic[j - 1] * dic[i - j];\n    \t\t}\n    \t}\n    \treturn dic[n];\n    }\n};"
		],
		[
			15.986863161444013,
			4.789620858732048,
			4,
			27.6923,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if(n == 0)\n        {\n            return 0;\n        }\n        vector<int> ret(1,1);\n        for(int i = 1; i <= n; i++)\n        {\n            int result = 0;\n            for(int j = 0; j < i; j++)\n            {\n                result += ret[j] * ret[i-1 - j];\n            }\n            ret.push_back(result);\n        }\n        return ret[n];\n    }\n};"
		],
		[
			15.211262659983063,
			1.0,
			3,
			27.0,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        \n        int catalan[n+1];\n        \n        catalan[0] = 1;\n        catalan[1] = 1;\n        \n        for(int i=2;i<=n;i++){\n            catalan[i] = 0;\n            for(int j=0;j<i;j++){\n                catalan[i]+= catalan[j]*catalan[i-j-1];\n            }\n        }\n        \n        return catalan[n];\n    }\n};\n"
		],
		[
			15.07355514764985,
			4.266807006446484,
			3,
			24.7059,
			"class Solution\n{\npublic:\n    \tint numTrees( int n )\n    \t{\n\t\t        int * a =new int[n + 1];\n\t\t        a[0] = 0;\n\t\t        a[1] = 1;\n\t\t        a[2] = 2;\n\t\t        a[3] = 5;\n\t\t\n\t\tfor( int i = 4; i <= n; ++i )\n\t\t{\n\t\t\t    int current = 2 * a[i - 1] + 2 * a[i - 2];\n\n\t    \t\tfor( int j = 3; j < i - 1; ++j )\n\t\t    \t{\n\t\t\t        \tcurrent += ( a[j - 1] * a[i - j] );\n\t\t\t    }\n\t\t\t    a[i] = current;\n\t\t}\n\t        \tint out = a[n];\n\t        \tdelete [] a;\n\t\t        return out;\n    \t}\n};"
		],
		[
			16.598700135710203,
			4.266807006446484,
			5,
			31.6667,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        if(n==0)\n            return 1;\n        if(n==1)\n            return 1;\n        vector<int> dp(n+1, 1);\n        int ans=0;\n        for(int i=2;i<=n;i++)\n        {\n            dp[i]=0;\n            for(int j=0;j<i;j++)\n            {\n                dp[i]+=(dp[j]*dp[i-j-1]);\n            }\n        }\n        return dp[n];\n    }\n};\n"
		],
		[
			4.267527688242771,
			1.0,
			2,
			21.4138,
			"class Solution {\npublic:\n\tint numTrees(int n) {\n\t\tdouble ans=1, i=2*n;\n\t\t//using formula directly i.e for value=n, number of trees possible= ((2n)C(n))/(n+1)\n\t\t//calculating numerator (2n)C(n) that is equal to ((2n)*(2n-1)*...n terms) / (n*(n-1)*...*1)\n\n\t\tfor(int j=1; j<=n; i--,j++){ // i goes from 2n to n terms and j goes from 1 to n\n\t\t\tans*= i/j;\n\t\t}\n\n\t\treturn ans/(n+1);\n\t}\n};"
		],
		[
			16.784349363931906,
			4.266807006446484,
			3,
			28.5909,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        \n        vector<int> dp(n+1,0);\n        dp[0]=1;\n        dp[1]=1;\n        for(int i=2;i<=n;i++){\n            \n            \n            for(int j=1;j<=i;j++){\n                dp[i]=dp[i]+(dp[j-1]*dp[i-j]);\n            }\n            \n        }\n        \n        return dp[n];\n    }\n};\n"
		],
		[
			57.301893561890985,
			1.0,
			7,
			38.25,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        int dp[n][n];\n        memset(dp, 0, sizeof(dp));\n        for(int i=0;i<n;i++) {\n            dp[i][i] = 1;\n        }\n        for(int l=2;l<=n;l++) {\n            int i = 0;\n            for(int j=l-1;j<n;j++) {\n                for(int k=0;k<=j;k++) {\n                    dp[i][j] += ((k-1 >= i ? dp[i][k-1] : 1) * (k+1 < j ? dp[k+1][j] : 1));\n                }\n                i++;\n            }\n        }\n        return dp[0][n-1];\n    }\n};"
		],
		[
			16.532855365903885,
			4.266807006446484,
			3,
			24.7273,
			"class Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for(int i = 2; i <= n; i++) {\n            for(int j = 0; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1];\n            }\n        }\n        return dp[n];\n    }\n};\n"
		]
	],
	"REVERSE_INTEGER": [
		"1",
		[
			1.0,
			1.0,
			4,
			12.1875,
			"class Solution {\npublic:\n    int reverse(int xx) {\n      bool neg=false;\n        long long int x=xx;\n        if(x<0)\n        {\n            neg=true;\n            x*=-1;\n        }\n        int ans;\n        string s=to_string(x);\n        std::reverse(s.begin(),s.end());\n        try{\n            ans=stoi(s); \n        }\n        catch(out_of_range& e)\n        {\n            return 0;\n        }\n        if(neg)\n            ans*=-1;\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			15.0,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long result = 0L;\n        while (x) {\n            result = result * 10 + (x % 10);\n            x /= 10;\n        }\n        \n        return (result >= (long) INT_MAX || result <= (long) INT_MIN) ? 0 : result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			14.2222,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int tut = x;\n        if(x >= INT_MAX || x <= INT_MIN){\n            return 0;\n        }\n\t\t//makes positive\n        if(x<0){\n            tut = -tut;\n        }\n        string s = to_string(tut);\n        ::reverse(s.begin(),s.end());\n\t\t//add '-' later\n        if(x<0){\n            s.insert(s.begin(),'-');\n        }\n        try{\n            x = stoi(s);\n        }\n        catch(const std::out_of_range& e){\n            return 0;\n        }\n        return x;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.75,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int rem = 0;\n        while(x)\n            {   if(rem > INT_MAX/10 || rem< INT_MIN/10)\n                    return 0;\n                rem = rem*10 + x%10 ;\n                x =x/10;\n            }   \n    return rem;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			16.875,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x) {\n            if (rev > INT_MAX / 10) return 0; // overflow check\n            if (rev < INT_MIN / 10) return 0;\n            rev = rev * 10 + x % 10;\n            x /= 10;\n        }\n        return rev ;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.2,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long result = 0;\n\n        while(x != 0) {\n            result *= 10;\n            result += x % 10;\n            x /= 10;\n        }\n\n        if (result <= INT_MIN || result >= INT_MAX) {\n            result = 0;\n        }\n        \n        return (int)result;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			22.9091,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long long int rem, ans = 0; \n        while(x > 0 || x < 0){\n            rem = x % 10;\n            ans = (ans * 10) + rem;\n            x /= 10;\n        }\n        if(ans > INT_MAX || ans < INT_MIN){\n            return 0;\n        }\n        else{\n            return ans;\n        }  \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.4091,
			"class Solution {\npublic:\nint reverse(int x) {\n\tint rev = 0;\n\twhile (x != 0) {\n\t\tif (rev > INT_MAX / 10 || rev < INT_MIN / 10)\n\t\t\treturn 0;\n\n\t\tint pop = x % 10;\n\t\trev = rev * 10 + pop;\n\t\tx /= 10;\n\t}\n\treturn rev;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			20.0962,
			"class Solution {\npublic:\n    int reverse(int x) \n    {\n        int flag = 0; //marks negativity \n        \n        if(x < 0)\n            flag = 1;\n        \n        int num = abs(x);\n        long int newNum = 0; //long to avoid integer overflow\n        \n        while(num > 0)\n        {\n            int rem = num % 10;\n            \n            if(newNum*10 > INT_MAX) //to avoid signed integer overflow\n                return 0;\n            \n            newNum = newNum*10 + rem; //Multiply by 10 to increment place value\n            num = num/10;\n        }\n        \n        if(flag == 0)\n            return newNum;\n        \n        else\n            return newNum*(-1);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			22.6667,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        int ori = x;\n\n        bool zeroFlag = true;\n\n        while(ori!=0)\n        {\n            if (ori % 10 == 0 && zeroFlag)\n            {\n                ori = ori / 10;\n                continue;\n            }\n\n            if (rev > INT_MAX / 10 || rev < INT_MIN / 10)\n                return 0;\n\n            rev = rev * 10 + (ori % 10);\n            ori = ori / 10;\n            zeroFlag = false;\n        }\n\n        return rev;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			23.5435,
			"class Solution {\npublic:\n    int reverse(int num) {\n        if(num == -2147483648) return 0;\n        \n        int rev = 0;\n\t    bool isNeg = false;\n\t   \n\t    if(num < 0) {\n\t        isNeg = true;\n\t        num = num * -1;\n\t    }\n\t    \n        while(num >= 10) {\n            rev = rev * 10 + num % 10;\n            num = num / 10;\n        }\n        \n\t\t// Checking for overflow when adding the last digit\n        // 2147483647 / 10 = 214748364\n        if(rev > 214748364) return 0;\n            \n        if(rev >= 214748364 && num > 7) return 0;\n        \n        rev = rev * 10 + num % 10;\n        \n        if(isNeg) {\n            rev = rev * -1;\n        }\n            \n        return  rev;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.2,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long ans=0;\n        while(x!=0)\n        {\n            ans=ans*10+x%10;\n            x=x/10;\n            if(ans>INT_MAX||ans<INT_MIN) return 0;\n        }\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			21.2167,
			"class Solution {\npublic:\n    int reverse(long x)\n    {   \n        long temp = x;\n        \n        // if x is negative, we make it positive and reverse it and then add sign at returning\n        if(x < 0)\n            temp = -x;\n        \n        long rev = 0, unit = 0;\n        while(temp != 0)\n        {\n            unit = temp % 10;\n            rev=  rev * 10 + unit;\n            // if reversed number is greater than 32 bits ie INT_MAX \n            if( rev >= INT_MAX )\n                return 0;\n            temp/=10;\n        }\n        // if number is negative, then we add negative sign\n        if(x < 0)\n            return -rev;\n        else\n            return rev;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			36.8824,
			"class Solution {\npublic:\n    int reverse(int x) {\n        stringstream ss;\n        long long int ans;\n        ss << x;\n        string str;\n        ss >> str;\n        if(str[0]=='-') for(int i =1 ; i<=str.size()/2 ; i++)swap(str[i], str[str.size() -i]);\n        else for(int i =0 ; i<str.size()/2 ; i++)swap(str[i], str[str.size()-1 -i]);\n        ss.str(\"\");\n        ss.clear();\n        ss << str;\n        ss >> ans;\n        if((abs(ans) >> 31) != 0)return 0;\n        return ans;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			16.5,
			"class Solution {\npublic:\nint reverse(int x) {\n\tstring a = to_string(x);\n\tstring res = \"\";\n\tif(a.find(\"-\")!=string::npos){\n\t\tres += \"-\";\n\t}\n\tfor(int i=a.length()-1; i>=0; i--){\n\t\tres += a.substr(i, 1);\n\t}\n\tif(stoll(res) > 2147483647 || stoll(res) < -2147483648){\n\t\treturn 0;\n\t}\n\treturn stoi(res);\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			13.4545,
			"class Solution {\npublic:\n    int reverse(int x) {\n        string str;\n        stack<char> integers;\n        if (x < 0)\n            str += \"-\";\n        \n        string input = to_string(abs(x));\n        for (char const &c: input) \n            integers.push(c);\n        \n        while (!integers.empty()) {\n            str += integers.top();\n            integers.pop();\n        }\n        \n        if (abs(stol(str)) > INT_MAX)\n            return 0;\n        \n        return stoi(str);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			3,
			15.6,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int r{0};\n        \n        while (x / 10) {\n            r *= 10;\n            r += x % 10;\n            x /= 10;\n        }\n        \n        if (r / (INT_MAX / 10 + 1)) {\n            return 0;\n        }\n            \n        return r * 10 + x;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.6923,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int y=0;\n        \n        while(x){\n            if(INT_MAX/10 < y){\n                return 0;\n            }\n            if(INT_MIN/10 > y){\n                return 0;\n            }\n            \n            //As it was given in question that the input is 32 bit integer, if the input number is positive and while reversing it is greater than +2147483647(INT_MAX) then the output should be 0. But if the input number is negetive and while reversing it is less than -2147483648(INT_MIN) then also the output should be 0.\n            \n            y = y*10 + x%10;\n            x = x/10;\n        }\n        return y;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			33.6154,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int res = 0;\n        while(x) {\n            bool checkPosNotOverflow = x > 0 && res <= INT_MAX / 10 && res * 10 <= INT_MAX - x % 10;\n            bool checkNegNotOverflow = x < 0 && res >= INT_MIN / 10 && res * 10 >= INT_MIN - x % 10;\n            if (checkPosNotOverflow || checkNegNotOverflow) res = res * 10 + x % 10;\n            else return 0;\n            x /= 10;\n        }\n        return res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			7,
			15.4286,
			"class Solution {\npublic:\n    int reverse(int x) {\n        bool isNegative{}; // False by default\n        int newInt{};\n        \n        if (x < 0)\n        {\n            isNegative = true;\n            if (x == numeric_limits<int>::min()) return 0; // If it's the lowest number, return 0\n            x *= -1; // This will overflow if we are given the smallest potential number.\n\t\t\t// But by the time we reach here we've already returned 0. Otherwise this multiplication won't\n\t\t\t// give us any issues. We want to turn all negative numbers positive to not deal with negatives\n\t\t\t// in multiplication below.\n        }\n        \n\t\t// Reverse an integer\n        while (x)\n        {\n            // Check integer overflow\n            if (newInt > INT_MAX / 10 || newInt < INT_MIN / 10) return 0;\n            newInt = newInt * 10 + x % 10;\n            x /= 10;\n        }\n        // Restore negative if the number was originally negative\n        return isNegative ? -1 * newInt : newInt;\n    }\n};\n"
		],
		[
			3.0186650060438813,
			1.0,
			6,
			27.8182,
			"class Solution {\npublic:\n\tint reverse(int x) {\n\t\tint sum = 0;\n\t\tint y = x;\n\t\twhile(y!=0){\n\t\t\tif(x>0){\n\t\t\t\tif((INT_MAX-y%10)/10<sum){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}else if(x < 0){\n\t\t\t\tif((INT_MIN-y%10)/10>sum){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = sum*10+y%10;\n\t\t\ty /= 10;\n\t\t}\n\t\treturn sum;\n\t}\n};"
		],
		[
			1.0,
			1.0,
			6,
			14.9697,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if (!x)\n            return 0;\n        string rev = \"\";\n        bool negative = x < 0 ? true : false;\n        long y = x;\n        try\n        {\n            y = abs(y);\n            // Reverse the digits\n            while (y)\n            {\n                rev += to_string(y % 10);\n                y /= 10;\n            }\n            // Add a minus sign if the original number was negative\n            return negative ? stoi(rev.insert(0, 1, '-')) : stoi(rev);\n        }\n        // For cases of overflow\n        catch(...)\n        {\n            return 0;\n        }\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			19.4366,
			"/**\n    https://leetcode.com/problems/reverse-integer/\n    \n    TC: O(1), 32 bit numbers have a limited num of digits\n    SC: O(1)\n**/\nclass Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        // instead of checking separately for negative and \n        // positive number, we can combine the checks by making the num +ve.\n        // in case the the x is neg, then the max limit \n        // is INT_MAX + 1, but since we are limited to 32bits we can\n        // use the unsigned var to store just +1 of INT_MAX\n        unsigned int max_limit = x < 0 ? (unsigned int)INT_MAX + 1 : INT_MAX;\n        bool neg = x < 0;\n        // take absolute value for calc\n        x = abs(x);\n        \n        // simple reversal with overflow checks\n        while(x) {\n            // overflow due to multiplcation\n            if(rev > max_limit / 10)\n                return 0;\n            rev *= 10;\n            // overflow due to addition\n            if(rev > max_limit - x % 10)\n                return 0;\n            rev = rev + x % 10;\n            x /= 10;\n        }\n        return rev * (neg ? -1 : 1);\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			24.2105,
			"class Solution {\npublic:\nint reverse(int x) {\n        int res=0,flag=-1;\n        if(x==INT_MIN) \n            return 0;\n\t// flag for marking -ve numbers.\t\n        if(x<0){\n            flag=1;\n            x=abs(x);\n        }\n        while(x>0){\t\t\n\t\t//condition check for overflow.\t\t\n            if(res>INT_MAX/10) \n                return 0;\n            res=res*10+x%10;\n            x/=10;\n            \n        }\n        if(flag==1)\n            res=-1*res;\n        return res;\n    }\n};"
		],
		[
			1.0,
			1.0,
			3,
			18.6207,
			"// 1. Use C++ INT_MAX/INT_MIN (defined similar to boundaries of the problem)\n// 2. Multiply 'ret' by 10 to add another zero each iteration\n// 3. Strip the last digit from 'x' with the modulus operator\n// 4. Add the stripped off last digit to 'ret'\n// 5. If 'x' divided by 10 == 0, then we have removed all digits from 'x'.\nclass Solution {\npublic:\n    int reverse(int x) {\n        long long ret = 0;\n        while (x != 0) {\n\n            // Iteration    |    1      |    2      |    3\n            // ret = 0      | 0 + 3 = 3 |  30+2=32  | 320+1=321\n            //  x  = 123    | 123/10=12 |  12/10=1  | 1/10=0 ==>>> exit loop\n\n            ret = (ret*10) + (x%10);\n            x /= 10;\n\n            if (abs(ret) > INT_MAX) {\n                return 0;\n            }\n        }\n        return ret;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			8,
			28.3333,
			"class Solution {\npublic:\n    int reverse(int x) {\n      \n        int z = 0;\n      \n        while(x){\n        \n            if(z>INT_MAX/10 || z==INT_MAX/10 && x%10>7)\n                return 0;\n            if(z<INT_MIN/10 || z==INT_MIN/10&&x%10<-8)\n                return 0;\n         \n            z = z *10 +x%10;x = x/10;\n        }\n        \n        return z;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			20.5714,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int reverse = 0;\n        \n        while(x != 0){\n            // Check overflow\n            if(reverse > (INT_MAX/10 - (x%10)/10) || reverse < (INT_MIN/10-(x%10)/10)){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\t// Calculate reversed integer\n            reverse = reverse*10 + x%10;\n            x /= 10;\n        }\n        \n        return reverse;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			10,
			25.6442,
			"class Solution {\npublic:\n    int reverse(int x) {\n        //check if the first part overflows\n        if (x > INT_MAX || x < INT_MIN) return 0;\n        \n        int reverse = 0;\n        \n        while(x != 0) {     \n            //these conditions check if reverse will be larger than INT_MAX or smaller than INT_MIN by a factor of 10.\n            //the 7 and -8 are represent the last digit of INT_MAX and INT_MIN.\n            //Their condition explains that as long as the remainder is from 0 to 7, or -8 to 0 inclusive,\n            //the x value can be from 0 to INT_MAX, or INT_MIN to 0 range.\n            if ((reverse > INT_MAX/10 || reverse < INT_MIN/10) && ((x > 0 && (x % 10 <= 7)) || x < 0 && (x % 10 >= -8))) return 0;\n            \n            //change reverse value\n            reverse = reverse * 10 + x % 10;\n            \n            //to get next values, divide x by ten\n            x /= 10;\n        }\n        \n        return reverse;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			19.2,
			"class Solution {\npublic:\nint reverse(int x) {\n        long long int ans=0;\n        while(x!=0)\n        {\n            ans=(ans*10) +(x%10);\n            x/=10;\n            if(ans> INT_MAX)\n                return 0;\n            if(ans<INT_MIN)\n                return 0;\n        }\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			7,
			25.1471,
			"class Solution {\npublic:\n    int reverse(int x) {\n        string s = to_string(x);\n        int base = 1;\n        int i = s[0] == '-' ? 1 : 0;\n        int res = 0;\n        while(i < s.size()){\n            if(base == 1000000000 && (s[i] - '0' > 2 || INT_MAX - (s[i] - '0') * base < res)) return 0;\n            res += (s[i] - '0') * base;\n            base *= 10;\n            i++;\n        }\n        return s[0] == '-' ? -res : res;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			22.1,
			"class Solution {\npublic:\nint reverse(int x) {\n\tint result = 0;\n\twhile (x != 0){\n\t\tif (INT_MAX / 10 < result||INT_MIN/10>result){\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse{\n\t\t\tresult = result * 10 + x % 10;\n\t\t}\n\t\tx /= 10;\n\t}\n\treturn result;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			22.1,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long returnInt = 0;\n        while (x)\n        {\n            returnInt = returnInt*10+x%10;\n            x/=10;\n        }\n        if (returnInt>0)\n            return returnInt > INT_MAX ? 0 : returnInt;\n        else return returnInt < INT_MIN ? 0 : returnInt;\n    }\n};"
		],
		[
			1.0,
			1.0,
			3,
			19.5,
			"class Solution {      \npublic:        \n      int reverse(int x) {     \n        int res =0,tmp = res;   \n        for(;x;tmp = res,res = x%10 + res*10,x = x/10);     \n        return tmp!=res/10 ?0:res;    \n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			18.9615,
			"class Solution {\npublic:\nint reverse(int x) {\n    int ans = 0, copy = abs(x);\n\n    while (copy > 0) {\n        if (INT32_MAX / 10 < ans) return 0;  // check overflow\n        ans = ans * 10 + copy % 10;\n        copy /= 10;\n    }\n\n    return x < 0 ? -ans : ans;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			23.5238,
			"class Solution {\npublic:\nint reverse(int x) {\n        int p=x>0?x:-x;     \n             // p is the abs value\n        long int result=0;\n             // in case of overflow, we choose long int\n        while(p!=0){\n            result=result*10+p%10;\n            p/=10;\n        }\n             //reverse the abs value\n        result=(x>0)?result:-result;\n             //check if x>0\n        if(result>INT_MAX||result<INT_MIN)\n            return 0;\n             //check overflow\n        return result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			29.2917,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if (x == 0) return x;\n        int sign = 1;\n        long long int sum = 0;\n        if (x < 0) \n            x = -x, sign = -1;\n        \n        while (x > 0)\n        {\n            sum = sum * 10 + (x % 10);\n            x /= 10;\n            \n            if (sum * sign > INT_MAX || sum * sign < INT_MIN)\n                return 0;\n        }\n        \n        return (int)sum * sign;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			28.5,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if (x == 0) return x;\n        int sum = 0, low = 0, sign = 1;\n        if (x < 0) \n            x = -x, sign = -1;\n        \n        while (x > 0)\n        {\n            low = x % 10;\n            if ((INT_MAX - low) / 10 < sum)\n                return 0;\n            sum = sum * 10 + low;\n            x /= 10;\n\n        }\n        \n        return sign * sum;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			23.7857,
			"class Solution {\npublic:\nint reverse(int x) {\n        if (x == 0) {\n            return 0;\n        } else {\n            int res = 0;\n            int _x = abs(x);\n            int flag = _x / x;\n            while (_x > 0) {\n                int curr = _x % 10;\n                //in case overflow\n                if (res > (INT_MAX - curr) / 10) {\n                   return 0;\n                } else  {\n                    res  = res * 10 + curr;\n                    _x = _x / 10;\n                }\n            }\n            return flag * res;\n        }\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			25.5,
			"class Solution\n{\npublic:\n    int reverse(int x)\n    {\n        if(x == 0)\n            return 0;\n            \n        long result = 0;  \n        \n        while(x % 10 == 0)\n            x /= 10;\n        while(x)\n        {\n            result = result*10 + x % 10;\n            \n            if(result >= INT_MAX || result<= INT_MIN)\n                return 0;\n            x /= 10;\n        }\n        \n        return result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			16.0312,
			"class Solution {\n public:\n    int reverse(int x) {\n        long result = 0;           // Final result\n        long op = x < 0 ? -1 : 1;  // Get the operator\n\n        long tmp = abs((long)x);  // Avoid too many type conversions and work with positive number\n        while (tmp) {             // When tmp is zero, stops\n            result += tmp % 10;   // Get the last number\n            result *= 10;\n            tmp /= 10;\n        }\n        result /= 10;  // Remove the last zero\n\n        return result > (long)INT_MAX ? 0 : result * op;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			17.3333,
			"#include <climits>\n\nclass Solution{\npublic:\n    int reverse(int x){\n        long s = 0;         \n        while (x != 0) {\n            s =s*10 + x%10;\n            x = x/10;\n        }\n        if (s > INT_MAX || s < INT_MIN) return 0;\n        return s;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			19.8333,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int tag = x < 0 ? -1 : 1;\n        unsigned long temp = 0;\n\n        x *= tag;\n        for( ; x; x /= 10 )\n        {\n            temp = temp * 10 + x % 10;\n            if( temp > INT_MAX )\n                return 0;\n        }\n        return temp * tag;\n    }\n};"
		],
		[
			1.0,
			1.0,
			5,
			22.6935,
			"class Solution {\npublic:\nint reverse(int x) {\n    if(x==INT_MIN)//solve this situation, we can use x=abs(x)\n        return 0;\n\tint isPositive=1;\n\tif(x<0)\n\t{\n\t    x=abs(x);\n\t    isPositive=-1;\n\t}\n\tint result=0;\n\tint int_maxp=INT_MAX/10;\n\twhile(x!=0)\n\t{\n\t\tif (result>int_maxp)//don't need to check \"result==int_maxp&&q>int_maxq\"\uff0cbecause this can't happen (x is type int)\n\t\t{\n\t\t\tresult=0;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t\tresult=10*result+x%10;\n\t\tx=x/10;\n\t}\n\tresult=isPositive*result;\n\treturn result;\n};\n"
		],
		[
			1.0,
			1.0,
			10,
			31.0,
			"class Solution {\npublic:\nint reverse(int x) {\n    int minimum = INT_MIN, maximum = INT_MAX;\n    int res = 0, sign;\n    sign = (x<0)?-1:1;\n    if (x == minimum)\n        return 0;\n    x *= sign;  // here check x==minimum first\n    while (x) {\n        int tmp = sign*res;\n        if (tmp>maximum/10 || tmp<minimum/10 || (tmp==maximum/10 && x%10>maximum%10) || (tmp==minimum/10 && x%10<minimum%10))\n            return 0;\n        res = 10*res + x%10;\n        x /= 10;\n    }\n    return res*sign;\n}\n};"
		],
		[
			1.0,
			1.0,
			4,
			20.0,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int y=0;\n        while(x){\n            if(y>INT_MAX/10 || y<INT_MIN/10){\n                return 0;\n            }else{\n                y=y*10 +x%10;\n                x=x/10;\n            }\n        }\n        return y;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			4,
			17.25,
			"class Solution {\npublic:\nint reverse(int x) {\n    long result = 0;\n    while(x != 0)\n    {\n        result = result*10 + x % 10;\n        x /= 10;\n    }\n    return (result > INT_MAX || result < INT_MIN)? 0 : result;\n}\n};"
		],
		[
			1.0,
			1.0,
			6,
			33.125,
			"class Solution {\npublic:\nint reverse(int x) {\n\tint ch[40] = {};\n\tint i = 0;\n\tint flag = 1;\n\tif (x < 0)\n\t{\n\t\tflag = -1;\n\t\tx = abs(x);\n\t\t\n\t}\n\n\twhile (x>0)\n\t{\n\t\tch[i++] = x % 10;\n\t\tx=x / 10;\n\t}\n\tint length = i;\n\n\n\tint reverse = 0;\n\tfor (size_t i = 0; i < length; i++)\n\t{\n\t\tif (ch[i]!=0)\n\t\t{\n\t\t\treverse += ch[i]*pow(10, length - i-1);\n\t\t\tif (reverse < 0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn reverse*flag;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			25.375,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int a = r(x);\n        if(r(a) != x && x % 10 != 0) return 0;\n        else return a;\n    }\n    \n    int r(int x)\n    {\n        int r = 0;\n        while(x != 0)\n        {\n            r *= 10;\n            r += x % 10;\n            x /= 10;\n        }\n        return r;\n    }\n};\n"
		],
		[
			1.0,
			1.0,
			5,
			23.1818,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int x_cp = abs(x);\n        long result = 0;\n        while(x_cp) {\n            result = result*10+ x_cp%10;\n            x_cp /= 10;\n        }\n        if(result > 2147483647 || result < -2147483648) return 0;\n        return x >0 ? result : -result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.6667,
			"class Solution {\npublic:\n    int reverse(int x) {\n        long num = abs((long)x);\n        long new_num = 0;\n        while(num) {\n            new_num = new_num*10 + num%10;\n            num /= 10;\n        }\n        \n        if (new_num > INT_MAX) {\n            return 0;\n        }\n        return (x<0 ? -1*new_num : new_num);\n    }\n};"
		],
		[
			1.0,
			1.0,
			10,
			28.7692,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int result = 0;\n        while (x != 0)\n        {\n            int a = x % 10;\n            if (a > 0 && (result > INT_MAX/10 || (result == INT_MAX/10 && a > 7))) return 0;\n            if (a < 0 && (result < INT_MIN/10 || (result == INT_MIN/10 && a < -8))) return 0;\n\n            result = result*10 + a;\n            x /= 10;\n        }\n        return result;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.1667,
			"class Solution {\npublic:\n    int reverse(int x) {\n        \n         int t = abs(x);\n         int sum =0;\n         int restraint  = pow(2,31)-1;\n         int res;\n        \n         while(t>0){\n            \n            if(sum<=restraint/10){\n                sum = sum*10+t%10;\n                t = t/10;\n            }else{\n                return 0;\n            }\n            \n        }\n        res = x>=0?sum:-sum;   \n        return res; \n       \n         \n    }\n};\n"
		],
		[
			1.0,
			1.0,
			13,
			45.5,
			"class Solution {\npublic:\n    int reverse(int x) {\n        bool negativeFlag = false;\n        \n        if (x<0){\n            negativeFlag = true;\n            \n            if ((x <= INT_MAX) && (x > INT_MIN)) x = -x;\n            else return 0;\n        \n        }\n        \n        int rev_num = 0, prev_rev_num = 0;\n        \n        while (x != 0){\n            int curr_digit = x % 10;\n            \n            if (rev_num > INT_MAX/10 || (rev_num == INT_MAX / 10 && curr_digit > 7)) return 0;\n            if (rev_num < INT_MIN/10 || (rev_num == INT_MIN / 10 && curr_digit < -8)) return 0;\n            \n            rev_num = (rev_num * 10) + curr_digit;\n                                 \n            \n            if ((rev_num - curr_digit)/10 != prev_rev_num)\n                return 0;\n            \n            prev_rev_num = rev_num;\n            x = x / 10;\n        }\n        \n        return (negativeFlag == true) ? -rev_num : rev_num;\n\t\t}\n};\n"
		],
		[
			1.0,
			1.0,
			6,
			27.7083,
			"class Solution {\npublic:\n    int reverse(int x) {\n        if(x==0)return 0;\n        long long int n=x;\n        if(n<0)n=-n;\n        long long int ans=0;\n        while(n>0){\n            ans=ans*10+n%10;\n            n=n/10;\n            if(ans>pow(2,31)-1)return 0;\n        }\n        if(x<0)return -ans;\n        return ans;\n    }\n};"
		],
		[
			1.0,
			1.0,
			4,
			22.5455,
			"class Solution {\npublic:\n    int reverse(int x) {\n        int newX = 0;\n        \n        while (x != 0) {\n            if (newX > (INT_MAX-abs(x%10))/10 || newX < (INT_MIN+abs(x%10))/10) \n                return 0;\n            newX = newX*10 + x%10;\n            x /= 10;\n        }\n        \n        return newX;\n    }   \n};\n"
		]
	],
	"REVERSE_LL": [
		"n",
		[
			5.541980586942202,
			4.9012741893949,
			2,
			14.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n    ListNode* reverseList(ListNode* head) {\n        ListNode *prev = NULL, *node = head; \n        while (node) {\n            ListNode* temp = node->next; \n            node->next = prev; \n            prev = node; \n            node = temp; \n        }\n        return prev; \n    }\n};\n"
		],
		[
			5.582843706368771,
			4.9012741893949,
			2,
			12.8571,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        //create two pointers pre, next\n        ListNode* pre=NULL;\n        ListNode* next=NULL;\n        //Run the loop till we reach the end\n        while(head){\n            next=head->next;\n            head->next=pre;\n            pre=head;\n            head=next;\n        }\n        //return the last pointer\n        return pre;\n    }\n};\n"
		],
		[
			5.540513837178394,
			4.9012741893949,
			4,
			28.9474,
			"\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr)return head;\n        ListNode* first;\n        ListNode* p;\n        vector<ListNode*>tab;\n        p=head;\n        while(p->next!=nullptr){\n            tab.push_back(p);\n            p=p->next;\n        }    \n        first=p;\n        int n=tab.size();\n        for(int i=n-1;i>=0;i--){\n            p->next=tab[i];\n            p=tab[i];\n        }\n        p->next=nullptr;\n        return first;\n        \n    }\n};\n"
		],
		[
			5.556561047596531,
			4.9012741893949,
			2,
			27.5,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* d = NULL;\n        while(head != NULL){\n            ListNode* next = head->next;\n            head->next = d;\n            d = head;\n            head = next;\n        }\n        \n        return d;\n    }\n};\n"
		],
		[
			5.560538463602518,
			4.9012741893949,
			2,
			18.7,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *current=head;\n        ListNode *next=NULL,*prev=NULL;\n        while(current!=NULL)\n        {\n            next=current->next;\n            current->next=prev;\n            prev=current;\n            current=next;\n        }\n        head=prev;\n        return head;\n    }\n};\n"
		],
		[
			5.550041908932439,
			4.9012741893949,
			2,
			12.2143,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n\t/*initialize current, next, and previous pointers*/\n        ListNode* curr=head;\n        ListNode* next=NULL;\n        ListNode* prev=NULL;\n        while(curr!=NULL)\n        {\n\t\t/*store next*/\n            next=curr->next;\n\t\t\t\n\t\t\t/*reverse current node's pointer*/\n            curr->next=prev;\n\t\t\t\n\t\t\t/*move pointers one position ahead*/\n            prev=curr;\n            curr=next;\n        }\n        head=prev;\n\t\t/*return the reversed linked list*/\n        return head;\n    }\n};\n"
		],
		[
			5.534769914001696,
			4.9012741893949,
			2,
			18.15,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *current, *previous, *next;\n        current = head;\n        previous = NULL;\n        \n        while(current){\n            next = current->next;\n            current->next = previous;\n            previous = current;\n            current = next;\n        }\n        \n        head = previous;\n        return head;\n    }\n};\n"
		],
		[
			5.541486217089054,
			4.9012741893949,
			2,
			28.2353,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode * current = head;\n        ListNode * previous = nullptr;\n        ListNode * next = nullptr;\n        \n        while(current!=NULL){\n            next=current->next;\n            current->next=previous;\n            previous=current;\n            current=next;\n        }\n        return previous;\n    }\n};\n"
		],
		[
			5.659083058711524,
			4.9012741893949,
			2,
			12.65,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head)\n{\n\t ListNode* prev{nullptr};\n\t for( ; head; head = exchange(head->next, exchange(prev, head)));\t \n\t return prev;\n}\n};"
		],
		[
			5.555012376923241,
			4.901274189394899,
			2,
			14.0,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\nListNode* reverseList(ListNode* head) {\n        ListNode *prevNode = NULL;\n        \n        while(head != NULL){\n            ListNode *tempNode  = head->next;\n            head->next = prevNode;\n            prevNode = head;\n            head = tempNode;\n        }\n    return prevNode;\n    }\n};"
		],
		[
			5.544674861982233,
			4.9012741893949,
			4,
			15.5833,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n\n    ListNode* helper(ListNode* prevN,ListNode* nextN){\n        ListNode* cur = nextN->next;\n        nextN->next = prevN;\n        if(cur) return helper (nextN, cur);\n        return nextN;\n    }\n    ListNode* reverseList(ListNode* head) {\n        if(head) return helper(NULL, head);\n        return head;\n    }\n};"
		],
		[
			5.561585653412237,
			4.9012741893949,
			2,
			21.2632,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n      ListNode* q = NULL, *r = NULL; // we requre three pointer p,q,r\n\tListNode* p = head; \n\twhile (p != NULL)\n\t{/*\n\t sliding pointer */\n\t\tr = q; // r  sud come upon q\n\t\tq = p;// q sud come upon p\n\t\tp = p->next;// p sud move to next node \n\t\tq->next = r;// q next sud points on \n\t}\n\treturn q; // once we came out of while loop // 1st pointer sud point on q \n        \n    }\n};\n"
		],
		[
			5.541008134155046,
			4.9012741893949,
			4,
			36.0,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head)\n    {\n        if(head==NULL || head->next==NULL)\n        {\n            return head;\n        }\n        ListNode* headprev=head;\n        head=head->next;\n        headprev->next=NULL;\n        ListNode* headnew;\n        while(head!=NULL)\n        {\n            headnew=head;\n            head=head->next;\n            headnew->next=headprev;\n            headprev=headnew;\n        }\n        return headnew;\n    }\n};\n"
		],
		[
			5.58207855890668,
			4.9012741893949,
			2,
			16.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* main = head;\n        ListNode* prev = NULL;\n        ListNode* next = NULL;\n        while(main!= NULL)\n        {\n            next = main->next;\n            main->next = prev;\n            prev = main;\n            main = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.520428844322775,
			4.9012741893949,
			3,
			17.6,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n  ListNode* helper(ListNode* head, ListNode* prev) {\n        if (!head) return prev;\n        ListNode* next = head->next;\n        head->next = prev;\n        return helper(next, head);\n      \n        \n    }\n    \n    ListNode* reverseList(ListNode* head) {       \n        return helper (head, NULL);\n        \n    }\n};"
		],
		[
			5.531796019079737,
			4.901274189394899,
			3,
			16.5926,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* dfs(ListNode* head, ListNode* prev) {\n\t\tif (head == nullptr)\n\t\t\treturn prev; // search for the last node of the list\n\t\t\t\n        ListNode* root = dfs(head->next, head);  // get last node of the list\n        head->next = prev; // change current node next pointer to prev node\n        \n        return root; // return last node of the original list (will be first now)\n    }\n    \n    ListNode* reverseList(ListNode* head) {\n       return dfs(head, nullptr);\n    }\n};\n"
		],
		[
			5.557842547079225,
			4.9012741893949,
			3,
			18.15,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(!head)\n        {\n            return head;\n        }\n        ListNode* curr = head;\n        ListNode* prev = NULL;\n        ListNode* next;\n        \n        while(curr)\n        {\n            next = curr -> next;\n            curr -> next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.515382731794856,
			4.9012741893949,
			2,
			17.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n\t//consider prev,curr,next as three boxes beneath 1 2 3 4 5 linked list\n\t//To reverse the address , first copy what current node is pointing and then assign to its prev node\n\t//curr stores address of box in list whose link must be reversed.\n\t//next stores the next node address pointed to by node whose address in curr\n\t//prev stores the add of last before node visited\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n        ListNode* next = NULL;\n        while(curr!=NULL){\n            next = curr->next;//copying node add pointed by add in curr\n            curr->next = prev;//copying curr node next to prev node\n            prev = curr;// the next prev node will be curr node\n            curr = next;//next curr node is next node\n        }\n        return prev;//prev stores last address of last box in the process\n    }\n};\n"
		],
		[
			5.524789735721206,
			4.9012741893949,
			3,
			19.6364,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr)\n            return head;\n        ListNode *curr=head;\n        ListNode *prev=nullptr;\n        ListNode *nxt=nullptr;\n         while(curr!=nullptr)\n        {\n            nxt=curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=nxt;\n        }\n        return prev;\n   }\n};\n"
		],
		[
			5.534359037487449,
			4.9012741893949,
			3,
			18.3333,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n     ListNode* reverseList(ListNode* head) {\n         if(head == nullptr || head->next == nullptr)\n             return head;\n         ListNode* last = reverseList(head->next);\n         head->next->next = head;\n         head->next = nullptr;\n         return last;\n     }\n};\n\n"
		],
		[
			5.518947508966637,
			4.9012741893949,
			3,
			15.7368,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n    ListNode* reverseList(ListNode* head) {\n        queue <ListNode*> list_stack;\n        auto pointer = head;\n        ListNode* res = nullptr;\n        while (pointer)\n        {\n            list_stack.push(pointer);\n            pointer = pointer -> next;\n        }\n        \n        while (!list_stack.empty())\n        {\n            auto current = res;\n            res = list_stack.front();\n            res -> next = current;\n            list_stack.pop();\n        }\n        \n\n        \n        return res;\n    }\n};"
		],
		[
			5.526938731055732,
			4.9012741893949,
			2,
			14.5455,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\nListNode* reverseList(ListNode* head) {\nListNode* nt;\nListNode* prev = NULL;\n\n    ListNode* curr = head;\n    \n    while(curr!=NULL){\n        nt = curr->next;\n        curr->next = prev;\n        \n        prev = curr;\n        curr = nt;\n        \n    }\n    \n    return prev;\n}\n};"
		],
		[
			5.578171115029668,
			4.9012741893949,
			3,
			19.8,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr) \n        {\n            return head;\n        }\n        \n        ListNode* p1 = head;\n        ListNode* p2 = nullptr;\n        \n        while(p1!=nullptr)\n        {\n            p1 = p1->next;\n            head->next = p2;\n            p2 = head;\n            head = p1;\n        }\n        \n        return p2;\n    }\n};\n"
		],
		[
			5.56166267871467,
			4.9012741893949,
			3,
			16.7619,
			"// Recursive Using Extra Memory(Queue)\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        queue<int> tmp;\n        helper(head, tmp);\n        return head;\n    }\n    \n    void helper(ListNode* cur, queue<int> &tmp) {\n        if (cur == NULL) {\n            return;\n        }\n        tmp.push(cur->val);\n        helper(cur->next, tmp);\n        cur->val = tmp.front();\n        tmp.pop();\n    }\n};"
		],
		[
			5.5428201368969505,
			4.9012741893949,
			2,
			15.0,
			"// Iterative In-Place \nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* newHead = NULL;\n        while (head) {\n            ListNode *next = head->next;\n            head->next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n};"
		],
		[
			5.545523057688134,
			4.9012741893949,
			2,
			18.5455,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        \n\t\t// BASE CASE\n        // if the linked list is empty or has only one node, we are done!\n        if (head == nullptr or head -> next == nullptr) {\n            return head;\n        }\n        \n\t\t// INDUCTION\n        // 1 -> 2 -> 3 -> nullptr\n        // use Recursive leap of faith to reverse the rest of the list\n        ListNode * reverse = reverseList(head -> next);\n        \n        // we got:\n        \n        //    nullptr\n        //      ^\n        //      |\n        // 1 -> 2 <- 3\n        // reverse pointer is actually pointing to 3\n        \n\t\t// HYPOTHESIS\n        // Now that we have our reversed list EXCLUDING the first node\n        // we want 2's next to point to 1\n        // therefore, we can set the next of (next of 1 (which is 2)) to 1, itself\n        ListNode * secondLast = head -> next;\n        secondLast -> next = head;  // as head is the last node in the reversed list(as it was first in our original list) and put nullptr in its next as the next step\n        head -> next = nullptr;\n        return reverse;\n    }\n};\n"
		],
		[
			5.568329712091426,
			4.901274189394899,
			3,
			17.7333,
			"// Recursive In-Place \nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        return helper(head, NULL);\n    }\n    \n    ListNode* helper(ListNode* cur, ListNode* newHead) {\n        if (cur == NULL) {\n            return newHead;\n        }\n        ListNode* next = cur->next; // Save next\n        cur->next = newHead;\n        return helper(next, cur);\n    }\n};"
		],
		[
			5.554765085892848,
			4.9012741893949,
			2,
			11.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        \n        ListNode* prev = NULL;\n        ListNode* current = head;\n        ListNode* next = NULL;\n        \n        while (current) {\n            \n            // Reverse node \n            next = current->next;\n            current->next = prev;\n            \n            // For next iteration\n            prev = current;\n            current = next;\n        }\n        \n        // Outside of while loop current is NULL that's why we are out of while but prev has the last node \n        // which is now the first node\n        return prev;\n        \n    }\n};\n"
		],
		[
			5.537638299419775,
			4.9012741893949,
			3,
			18.3333,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n          if(head==NULL || head->next==NULL)\n              return head;\n         ListNode* p= reverseList(head->next);\n         head->next->next=head;\n         head->next=NULL;\n         return p;   \n    }\n};"
		],
		[
			5.555044080835704,
			4.9012741893949,
			2,
			14.85,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *nextNode, *prevNode = NULL;\n        while (head) {\n            nextNode = head->next;\n            head->next = prevNode;\n            prevNode = head;\n            head = nextNode;\n        }\n        return prevNode;\n    }\n};"
		],
		[
			5.518176491704252,
			4.9012741893949,
			2,
			19.3208,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode * current = head;\n        ListNode * previous = nullptr;\n        ListNode * next = nullptr;\n        \n        // 1 -> 2 -> 3 -> nullptr\n        while (current != nullptr) {\n            // store the next of current and change its value so that it points to previous\n            next = current -> next;\n            // previous(nullptr) <- 1  2 -> 3 -> nullptr\n            current -> next = previous;\n            \n            // Settings for the next iteration\n            \n            // the current will be the previous of next of current\n            previous = current;\n            // move current to its next stored in the first step\n            current = next;\n        }\n        // we are doing this iteration for all the elements in the loop\n        \n        // In the end, our current will point to nullptr(past the list)\n        // and our previous will point to the last node, which for us\n        // is the first node of the reversed list\n        \n        // nullptr <- 1 <- 2 <- 3 \n        \n        return previous;\n    }\n};\n"
		],
		[
			5.568024437523534,
			4.9012741893949,
			2,
			14.5455,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev=NULL;\n        ListNode* curr=head;\n        ListNode* nxt;\n        \n        while(curr!=NULL)\n        {\n            nxt=curr->next;\n            curr->next=prev;\n            prev=curr;\n            curr=nxt;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.541773055529368,
			4.9012741893949,
			4,
			30.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if (head == NULL || head->next == NULL){\n            return head;\n        }\n        ListNode *start = head;\n        ListNode *end = start->next;\n        start ->next = NULL;\n        start = end;\n        end = end ->next;\n\t\t\n        while (end != NULL){\n            start->next = head;\n            head = start;\n            start = end;\n            end = end->next;\n        }\n        start->next = head;\n        head = start;\n        return head;\n    }\n};\n"
		],
		[
			5.552213325238729,
			4.9012741893949,
			4,
			23.25,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL || head->next==NULL) return head;\n        //Take two nodes one to point and other to traverse with\n\t\tListNode* prev = NULL;\n        ListNode* curr = head;\n        while(curr->next!=NULL){\n\t\t    //Make a temp node to store the current node\n            ListNode* temp = curr;\n\t\t\t//Move current to the next node\n            curr = curr->next;\n\t\t\t//Reverse the arrow of temp (which was curr) to previous node\n            temp->next = prev;\n\t\t\t// Move prev one step forward\n            prev = temp;\n        }\n\t\t//At last reverse the arrow of last node to prev\n        curr->next = prev;\n\t\t//Return current as head\n        return curr;\n    }\n};\n"
		],
		[
			5.578144333518622,
			4.9012741893949,
			4,
			21.8182,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head ==nullptr || head->next == nullptr)\n            return head;\n        \n        ListNode* rest = head->next;\n        ListNode* reversed = head;\n        reversed->next = nullptr;\n       \n        \n        while(rest)\n        {\n            ListNode* tmp = rest;\n            rest = rest->next;\n            tmp->next = reversed;\n            reversed = tmp;\n        }\n    \n        return reversed;\n    }\n};\n"
		],
		[
			5.590933565217982,
			4.9012741893949,
			2,
			27.7647,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur = head, *prev = NULL, *next;\n        while(cur!=NULL) {\n            next = cur->next;\n            cur->next = prev;\n            prev = cur;\n            cur = next;\n        }\n        head = prev;\n        return head;\n    }\n};\n"
		],
		[
			5.5353254989828296,
			4.9012741893949,
			3,
			29.75,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* util(ListNode* prev, ListNode* cur, ListNode* next) {\n        if(cur==NULL)\n            return prev;\n        next = cur->next;\n        cur->next = prev;\n        prev = cur;\n        cur = next;\n        return util(prev,cur,next);\n    }\n    ListNode* reverseList(ListNode* head) {\n        auto o = util(NULL,head,NULL);\n        return o;\n    }\n};\n"
		],
		[
			5.511988283710715,
			4.9012741893949,
			2,
			13.1818,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head)\n{\n\tif(!head or !head->next) return head;\n\tauto root = reverseList(head->next);\n\thead->next->next = head;\n\thead->next = nullptr;\n\treturn root;\n}\n};"
		],
		[
			5.540039417761261,
			4.9012741893949,
			2,
			15.0,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head) {\n\tListNode* prev = nullptr;\n\tListNode* cur = head;\n\twhile (cur) {\n\t\tListNode* next = cur->next;\n\t\tcur->next = prev;\n\t\tprev = cur;\n\t\tcur = next;\n\t}\n\treturn prev;\n}\n};"
		],
		[
			5.534808545377994,
			4.9012741893949,
			2,
			16.2,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head,ListNode* pre = NULL) {\n        if(head == nullptr){\n            return pre;\n        }\n        ListNode* next = head->next;\n        head->next = pre;\n        return reverseList(next,head);\n    }\n};\n"
		],
		[
			5.543016575759078,
			4.9012741893949,
			2,
			15.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        while(head){\n            ListNode* next = head->next;\n            head->next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.6238644324224465,
			4.9012741893949,
			2,
			15.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* current = head;\n        while(current){\n            ListNode* next = current->next;\n            current->next = prev;\n            prev = current;\n            current = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.550766764890758,
			4.9012741893949,
			3,
			18.3333,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        ListNode* prev = reverseList(head->next);\n        head->next->next = head;\n        head->next = nullptr;\n        return prev;\n    }\n};\n"
		],
		[
			5.576888695888699,
			4.9012741893949,
			3,
			33.0,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL)\n            return head;\n        ListNode* p=NULL;\n        ListNode* q=head;\n        ListNode* r=q->next;\n        while(q!=NULL){\n            r=q->next;\n            q->next=p;\n            p=q;\n            q=r;\n        }\n        head=p;\n        return head;\n    }\n};\n"
		],
		[
			5.549121664854881,
			4.9012741893949,
			2,
			19.3721,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n            \nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur=head,*prev=NULL,*q; //\n        \n        while(cur!=NULL){\n            q=cur->next; // storing next pointer to modifiy it leater\n            cur->next=prev;  // Reversing the pointer to the prev\n            prev=cur;  // make the prev equal to the last node we added\n            cur=q; // we get the value back from q that we stored at the first of the loop\n        }\n        return prev; /// return the ans\n    }\n    \n};\n      \n"
		],
		[
			5.5312571511596325,
			4.9012741893949,
			2,
			15.5,
			"class Solution {\npublic:\n\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\nListNode* reverseList(ListNode* head) {\n        ListNode *prev = NULL;\n\t\tListNode *cur = head;\n\t\twhile (cur != NULL){\n\t\t\tListNode *next = cur->next;\n\t\t\tcur->next = prev;\n\t\t\tprev = cur;\n\t\t\tcur = next;\n\t\t}\n\t\treturn prev;\n    }\n};"
		],
		[
			5.515608175732883,
			4.9012741893949,
			3,
			18.0,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        if(head == NULL)\n            return head;\n        ListNode* prevNode = NULL;\n        ListNode* currNode = head;\n        while(currNode) {\n            ListNode* nextNode = currNode->next;\n            currNode->next = prevNode;\n            prevNode = currNode;\n            currNode = nextNode;\n        }\n        return prevNode;\n    }\n};\n"
		],
		[
			5.590119991003216,
			4.9012741893949,
			2,
			24.0,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = NULL, *curr = head, *next = head;\n        while(curr!=NULL)\n        {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.519043906134297,
			4.9012741893949,
			2,
			24.8889,
			"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur=head,*prev=NULL,*temp;\n        while(cur){\n            temp=cur->next;\n            cur->next=prev;\n            prev=cur;\n            cur=temp;\n        }\n        return prev;\n    }\n};\n"
		],
		[
			5.669538521176404,
			4.9012741893949,
			2,
			14.4,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode *cur=head,*prev=NULL,*q;\n        \n        while(cur!=NULL){\n            q=cur->next; // storing next pointer\n            cur->next=prev;  // Reversing the pointer\n            prev=cur; \n            cur=q;\n        }\n        return prev;\n    }\n    \n};\n"
		],
		[
			1.0,
			1.0,
			4,
			18.2879,
			"class Solution {\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseL(ListNode* cur,ListNode** newhead) {    // using ** so that change remain permanent(similar to call by reference)\n        if(cur->next==NULL){       // base case and also for \"[1]\" case\n             *(newhead)=cur;       // new head\n            return cur;\n        }\n        else{\n        ListNode* n = reverseL(cur->next,newhead);\n        n->next=cur;\n        return cur;\n        }\n    }\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head==NULL)          // for [] case\n            return head;\n        ListNode* temp =head;\n        ListNode* t = reverseL(head,&temp);\n        t->next=NULL;       // head = tail\n        return temp;            // returning the new head\n    }\n};\n"
		],
		[
			5.547052847979819,
			4.901274189394899,
			2,
			13.5,
			"class Solution {\npublic:\n    class ListNode{\n        public:\n        ListNode* next;\n        int val;\n    };\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* newHead = nullptr;\n        while (head) {\n            auto next = head->next;\n            head->next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n};\n"
		]
	],
	"ANAGRAM": [
		"m",
		[
			4.359157263178671,
			4.266792246588796,
			6,
			22.5,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) \n    {\n        if(s.length()!=t.length())\n        {\n            return false;\n        }\n        unordered_map<char, int>mp1,mp2;\n        unordered_map<char, int>::iterator itr1,itr2;\n        for(int i=0;i<s.length();i++)\n        {\n            mp1[s[i]]++;mp2[t[i]]++;\n        }\n        for(itr1=mp1.begin(),itr2=mp2.begin();itr1!=mp1.end();itr1++,itr2++)\n        {\n            itr2=mp2.find(itr1->first);\n            if(itr2!=mp2.end())\n            {\n                if(itr2->second!=itr1->second)\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			6.979264323766231,
			4.266811783871503,
			1,
			9.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        return s == t;\n    }\n};"
		],
		[
			4.554233019670972,
			4.266794949578171,
			6,
			18.5,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s==t) return true;\n        if (s.size()!=t.size()) return false;\n        unordered_map <char, int> umap;\n        for (int i=0; i<s.size(); i++) {\n            umap[s[i]]++;\n            umap[t[i]]--;\n        }\n        for (auto it: umap) {\n            if (it.second) return false;\n        }\n        return true;\n    }\n};"
		],
		[
			4.142497146426994,
			3.328036606549934,
			1,
			5.54167,
			"class Solution {\npublic:\nstatic bool isAnagram( const string& s, const string& t ) \n    {\n        return is_permutation( begin( s ), end( s ), begin( t ), end( t ) );\n    }\n};"
		],
		[
			9.614647260721352,
			11.4380692959006,
			3,
			20.7059,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        array<int, 'z' - 'a' + 1> occ_s{ 0 };\n        array<int, 'z' - 'a' + 1> occ_t{ 0 };\n        for (auto& c : s) occ_s[c - 'a']++;\n        for (auto& c : t) occ_t[c - 'a']++;\n        \n        return equal(occ_s.begin(), occ_s.end(), occ_t.begin());\n    }\n};\n"
		],
		[
			18.227194264376834,
			4.2680963737104705,
			3,
			13.4167,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char, int> S, T;\n        for (char c : s) {\n            S[c]++;\n        }\n        for (char c : t) {\n            T[c]++;\n        }\n        return S == T;\n    }\n};\n"
		],
		[
			20.475183803134442,
			12.361791929367348,
			1,
			9.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) \n    {\n        sort(s.begin(),s.end()),sort(t.begin(),t.end());\n        return (s == t);\n    }\n};\n"
		],
		[
			7.747259017418326,
			5.785287621625488,
			1,
			10.0833,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        multiset<char> msc1(s.begin(), s.end());\n        multiset<char> msc2(t.begin(), t.end());\n        return msc1==msc2;\n}\n};"
		],
		[
			4.501906077709556,
			11.870590087942235,
			6,
			24.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())return false;\n        int count[256] = {0};\n        for(int i=0;i<s.size();++i)count[s[i]]++;\n        for(int i=0;i<t.size();++i)count[t[i]]--;\n        for(int i=0;i<256;++i)\n            if(count[i]!=0)return false;\n        return true;\n    }\n};\n"
		],
		[
			6.199366779175263,
			4.267961306130443,
			3,
			14.9333,
			"class Solution\n{\npublic:\n\nbool isAnagram(std::string s, std::string t) \n{\n    std::unordered_map<char, int> ma;\n    std::unordered_map<char, int> mb;\n    \n    for(const auto &el: s)\n    {\n        ma[el]++;\n    }\n    \n    for(const auto &el: t)\n    {\n        mb[el]++;\n    }\n    \n    return ma == mb; \n}\n};"
		],
		[
			4.4593872287839895,
			11.870588251275025,
			1,
			7.31818,
			"class Solution {\npublic:\n    bool isAnagram(std::string s, std::string t) {\n        return std::is_permutation(std::cbegin(s), std::cend(s), std::cbegin(t), std::cend(t));\n    }\n};\n"
		],
		[
			4.365625582095888,
			4.266796746606677,
			9,
			33.1818,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n\n\t\tif(s.length()!=t.length())return false;\n\t\t\n        unordered_map<char, int> hash_table;\n        for(int i=0;i<s.length();i++){\n             if (hash_table.find(s[i]) == hash_table.end()){\n                 hash_table[s[i]]=1;\n             }else{\n                 hash_table[s[i]]++;\n             }\n        }\n        for(int i=0;i<t.length();i++){\n             if (hash_table.find(t[i]) == hash_table.end()){\n                 return false;\n             }else{\n                 if(hash_table[t[i]]<=0)return false;\n                 hash_table[t[i]]--;\n             }\n        }\n        for (auto x : hash_table){\n            if (x.second > 0)return false;\n        }\n        return true; \n    }\n};"
		],
		[
			12.772876922026738,
			4.266808646128985,
			9,
			31.7333,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.size() == 0 && t.size() == 0) return true;\n        if(s.size() == 0 || t.size() == 0) return false;\n        if(s.size() != t.size()) return false;\n        int sa[26] = {0};\n        int ta[26] = {0};\n        for(int i=0;i < s.size();i++){\n            sa[s[i] - 'a']++;\n            ta[t[i] - 'a']++;\n        }\n        for(int i=0;i<26;i++)\n            if(sa[i] != ta[i]) return false;\n    return true;\n    }\n};\n"
		],
		[
			4.3608484651899495,
			4.266789162041007,
			5,
			17.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size()!=t.size()) return false;\n        \n\t\tunordered_map <char, int> umap;\n        for (char c:s) umap[c]++;\n        for(char c:t) {\n            umap[c]--;\n            if (umap[c]<0) return false;\n        }\n        \n        return true;\n                    \n    }\n};"
		],
		[
			7.037371669499475,
			12.361794159925735,
			1,
			9.9,
			"class Solution {\npublic:\n    bool isAnagram(std::string s, std::string t) {\n        std::sort(s.begin(), s.end());\n        std::sort(t.begin(), t.end());\n        return s == t;\n    }\n};\n"
		],
		[
			21.702491547511233,
			4.266809827833883,
			1,
			9.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n       \n       sort(s.begin(),s.end());\n       sort(t.begin(),t.end());\n        \n        return(s==t);\n    }\n};\n"
		],
		[
			4.447991773538232,
			4.266802969096171,
			8,
			24.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        \n         if (s.length() != t.length()) {\n        return false;\n    }\n        if(s.size() == 0 and t.size()==0) return true;\n        \n        unordered_map<char,int> map;\n        int matched = 0;\n        for(auto x : t)\n        {\n            map[x]++;\n        }\n        \n        for(int end =0 ; end<s.size(); end++){\n            char right = s[end];\n            if(map.find(right)!=map.end()){\n                map[right]--;\n                if(map[right] == 0){\n                    matched++;\n                }\n                if(matched == map.size())\n                    return true;\n                \n                \n            }\n            \n        }\n        return false;\n    }\n};\n"
		],
		[
			7.024578682456252,
			4.266810988774243,
			1,
			9.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n         sort(s.begin(),s.end());\n        sort(t.begin(),t.end()); return s==t;\n    }\n};"
		],
		[
			14.33522358364424,
			11.870580643825202,
			3,
			13.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n     std::vector<char> map(128,0);\n    std::vector<char> _map(128,0);\n    \n    for(auto x : s)\n    {\n        map[x]++;\n    }\n    \n    for(auto z : t)\n    {\n        _map[z]++;\n    }\n    \n    return map == _map;  \n    }\n};"
		],
		[
			8.8626204730492,
			4.266787631248729,
			6,
			28.2857,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n\n    if(s.size()!=t.size()) return false;\n    int arr[26]={0};\n    \n    for(int i=0;i<s.size();i++)\n    {\n        arr[s[i]-'a']++;\n    }\n    \n    for(int i=0;i<t.size();i++)\n    {\n        arr[t[i]-'a']--;\n    }\n    \n    for(int i=0;i<26;i++)\n    {\n        if(arr[i]>0)\n            return false;\n    }\n    return true;\n}\n};"
		],
		[
			6.983500992831561,
			4.266808493678565,
			2,
			10.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s == t){\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n};"
		],
		[
			6.741230151618266,
			4.267455102610033,
			3,
			14.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        map<char, int> mps;\n        map<char, int> mpt;\n        for(auto i : s){\n            mps[i]++;\n        }\n        for(auto i : t){\n            mpt[i]++;\n        }\n        return mps == mpt;\n    }\n};"
		],
		[
			6.938468458431901,
			4.266808583209235,
			2,
			10.0,
			"class Solution\n{\npublic:\n    bool isAnagram(string s, string t)\n    {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if (s == t)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n};"
		],
		[
			4.450341260028348,
			4.266809919327808,
			4,
			15.6774,
			" class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        if (s.length() != t.length())\n            return false;\n        \n\t\t// Sort strings\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        \n\t\t/* \n\t\t\tIf the two strings don't match at every index \n\t\t\tthen the strings are not anagrams of each other\n\t\t*/\n        for (int i=0; i < s.length(); i++)\n        {\n            if (s[i] != t[i])\n                return false;\n        }\n        \n        return true;\n    }\n };"
		],
		[
			4.3805164468200015,
			4.266806732484615,
			5,
			15.7959,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        if (s.length() != t.length())\n            return false;\n\t\t\t\n        // Arrays used to keep track of character frequency using ASCII values\n        char string1[128]{0};\n        char string2[128]{0};\n        \n\t\t// Count number of times a character appears\n        for (int i=0; i < s.length(); i++)\n        {\n            string1[s[i]]++;\n            string2[t[i]]++;\n        }\n        \n\t\t/* \n\t\t\tIf the two arrays don't match at every indice then\n\t\t\tthe two strings are not anagrams of each other \n\t\t*/\n\t\tint len = sizeof(string1)/sizeof(string1[0]);\n        for (int i=0; i < len; i++)\n        {\n            if (string1[i] != string2[i])\n                return false;\n        }\n        \n        return true;\n    }\n};"
		],
		[
			4.5950238698904755,
			4.2667935043561664,
			10,
			37.2692,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n\n    if(t.size()!=s.size())\n    {\n        return false;\n    }\n    if(s==t)\n    {\n        return true;\n    }\n    map<char,int>m1;\n    map<char,int>m2;\n    map<char,int>::iterator it1;\n    map<char,int>::iterator it2;\n    for(char c:s)\n    {\n\n        it1=m1.find(c);\n    if(it1==m1.end())\n    {\n        m1.insert(pair<int,int>(c,1));\n    \n    }\n        else\n        {\n            it1->second=it1->second+1;\n            \n        }\n    \n    }\n    \n    \n    for(char c:t)\n    {\n\n        it2=m2.find(c);\n    if(it2==m2.end())\n    {\n        m2.insert(pair<int,int>(c,1));\n    \n    }\n        else\n        {\n            it2->second=it2->second+1;\n            \n        }\n    \n    }\n    \n    for(it1=m1.begin();it1!=m1.end();it1++)\n    {\n        it2=m2.find(it1->first);\n        if(it2==m2.end())\n        {\n            m1.clear();\n            m2.clear();\n            return false;\n        }\n        else\n        {\n            if(it2->second!=it1->second)\n            {\n                m1.clear();\n                m2.clear();\n                return false;\n            }\n        }\n        \n        \n    }\n    m1.clear();\n    m2.clear();\n    return true;\n    \n    \n    \n}\n};"
		],
		[
			4.583137955415487,
			4.2668101824800795,
			6,
			25.0714,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s==t) return true;\n        if (s.size()!=t.size()) return false;\n        int umap[26]={};\n        for (int i=0; i<s.size(); i++) {\n            umap[s[i]-'a']++;\n            umap[t[i]-'a']--;\n        }\n        for (int i=0; i<26; i++) {\n            if (umap[i]) return false;\n        }\n        return true;\n    }\n};"
		],
		[
			12.544396207485468,
			4.266808689622044,
			4,
			24.12,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n\t\t// quick exit condition\n        if (s.size() != t.size()) return false;\n\t\t// working with frequencies now\n        int alpha[26] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n        for (char c: s) alpha[c - 'a']++;\n        for (char c: t) alpha[c - 'a']--;\n        return all_of(begin(alpha), end(alpha), [](int a){return a == 0;});\n    }\n};\n"
		],
		[
			6.786635141599813,
			4.267472258369438,
			4,
			16.3462,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        map<char,int> hash;\n        for(char i:s) hash[i]++;\n        for(char i:t) \n            if(--hash[i] == 0) hash.erase(i);\n        return hash.empty();\n    }\n};\n"
		],
		[
			13.571763326102626,
			4.266770082649957,
			5,
			19.5,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        if(s.size()!=t.size()) return false;\n        map<char,int>map;\n        \n        for(int i=0;i<s.size();i++){\n            map[s[i]]++;\n            map[t[i]]--;\n        }\n        for(auto it=map.begin();it!=map.end();it++)\n            if(it->second!=0)return false;\n        return true;\n    }\n};"
		],
		[
			12.526204522335876,
			4.266806864767448,
			5,
			23.75,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) {\n            return false;\n        }\n        string alph = \"abcdefghijklmnopqrstuvwxyz\";\n        int sum = 0;\n        for (int i = 0; i < s.size(); ++i) {\n            if (s.find(t[i]) == string::npos) {\n                return false;\n            }\n            sum += alph.find(s[i]) - alph.find(t[i]);\n        }\n        if (sum != 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n};\n"
		],
		[
			12.125682361725206,
			11.870578687221112,
			3,
			23.5385,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n        unordered_map<char, int> s_map, t_map;\n        for (int i=0; i<s.size(); i++)\n        {\n            s_map[s[i]]++;\n            t_map[t[i]]++;\n        }\n        return s_map == t_map;\n    }\n};\n"
		],
		[
			4.521833874003185,
			4.266808671878799,
			6,
			19.5938,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char, int>mp;\n        if(s.size() != t.size()) return false;\n        for(auto ch : s) {\n            mp[ch] ++;\n        }\n        for(auto ch : t) {\n            if (mp[ch] > 0) {\n                mp[ch]--;\n            } else if (mp[ch] == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n"
		],
		[
			12.960344132445083,
			4.2667695925140805,
			3,
			23.5385,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.size() != t.size()) return false;\n        unordered_map<char, int> s_map, t_map;\n        for (int i=0; i<s.size(); i++)\n        {\n            s_map[s[i]]++;\n            t_map[t[i]]++;\n        }\n        return s_map == t_map;\n    }\n};\n"
		],
		[
			6.989938367333926,
			4.266811783871503,
			1,
			9.0,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        \n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        \n        return (s == t);\n    }\n};"
		],
		[
			6.927323493535038,
			11.87059780362572,
			1,
			9.0,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n\tsort(s.begin(), s.end());\n\tsort(t.begin(), t.end());\n\treturn s == t;\n}\n};"
		],
		[
			1.0,
			1.0,
			5,
			26.9167,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int a[26]={0} ;\n        for(int i=0;i<s.length();i++)\n        {\n            a[s[i]-'a']++;\n        }\n        for(int i=0;i<t.length();i++)\n        {\n            a[t[i]-'a']--; \n        }\n        for(int i=0;i<26;i++)\n            if(a[i]) return 0;\n        return 1;\n    }\n};\n"
		],
		[
			6.880600976091475,
			4.266811389656132,
			4,
			11.4231,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        if(s.size() == 0 && t.size() == 0) return true;\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        if(s==t) return true;\n        else return false;\n        \n    }\n};"
		],
		[
			4.420019277365354,
			4.26680937537946,
			5,
			20.4,
			"class Solution {\npublic:\nbool isAnagram(string s, string t) {\n        \n        if(s.length() != t.length())\n            return false;\n        \n        int count[26] = {0};\n        int n = s.length();\n        \n        for(int i=0; i<n; i++)\n        {\n            count[s[i] - 'a']++;\n            count[t[i] - 'a']--;\n        }\n        \n        for(int i : count)\n            if(i != 0) return false;\n        \n        return true;\n        \n    }\n};"
		],
		[
			4.388695255319828,
			4.266810941020845,
			6,
			15.0,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // edge case: different lengths\n        if (s.size() != t.size()) return false;\n        // support variables\n        int freqs[128] = {};\n        // adding frequencies of s\n        for (char c: s) freqs[c]++;\n        // removing frequencies of t\n        for (char c: t) freqs[c]--;\n        // veryfying no character is mismatched\n        for (int i = 97; i < 123; i++) if (freqs[i]) return false;\n        return true;\n    }\n};\n"
		],
		[
			4.375589448473199,
			12.361778290723883,
			5,
			31.5,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map <char,int> map_s,map_t;\n        if (s.size() != t.size()){\n            return false;\n        }\n        for (int i = 0; i < s.size(); i++){\n            char s1 = s[i], t1 = t[i];\n            if (map_s.find(s1) == map_s.end()){\n                map_s[s1] = 1;\n            }else{\n                map_s[s1]++;\n            }\n            if (map_t.find(t1) == map_t.end()){\n                map_t[t1] = 1;\n            }else{\n                map_t[t1]++;\n            }\n        }\n        return map_s == map_t;\n    }\n};\n"
		],
		[
			12.161718674831373,
			11.870578994786136,
			3,
			14.875,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int n=s.size();//length of string s\n        int n1=t.size();//length of string t\n        if(n!=n1){//if length of string is not same\n            return false;\n        }\n        sort(s.begin(),s.end());//use sorting for s\n        sort(t.begin(),t.end());//use sorting t\n        if(s==t){//if both string is equal then return true\n            return true;\n        }\n        return false;\n            \n    }\n};\n"
		],
		[
			12.159892632698083,
			11.870560037619931,
			5,
			25.8,
			" class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n    if(s.size()!=t.size()){\n        return false;\n    }\n     int arr[26]={0};\n     for(int i=0;i<s.size();i++){\n         arr[int(s[i]-97)]+=1;\n     }\n     for(int i=0;i<t.size();i++){\n         if(arr[int(t[i]-97)]==0){\n              return false;\n         }\n        arr[int(t[i]-97)]-=1;\n     }   \n    return true;\n    }\n};\n"
		],
		[
			5.84663261986929,
			11.867333538031149,
			6,
			25.3333,
			"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        unordered_map<char,int> ump;\n        for(int i=0;i<s.size();i++){\n            ump[s[i]]++;\n        }\n        \n        for(int i=0;i<t.size();i++){\n            if(ump.find(t[i])!=ump.end()){\n                ump[t[i]]--;\n                if(ump[t[i]]==0) ump.erase(t[i]);\n            }else{\n                return false;\n            }\n        }\n        \n        if(ump.size()==0) return true;\n        else return false;\n    }\n};\n"
		]
	],
	"STR_SEARCH": [
		"m",
		[
			4.372447321811575,
			11.870561512899846,
			1,
			7.14286,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) \n    {\n        int res=haystack.find(needle);\n        return res;\n    }\n};\n"
		],
		[
			5.4905482913066255,
			4.901275427363401,
			7,
			34.7812,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.empty()) return 0;\n        string s = needle + \"$\" + haystack;\n        int n = s.length();\n        vector<int> ps(n, 0);\n        for(int i = 1; i < n; i++) {\n            int j = ps[i-1];\n            while(j > 0 && s[i] != s[j])\n                j = ps[j-1];\n            if(s[i] == s[j])\n                j++;\n            ps[i] = j;\n            if(j == needle.length()) return i-2*needle.length();\n        }\n        return -1;\n    }\n};\n"
		],
		[
			4.418718871153152,
			4.266808778034203,
			3,
			9.6,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n        if(strstr(haystack.c_str(),needle.c_str()))\n        {\n            size_t found;\n            found=haystack.find(needle);\n            if (found != string::npos) return found; \n            return 0;\n        }\n        return -1;\n    }\n};"
		],
		[
			5.2558132082461935,
			4.266809551804135,
			4,
			17.2308,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle == \"\") return 0;\n        int subSize = needle.length(), haySize = haystack.length();\n        for(int i=0; i<=haySize-subSize; i++) {\n            string sub = haystack.substr(i, subSize);\n            if(sub == needle)\n                return i;\n        }\n        return -1;\n    }\n};"
		],
		[
			5.108676182917121,
			4.363088844407138,
			13,
			41.6029,
			"class Solution {\nprivate:\n    void computeLPS(string pat,int m,int lps[]) { \n    // length of the previous longest prefix suffix(lps)\n    int len=0; \n    lps[0]=0;\n    int i=1; \n    while(i<m) { \n        if(pat[i]==pat[len]) { \n            len++; \n            lps[i]=len; \n            i++; \n        } \n        else {\n            if(len!=0) len=lps[len-1];\n            else { \n                lps[i]=0; \n                i++; \n            } \n        } \n    } \n    } \npublic:\n    int strStr(string txt, string pat) {\n        int c=0;\n        int n=txt.length(); \n        int m=pat.length();\n        if(m==0) return 0;\n        int lps[m];                           // lps --> longest prefix suffix\n        computeLPS(pat,m,lps); \n        int i=0,j=0; \n        while(i<n) { \n            if(pat[j]==txt[i]) { \n                j++; \n                i++; \n            }\n            if(j==m) { \n                c=1;\n                break; \n                j=lps[j-1]; \n            } \n            else if(i<n && pat[j]!=txt[i]) {  // mismatch after j matches \n            // Do not match lps[0..lps[j-1]] characters they will match anyway \n                if(j!=0) j=lps[j-1];\n                else ++i;\n            } \n        } \n        return c==1 ? (i-j) : -1;\n    }\n};\n"
		],
		[
			14.276970765819462,
			4.5730513033287785,
			11,
			51.4286,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int n=haystack.length();\n        int m=needle.length();\n        if(m==0)\n            return 0;\n        int j;\n        vector<int> dp(m,0);\n        j=0;\n        for(int i=1;i<m;i++)\n        {\n            while(j>0 && needle[j]!=needle[i])\n            {\n                j=dp[j-1];\n            }\n            if(needle[i]==needle[j])\n                j++;\n            dp[i]=j;       \n        }\n        j=0;\n        for(int i=0;i<n;i++)\n        {\n            while(j>0 && needle[j]!=haystack[i])\n                j=dp[j-1];\n            if(needle[j]==haystack[i])\n                j++;\n            if(j==m)\n                return i-j+1;           \n        }\n        return -1;\n        \n    }\n};\n\n"
		],
		[
			5.306833957756544,
			4.26680877995135,
			6,
			27.4615,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        \n        if( needle.size()==0 )   return 0;\n        if( haystack.size()==0 )    return -1;\n        \n        int h_length = haystack.size();\n        int n_length = needle.size();\n        \n        if( n_length > h_length )\n            return -1;\n        \n        for(int i=0; i<=h_length-n_length; ++i) {\n            if( needle == haystack.substr(i,n_length) )\n                return i;\n        }\n        return -1;\n    }\n};\n"
		],
		[
			12.992460118970063,
			4.26680841195611,
			17,
			51.3393,
			"class Solution {\npublic:\n    int strStr_(string s, string p) {\n        if(s == p || p.empty()) return 0;\n        if(s.size() < p.size()) return -1;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == p[0]){\n                if(s.substr(i, p.size()) == p){\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n    \n    int strStr(std::string s1, std::string s2) {\n        // using rolling hash\n        if(s1 == s2 || s2.empty()) return 0;\n        if(s1.size() < s2.size()) return -1;\n\n        int p = 10001; //1000000007; \n        int b = 7;//257;\n\n        int64_t hash1 = 0;\n        int64_t hash2 = 0;\n        int64_t power = 1;\n        for(int i = 0; i < s2.size(); i++){\n            hash2 = (hash2 * b + s2[i]) % p;\n            power = (power * b) % p;\n        }\n\n        int index = -1;\n        for(int i = 0; i < s1.size(); i++){\n            hash1 = (hash1 * b + s1[i]) % p;\n\n            if( i >= s2.size()){\n                hash1 -= power * s1[i - s2.size()] % p;\n                if( hash1 < 0){\n                    hash1 += p;\n                }\n            }\n            if( i >= s2.size() - 1 && hash1 == hash2){\n                index = i - (s2.size() - 1);\n                break;\n            }\n        }\n        return index;\n    }\n};\n"
		],
		[
			4.896630196452602,
			4.266808904074753,
			11,
			27.9286,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        // Base cases\n        auto n = haystack.length(); auto m = needle.length();\n        if (m == 0) return 0;\n        if (n == 0 || n < m) return -1;\n \n        // Hashing:\n        // or using fast integer power algo: \n        // radix^(m - 1) % prime: int h = pow(d, m - 1) % q;                                            \n        int d = 31;                                                     // radix - beneficial to make smaller      \n        int q = 15486703;                                               // some big prime\n        long p = 0; long t = 0; long h = 1;\n       \n        for (auto i = 0; i < m; ++i) {                                  // preprocessing hashes for pattern and text\n            if (i != m - 1) \n                h = (d * h) % q;\n            p = (d * p + needle[i]) % q;\n            t = (d * t + haystack[i]) % q;\n        }\n        \n        for (auto s = 0; s < n - m + 1; ++s) {\n            if (t < 0) t += q;                                           // fix negative hash\n            if (p == t)                                                  // hash matched\n                if (needle == haystack.substr(s, m))                     // collision handling\n                    return s;\n            if (s < n - m)                                               // updating hash: pop front char, push new\n                t = (d * (t - haystack[s] * h) + haystack[s + m]) % q;\n        }\n        \n        return -1;   \n    }\n};\n\n"
		],
		[
			4.8917883392759345,
			4.266809512197119,
			7,
			32.8182,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle == \"\") return 0;\n        if(needle.size() > haystack.size()) return -1;\n        \n        \n        for(int i=0; i<haystack.size(); i++) {\n            int j=0; int ind=i;\n            while(j < needle.size() && haystack[i] == needle[j]) {\n                i++; j++;\n            }\n            if(j==needle.size()) {\n                return ind;\n            }\n            i = ind; \n        }\n        \n        return -1;\n    }\n};\n"
		],
		[
			4.910720350710083,
			11.870561512899846,
			7,
			34.2,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.size() == 0) return 0;\n        for(int i = 0; i < haystack.size(); i++){\n            int j = 0;\n            for(;j < needle.size(); j++){\n                if(i + j == haystack.size()) return -1;\n                if(haystack[i + j] != needle[j]) break;\n            }\n            if(j == needle.size()) return i;\n        }\n        return -1;\n    }\n};"
		],
		[
			6.504538636592708,
			4.2677612606368385,
			11,
			34.2632,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.size() == 0) return 0;\n        unordered_map<char, int>m;\n        for(auto x: needle) m[x]++;\n        int count = needle.size();\n        int begin = 0, end = 0;\n        while(end < haystack.size()){\n            if(m[haystack[end++]]-- > 0) count--;\n            if(count == 0){\n                int i = begin, j = 0;\n                while(j < needle.size() && haystack[i] == needle[j]) i++, j++;\n                if(j == needle.size()) return begin;\n            }\n            if(end - begin == needle.size() && m[haystack[begin++]]++ >= 0) count++;\n        }\n        return -1;\n    }\n};"
		],
		[
			5.203693208436863,
			4.627231864583217,
			12,
			44.1471,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int m = haystack.size(), n = needle.size();\n        if (!n) {\n            return 0;\n        }\n        vector<int> lps = kmpProcess(needle);\n        for (int i = 0, j = 0; i < m;) {\n            if (haystack[i] == needle[j]) { \n                i++, j++;\n            }\n            if (j == n) {\n                return i - j;\n            }\n            if (i < m && haystack[i] != needle[j]) {\n                j ? j = lps[j - 1] : i++;\n            }\n        }\n        return -1;\n    }\nprivate:\n    vector<int> kmpProcess(string needle) {\n        int n = needle.size();\n        vector<int> lps(n, 0);\n        for (int i = 1, len = 0; i < n;) {\n            if (needle[i] == needle[len]) {\n                lps[i++] = ++len;\n            } else if (len) {\n                len = lps[len - 1];\n            } else {\n                lps[i++] = 0;\n            }\n        }\n        return lps;\n    }\n};"
		],
		[
			4.973102242640504,
			4.10743761780077,
			9,
			24.9688,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.size() == 0) return 0;\n        for(int i = 0; i < haystack.size(); i++)\n            if(haystack[i] == needle[0] && isEqual(haystack.substr(i), needle)) return i;\n        return -1;\n    }\n    \n    bool isEqual(string s1, string s2){\n        if(s1.size() < s2.size()) return false;\n        for(int i = 0; i < s2.size(); i++)\n            if(s1[i] != s2[i]) return false;\n        return true;\n    }\n};"
		],
		[
			4.797823505530206,
			4.266809280216143,
			8,
			38.8636,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n        \n        if(needle.length()==0)\n            return 0;\n        if(haystack.length()==0)\n            return -1;\n        \n        int i=0,j=0,start;\n        \n        while(i<haystack.length() && j<needle.length())\n        {\n            if(j==0)\n                start=i;\n                    \n            if(haystack[i]==needle[j])\n            {\n                i++;\n                j++;\n                if(j==needle.length())\n                    return i-j;\n                continue;\n            }\n            \n            j=0;\n            i=start+1;\n        }\n        \n        return -1;\n    }\n};"
		],
		[
			4.727784438646533,
			4.266808416643872,
			7,
			26.4,
			"class Solution {\npublic:\n    int strStr(std::string haystack, std::string needle) {\n\n        if(needle.empty()) return 0;\n        size_t i;\n        for(i = 0; i < haystack.size(); ++i) {\n            if(haystack[i] != needle[0]) {\n                continue;\n            }\n            for(size_t index = 0, j = i; j < haystack.size() && haystack.at(j) == needle.at(index);++j) {\n                if(++index == needle.size()) {\n                    return i;\n                } \n            }\n        }\n        return -1;\n    }\n\n};\n"
		],
		[
			4.738881338769133,
			4.266808561973395,
			8,
			36.9231,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if (needle.length() <= 0) return 0;\n        for (unsigned int i=0; i<haystack.length(); i++){\n            if (haystack[i] == needle[0]){\n                bool match = 1;\n                if (i+needle.length()-1 <= haystack.length()-1){\n                    for (unsigned int j=1; j<needle.length(); j++){\n                        if (haystack[i+j] != needle[j]) match=0;\n                    }if (match) return i;\n                }else return -1;\n            }\n        }return -1;\n    }\n};\n"
		],
		[
			4.418435936494818,
			4.266805020937362,
			2,
			13.0,
			"class Solution {\npublic:\n        \n    int strStr(string haystack, string needle) {\n        const char* a=haystack.c_str(), *b=needle.c_str();\n        const char* c=strstr(a, b);\n        if(c==NULL) return -1;\n        return c-a;\n    }\n};\n"
		],
		[
			4.818105044982189,
			4.266807473383308,
			5,
			30.5455,
			"class Solution\n{\npublic:\n\tint strStr(string haystack, string needle)\n\t{\n\t\tint len = haystack.size() - needle.size() + 1;\n\t\tfor (int i = 0; i < len; ++i)\n\t\t{\n\t\t\tint j = 0;\n\t\t\twhile (j < needle.size()) \n\t\t\t{\n\t\t\t\tif (haystack[i + j] != needle[j]) break;\n\t\t\t\telse ++j;\n\t\t\t}\n\t\t\tif (j == needle.size()) return i;\n\t\t}\n\t\treturn -1;\n\t}\n};"
		],
		[
			4.987057504539949,
			4.573042158683046,
			14,
			48.875,
			"class Solution {\npublic:\n    //use kmp\n    vector<int> f;\n   // it should be needle. sorry for carelessness. pass needle to it.\n    void failure(string& haystack){\n        for(int i = 1, j = -1;i < haystack.length(); ++i){\n            while(j >= 0 && haystack[j + 1] != haystack[i]){\n                j = f[j];\n            }\n            if(haystack[j + 1] == haystack[i]){\n                ++j;\n            }\n            f[i] = j;\n        }\n    }\n    int search(string& haystack, string& needle){\n        for(int i = 0, j = -1;i < haystack.length(); ++i){\n            while(j >= 0 && needle[j + 1] != haystack[i]){\n                j = f[j];\n            }\n            if(needle[j + 1] == haystack[i]){\n                ++j;\n            }\n            if(j == needle.length() - 1){\n                return i - needle.length() + 1;\n            }\n        }\n        return -1;\n    }\n    int strStr(string haystack, string needle) {\n        if(haystack.length() < needle.length()){\n            return -1;\n        }else if(needle == \"\"){\n            return 0;\n        }\n        f = vector<int>(haystack.length(), -1);\n        failure(needle);\n        return search(haystack, needle);\n    }\n};"
		],
		[
			5.296626603919544,
			4.266805030661436,
			9,
			39.3421,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle==\"\") return 0;\n        int len1 = haystack.length(), len2 = needle.length();\n        if(len1<len2) return -1;\n        map<char, int> mapping;\n        for(int i = 0;i<needle.size();++i)\n            mapping[needle[i]] = i;\n\n        int i = 0;\n        while(i<=len1-len2){\n            int j = 0;\n            for(;j<len2;++j){\n                if(haystack[i+j] != needle[j]){\n                    char c = haystack[i+len2];\n                    if(mapping.find(c)==mapping.end()) i += len2+1;\n                    else i += len2-mapping[c];\n                    break;\n                }\n            }\n            if(j == len2) return i;\n        }\n        return -1;\n    }\n};"
		],
		[
			4.8732652917488775,
			11.870561512899846,
			6,
			32.7273,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n\n        if(haystack.size() < needle.size())\n            return -1;\n        \n        int index = 0;\n        int i,j;\n        for(i = 0, j = 0;i < haystack.size() && j < needle.size();){\n            if(haystack[i] == needle[j]){\n                i++; j++;\n            }else{\n               index++;\n               i = index;\n               j = 0;\n            }\n        }\n    \n        if(j == needle.size())\n            return index;\n        return -1;\n   }\n};"
		],
		[
			4.815396071737493,
			4.2668087152245295,
			5,
			29.2917,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int n= haystack.size();\n        int m= needle.size();\n        if(m==0){\n            return 0;\n        }\n        int j=0;\n        for(int i=0;i<n;i++){\n            if(haystack[i]==needle[j]){\n                j++;\n            }else{\n                i=i-j;\n                j=0;\n            }\n            if(j==m){\n                return i-j+1;\n            }\n        }\n        return -1;\n    }\n};\n"
		],
		[
			4.780435019546724,
			12.361691726291639,
			13,
			35.625,
			"class Solution {\npublic:\n    // KMP match algorithm\n    int strStr(string haystack, string needle) {\n        if(needle==\"\") return 0;\n        int len1 = haystack.size(), len2 = needle.size();\n        if(len1<len2) return -1;\n        \n        vector<int> lps(needle.size());\n        computeLPSArray(needle, lps);\n        int i = 0 , j = 0;\n        while(i<len1 && j<len2){\n            if(haystack[i] == needle[j]){\n                ++i;\n                ++j;\n            }else if(j) j = lps[j-1];\n            else ++i;\n        }\n        if(j == len2) return i-j;\n        return -1;\n    }\n    //calculate string needle's lps (longest prefix and suffix length) array\n    void computeLPSArray(string & needle, vector<int> & lps){\n        if(lps.size()!=needle.size()) return;\n        lps[0] = 0;\n        int len = 0, i = 1;\n        while(i<needle.size()){\n            if(needle[len] == needle[i]) lps[i++] = ++len;\n            else if(len) len = lps[len-1];\n            else lps[i++] = 0;\n        }\n    }\n};"
		],
		[
			4.890102675678115,
			4.266809551804135,
			6,
			24.6,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n     \n    if (needle.empty()) return 0;\n    \n    int i,j =0;  \n    int startOfMatch = INT_MAX;\n    \n    while (i < haystack.size()){\n        \n        if (haystack[i] == needle[j]){\n            startOfMatch = min(startOfMatch, i); \n            ++j; ++i;\n        }\n        else{\n            if (startOfMatch == INT_MAX) startOfMatch = 0;\n            i = ++startOfMatch; \n            j = 0; \n        }\n        if (j==needle.size()) return startOfMatch;\n    }\n    return -1;\n     \n    \n}\n};"
		],
		[
			5.285322928442467,
			4.762282366670037,
			10,
			38.0,
			"class Solution {\npublic:\nvoid kmp(string haystack, string needle, vector<int> &psl, int &pos, bool build = true) {\n    int hl = haystack.length(), nl = needle.length();\n    if (nl == 0) {\n        pos = 0;\n        return;\n    } \n    if (build) psl.resize(hl);\n    for (int i = 0, j = build ? 1 : 0; j < hl; j++) {\n        if (needle[i] == haystack[j]) {\n            i++;\n        } else if (i > 0) {\n            i = psl[i - 1];\n            j--;\n            continue;\n        }\n        if (build) psl[j] = i;\n        else if (i ==  nl) {\n            pos = j - nl + 1;\n            return;\n        }\n    }\n    \n}\nint strStr(string haystack, string needle) {\n    vector<int> psl;\n    int pos = -1;\n    kmp(needle, needle, psl, pos);\n    kmp(haystack, needle, psl, pos, false);\n    return pos;\n}\n};"
		],
		[
			5.157570842791127,
			4.4433672619053945,
			11,
			49.2857,
			"class Solution {\npublic:\n  int strStr(const string &T, const string &P) {\n    if (P.empty()) return 0;\n\n    vector<int> pi(P.size(), 0);\n    for (int i = 1, k = 0; i < P.size(); ++i) {\n      while (k && P[k] != P[i]) k = pi[k - 1];\n      if (P[k] == P[i]) ++k;\n      pi[i] = k;\n    }\n\n    for (int i = 0, k = 0; i < T.size(); ++i) {\n      while (k && P[k] != T[i]) k = pi[k - 1];\n      if (P[k] == T[i]) ++k;\n      if (k == P.size()) return i - k + 1;\n    }\n\n    return -1;\n  }\n};"
		],
		[
			12.903518945020902,
			4.26680846954468,
			5,
			28.5,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n    for (int i = 0; i < (int)(haystack.size()-needle.size()+1); i++) {\n        int j = 0;\n        while (j < needle.size() && haystack[i+j] == needle[j])\n            j++;\n        if (j == needle.size()) \n            return i;\n    }\n    return -1;\n}\n};"
		],
		[
			13.62294305158748,
			4.266806401176554,
			5,
			24.0,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int m = haystack.size(), n = needle.size(), p = 0;\n        while (p + n - 1 < m) {\n            if (haystack.substr(p, n) == needle) {\n                return p;\n            }\n            while (p++ + n - 1 < m && haystack[p] != needle[0]);\n        }\n        return -1;\n    }\n};"
		],
		[
			4.374406789944025,
			4.26680877995135,
			1,
			6.0,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        return haystack.find(needle);\n    }\n};"
		],
		[
			16.08755699729304,
			4.901275366407102,
			8,
			44.625,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if (!needle.size()) return 0;\n        string combo = needle + '#' + haystack;\n        vector<int> z(combo.size());\n        int high = 0, it = 0;\n        for (int i = 1; i < combo.size(); ++i) {\n            high = max(high, i);\n            if (high > i && z[i - it] + i != high) {\n                z[i] = min(z[i - it], high - i);\n            } else {\n                it = i;\n                while(high < combo.size() && combo[high] == combo[high - i]) {\n                    high++;\n                }\n                z[i] = high - i;\n                if (z[i] == needle.size()) {\n                    return i - needle.size() - 1;\n                }\n            }\n        }\n        return -1;\n        \n    }\n};\n"
		],
		[
			12.113868244644152,
			4.266808904074753,
			1,
			6.0,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        return haystack.find(needle);\n    }\n};\n"
		],
		[
			3.9204182733572033,
			1.0,
			6,
			30.9091,
			"class Solution {\npublic:\nint strStr(string h, string n) {\n    int j;\n    if(n.size()==0)\n        return 0;\n    for(int i=0;i<=(int)(h.length()-n.length());i++)\n    {\n        for(j=0;j<n.length();j++)\n        {\n            if(h[i+j]!=n[j])\n               break;\n        }\n        if(j==n.length())\n           return i;\n    }\n    return -1;\n   }\n };\n"
		],
		[
			12.611481296525639,
			4.266807706709919,
			5,
			36.2727,
			"class Solution {\npublic:\n\tint strStr(string haystack, string needle) {\n\t\tint needle_len = needle.length();\n\t\tint haystack_len = haystack.length();\n\t\tif(needle_len==0){\n\t\t\treturn 0;\n\t\t}\n\t\tint j = 0;\n\t\tfor(int i = 0 ; i < haystack_len ; i++){\n\n\t\t\tif(haystack[i] == needle[j]){\n\t\t\t\tj++;\n\t\t\t}else{\n\t\t\t\ti = i-j;\n\t\t\t\tj = 0;\n\t\t\t}\n\t\t\tif(j==needle_len){\n\t\t\t\treturn i - j +1 ;\n\t\t\t}\n\n\t\t}\n\t\treturn -1;\n\t}\n};"
		],
		[
			4.12754035127869,
			3.981074399793492,
			5,
			25.8333,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int m = haystack.size(), n = needle.size();\n        for (int i = 0; i <= m - n; i++) {\n            int j = 0;\n            for (; j < n; j++) {\n                if (haystack[i + j] != needle[j]) {\n                    break;\n                }\n            }\n            if (j == n) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};"
		],
		[
			7.595557507474571,
			3.9774278325742363,
			5,
			38.5714,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n        int sz_haystack = haystack.size();\n    \tint sz_needle = needle.size();\n    \tfor (int i = 0; i+sz_needle-1 < sz_haystack;)\n    \t{\n    \t\tif (needle == haystack.substr(i, sz_needle))\n    \t\t\treturn i;\n    \t\telse\n    \t\t{\n    \t\t    int step = sz_needle;\n    \t\t\tfor (int j = 0; j <= sz_needle-2; j++)\n    \t\t\t{\n    \t\t\t    if (haystack[i+sz_needle-1] == needle[j])\n    \t\t\t        step = sz_needle-1-j;\n    \t\t\t}\n    \t\t\ti = i+step;\n    \t\t}\n    \t}\n    \treturn -1;\n    }\n};"
		],
		[
			4.810735005153832,
			4.266810187678078,
			8,
			32.1562,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n    \n        if(needle.size() > haystack.size())\n    \t\treturn -1;\n    \n    \tif(needle.size() < 1)\n    \t\treturn 0;\n    \n    \tint hsize = haystack.size();\n    \tint nsize = needle.size();\n    \tbool isNeedle;\n    \t\n    \tfor(int i = 0; i <= hsize - nsize; i++)\n    \t{\n    \t\tif(haystack[i] == needle[0])\n    \t\t{\n    \t\t\tisNeedle = true;\n    \n    \t\t\tfor(int j =1; j < nsize; j++)\n    \t\t\t{\n    \t\t\t\tif(haystack[i+j] != needle[j])\n    \t\t\t\t{\n    \t\t\t\t\tisNeedle = false;\n    \t\t\t\t\tbreak;\n    \t\t\t\t}\n    \t\t\t}\n    \n    \t\t\tif(isNeedle)\n    \t\t\t\treturn i;\n    \t\t}\n    \t}\n    \n    \treturn -1; \n    \n    }\n};"
		],
		[
			4.621838608710214,
			12.36179775857442,
			7,
			27.5,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int lenh = haystack.length();\n        int lenn = needle.length();\n        bool flag = true;\n        if(needle == \"\") return 0;\n        for(int i = 0; i < lenh - lenn + 1; i++) {\n            if(haystack[i] == needle[0]) {\n                for(int j = 0; j < lenn; j++) {\n                    if(haystack[j + i] != needle[j]) {\n                        flag = false;\n                        break;\n                    } else flag = true;\n                }\n                if(flag) return i;\n            }\n        }\n        return -1;\n    }\n};"
		],
		[
			7.576883693532479,
			3.9810798557686007,
			7,
			25.9667,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if (needle.empty()) { return 0; }\n        if (needle.size() > haystack.size()) { return -1; }\n        for (int i = 0; i < haystack.size() - needle.size() + 1; ++i) {\n            bool match = true;\n            for (int j = 0; j < needle.size(); ++j) {\n                if (haystack[i + j] != needle[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) { return i; }\n        }\n        return -1;\n    }\n};"
		],
		[
			4.922633354087852,
			4.266807968279502,
			7,
			32.3077,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n    if(haystack.size() == 0 && needle.size() == 0) return 0;\n    int pos = 0, diff = static_cast<int>(haystack.size()-needle.size());\n    for(;pos <= diff;pos++){\n        int j = 0;\n        for(; j < needle.size(); j++)\n            if(haystack[pos+j]!=needle[j]) break;\n        if(j == needle.size()) return pos;\n    }\n    return -1;\n}\n};"
		],
		[
			4.354148098990878,
			11.870561512899846,
			1,
			6.0,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\nreturn haystack.find(needle);\n}\n};"
		],
		[
			5.3167322051431976,
			4.2668087152245295,
			3,
			18.5455,
			"class Solution \n{\npublic:\n\tint strStr(string haystack, string needle)\n\t{\n\t\tint len = haystack.size() - needle.size() + 1;\n\t\tfor (int i = 0; i < len; ++i)\n\t\t{\n\t\t\tif (haystack.substr(i, needle.size()) == needle) return i;\n\t\t}\n\t\treturn -1;\n\t}\n};"
		],
		[
			4.408565113504344,
			4.266808778034203,
			1,
			6.0,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        return haystack.find(needle);\n    }\n};"
		],
		[
			1.0,
			1.0,
			6,
			34.8333,
			"class Solution {\npublic:\n    int strStr(char *a, char *b) {\n        int len_b = strlen(b);\n        int len_a = strlen(a);\n        if (len_a < len_b) return -1;\n        \n        for (int i = 0; i <= len_a-len_b; ++i) {\n            int j = 0;\n            while(j < len_b && a[j+i] == b[j]) {\n                j++;\n            }\n            if (j == len_b) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};"
		],
		[
			4.155719438443012,
			3.981073314161204,
			2,
			8.25,
			"class Solution {\npublic:\nint strStr(const string& haystack,const string& needle) {\n\tif (needle == \"\") return 0;\n\treturn haystack.find(needle);\n}\n};"
		],
		[
			4.707560619242039,
			4.266809523872782,
			7,
			33.3333,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\nint sn = needle.size();\nif(sn==0)\nreturn 0;\n\n    int cnt=0;\n    int sh=haystack.size();\n    int i=0, j,x;\n    int search = sh-sn+1;\n\n        for(j=0;j<search;j++){\n            x=j;\n            while(haystack[x]==needle[i] && x<sh&&i<sn){\n                ++i;\n                ++cnt;\n                ++x;\n            }\n            if(cnt==sn) return j;\n            else {\n                i=0;\n                cnt=0;\n            }\n        }   \n    return -1;\n}\n};"
		],
		[
			14.017662838391344,
			4.26680846954468,
			9,
			36.25,
			"//KMP\nclass Solution {\npublic:\nint strStr(string haystack, string needle) {\nint sn = needle.size();\nif(sn==0)\nreturn 0;\n\n    int sh=haystack.size();\n    \n    //pre-compute how many characters can be skipped when a sub-string of needle was matched previously.\n    //For the pattern \u201cAAAA\u201d, skip[] is [0, 1, 2, 3]\n    //For the pattern \u201cABCDE\u201d, is [0, 0, 0, 0, 0]\n    //For the pattern \u201cAABAACAABAA\u201d, is [0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 5]\n    //For the pattern \u201cAAACAAAAAC\u201d, is [0, 1, 2, 0, 1, 2, 3, 3, 3, 4]         \n    \n    int skip[sn];\n    skip[0] = 0;\n    int i = 1, len = 0; \n    while (i < sn) { \n        if (needle[i] == needle[len]) { \n            len++; \n            skip[i] = len; \n            i++; \n        } \n        else{ // (needle[i] != needle[len]) \n            if (len != 0) { \n                len = skip[len - 1]; \n            } \n            else{ // if (len == 0)  \n                skip[i] = 0; \n                i++; \n            } \n        } \n    } \n    \n    //matching \n            \n    i=0;\n    len =0;\n    for(len=0;len<sh;){\n        while(haystack[len]==needle[i] ){\n            ++i;\n            ++len;\n            if(i==sn) return (len-sn);\n         }\n         \n        if(i==0){\n            ++len;\n            continue;\n        }\n        else{\n            i=skip[i-1];\n        }\n    }\n    return -1;\n}\n};"
		],
		[
			4.682831525438655,
			4.266806401176554,
			5,
			28.0,
			"class Solution {\npublic:\nint strStr(string haystack, string needle) {\n\tint n=haystack.length(), m=needle.length();\n\tfor(int i=0;i<n-m+1;i++){\n\t\tint j=0;\n\t\twhile(j<m){\n\t\t\tif(haystack[i+j]==needle[j]) j++;\n\t\t\telse break;\n\t\t}\n\t\tif(j==m) return i;\n\t}\n\treturn -1;\n}\n};"
		],
		[
			5.179285577303364,
			4.627232411098314,
			14,
			29.6739,
			"class Solution {\npublic:\n    // calculate the lps function\n    vector<int> calc(string pat, int m)\n    {\n        vector<int> lps(m,0);\n        int i=1, j=0;\n        while(i<m){\n            if(pat[i]==pat[j]){\n                j++;\n                lps[i++]=j;\n            }\n            else{\n                if(j) j=lps[j-1];\n                else lps[i++]=0;\n            }\n        }\n        return lps;\n    }\n    int strStr(string haystack, string needle) {\n        int n=haystack.length(), m=needle.length();\n        if(m==0) return 0;\n        vector<int> lps = calc(needle, m);\n        int i=0,j=0;\n        while(i<n && j<m){\n            if(haystack[i]==needle[j]){\n                i++;\n                j++;\n            }\n            if(j==m) return i-j; // since we are returning the first valid index, we just return i-j. If we had to return all valid indices, then we would have to do j=lps[j-1] after this step, since pattern can repeat, and the new pattern may already have started.\n            else if(i<n && j<m && haystack[i]!=needle[j]){\n                if(j) j=lps[j-1];\n                else i++;\n            }\n        }\n        return -1;\n    }\n};"
		],
		[
			5.483440342410734,
			4.959345841043931,
			12,
			44.85,
			"class Solution {\npublic:\n    vector<int> calc(string pat) // calculates the Z-array\n    {\n        int n=pat.length();\n        vector<int> z(n,0);\n        int L=0, R=0, i=1;\n        for(;i<n;i++){\n            if(i>R){  // i is not in the Z-box.\n                L=R=i;\n                while(R<n && pat[R-L]==pat[R]) R++;\n                z[i]=R-L;\n                R--;\n            }\n            else{\n                int k=i-L;\n                if(z[k]<R-i+1) z[i]=z[k];\n                else{\n                    L=i;\n                    while(R<n && pat[R-L]==pat[R]) R++;\n                    z[i]=R-L;\n                    R--;\n                }\n            }\n        }\n        return z;\n    }\n    \n    int strStr(string haystack, string needle) {\n        int n=haystack.length(), m=needle.length();\n        if(m==0) return 0;\n        string res=needle+\"$\"+haystack;   // we find the z array for [pat + '$' + text]\n        vector<int> z=calc(res);\n        for(int i=0;i<res.length();i++){\n            if(z[i]==m) return i-m-1;\n        }\n        return -1;\n    }\n};"
		],
		[
			5.262353120885842,
			4.266808957992769,
			4,
			18.5294,
			"class Solution\n{\npublic:\n\nint strStr(std::string haystack, std::string needle) \n{     \n    const auto dim1 = haystack.size();\n    const auto dim2 = needle.size();\n    \n    int pos = 0;\n    \n    while(true)\n    {\n        const auto tmp = haystack.substr(pos, dim2);\n        \n        if(tmp == needle) return pos;\n        \n        pos++;\n        \n        if(pos + dim2 > dim1) break;\n    }\n          \n    return -1;\n}\n};"
		],
		[
			4.3718028184265885,
			11.870599633850185,
			2,
			9.0,
			"class Solution\n{\npublic:\n\nint strStr(std::string haystack, std::string needle) \n{      \n    const auto pos = haystack.find(needle);\n    \n    if (pos != std::string::npos)\n    {\n        return pos;\n    }\n    \n    return -1;\n}\n};"
		],
		[
			4.673690210463663,
			4.266805433631428,
			15,
			51.9706,
			"class Solution {\npublic:\n    void computelps(string pattern,int n,vector<int>&lps) {\n        int i=1;\n        int len =0 ;\n        lps[0]=0;\n        while(i<n) {\n            if(pattern[i] == pattern[len]) {\n                len++;\n                lps[i] =len;\n                i++;\n            }\n            else  {\n                if(len!=0) {\n                    len = lps[len-1];\n                }\n                else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n    }\n    \n    \n    int strStr(string word, string pattern) {\n        int m = word.length();\n        int n = pattern.length();\n        if(n==0) return 0;\n        if(m==0 && n==0)\n            return 0;\n        if(n>m) return -1;\n        vector<int> lps(n);\n        computelps(pattern , n, lps);\n        int i=0 ,j =0;\n        while(i<m) {\n            if(pattern[j] == word[i]) {\n                i++;\n                j++;\n            }\n            if(j==n) \n                return i-j;\n            if(i<m && pattern[j]!=word[i]) {\n                if(j!=0)\n                    j = lps[j-1];\n                else\n                    i++;\n            }\n        }\n        return -1;\n    }\n};\n"
		],
		[
			5.247902266573542,
			4.901280978906284,
			6,
			30.8824,
			"class Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(needle.empty())\n            return 0;\n        \n        string kmp = needle + \"#\" + haystack;\n        \n        int m = kmp.size(), n = needle.size();\n        \n        vector<int> lps(m , 0);\n        \n        for(int i = 1, len = 0; i < m;){\n            if(kmp[i] == kmp[len]){\n                lps[i] = ++len;\n                if(len == n)\n                    return i - 2 * n;\n                ++i;\n            }\n            else if(len == 0)\n                lps[i++] = 0;\n            else\n                len = lps[len - 1];\n        }\n        return -1;\n    }\n};\n"
		],
		[
			4.354626031134776,
			11.870583181751352,
			3,
			9.0,
			"\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        if(!needle.length())return 0;\n        size_t ind=haystack.find(needle);\n        return (ind==string::npos)?-1:ind;\n    }\n};\n"
		],
		[
			4.676613813218845,
			4.266808902620773,
			6,
			29.7667,
			"class Solution {\n\npublic:\n    int strStr(string haystack, string needle) \n    {\n        int hay_len = haystack.length();\n        int need_len = needle.length();\n        int match_len = hay_len-need_len;\n        \n        if( need_len == 0 )\n            return 0;\n        \n        for(int i=0 ;i <= match_len ; i++)\n        {   \n               int j=i, k = 0;\n               while( k < need_len && haystack[j] == needle[k]) \n               {\n                  k++;j++;\n               }\n               if( k == need_len)\n                  return i;\n        }\n        return -1;\n    }\n};\n"
		]
	]
}